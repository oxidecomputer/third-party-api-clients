//! A fully generated, opinionated API client library for GitHub.
//!
//! This library is generated from the [GitHub OpenAPI
//! specs](https://github.com/github/rest-api-description). This way it will remain
//! up to date as features are added. The documentation for the crate is generated
//! along with the code to make this library easy to use.
//!
//! To install the library, add the following to your `Cargo.toml` file.
//!
//! ```toml
//! [dependencies]
//! github_api_client = "0.1.0"
//! ```
//!
//! ## Basic example
//!
//! Typical use will require intializing a `Client`. This requires
//! a user agent string and set of `auth::Credentials`.
//!
//! ```
//! use github_api_client::{auth::Credentials, Client};
//!
//! let github = Client::new(String::from("user-agent-name"), Credentials::Token(String::from("personal-access-token")));
//! ```
//!
//! If you are a GitHub enterprise customer, you will want to create a client with the
//! [Client#host](struct.Client.html#method.host) method.
//!
//! ## Feature flags
//!
//! ### httpcache
//!
//! Github supports conditional HTTP requests using etags to checksum responses
//! Experimental support for utilizing this to cache responses locally with the
//! `httpcache` feature flag.
//!
//! To enable this, add the following to your `Cargo.toml` file:
//!
//! ```toml
//! [dependencies]
//! github_api_client = { version = "0.1.0", features = ["httpcache"] }
//! ```
//!
//! Then use the `Client::custom` constructor to provide a cache implementation.
//!
//! Here is an example:
//!
//! ```
//! #[cfg(feature = "httpcache")]
//! use github_api_client::http_cache::HttpCache;
//! use github_api_client::{auth::Credentials, Client};
//!
//! #[cfg(feature = "httpcache")]
//! let http_cache = HttpCache::in_home_dir();
//!
//! #[cfg(not(feature = "httpcache"))]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::Token(String::from("personal-access-token")),
//!     reqwest::Client::builder().build().unwrap(),
//! );
//!
//! #[cfg(feature = "httpcache")]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::Token(String::from("personal-access-token")),
//!     reqwest::Client::builder().build().unwrap(),
//!     http_cache,
//! );
//! ```
//! ## Authenticating GitHub apps
//!
//! You can also authenticate via a GitHub app.
//!
//! Here is an example:
//!
//! ```rust
//! use std::env;
//!
//! #[cfg(feature = "httpcache")]
//! use github_api_client::http_cache::FileBasedCache;
//! use github_api_client::{
//!     auth::{Credentials, InstallationTokenGenerator, JWTCredentials},
//!     Client,
//! };
//!
//! let app_id_str = env::var("GH_APP_ID").unwrap();
//! let app_id = app_id_str.parse::<u64>().unwrap();
//!
//! let app_installation_id_str = env::var("GH_INSTALLATION_ID").unwrap();
//! let app_installation_id = app_installation_id_str.parse::<u64>().unwrap();
//!
//! let encoded_private_key = env::var("GH_PRIVATE_KEY").unwrap();
//! let private_key = base64::decode(encoded_private_key).unwrap();
//!
//! // Decode the key.
//! let key = nom_pem::decode_block(&private_key).unwrap();
//!
//! // Get the JWT credentials.
//! let jwt = JWTCredentials::new(app_id, key.data).unwrap();
//!
//! #[cfg(feature = "httpcache")]
//! {
//!     // Create the HTTP cache.
//!     let mut dir = dirs::home_dir().expect("Expected a home dir");
//!     dir.push(".cache/github");
//!     let http_cache = Box::new(FileBasedCache::new(dir));
//! }
//!
//! let token_generator = InstallationTokenGenerator::new(app_installation_id, jwt);
//!
//! #[cfg(not(feature = "httpcache"))]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::InstallationToken(token_generator),
//!     reqwest::Client::builder().build().unwrap(),
//! );
//!
//! #[cfg(feature = "httpcache")]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::InstallationToken(token_generator),
//!     reqwest::Client::builder().build().unwrap(),
//!     http_cache,
//! );
//! ```
//!
//! ## Acknowledgements
//!
//! Shout out to [hubcaps](https://github.com/softprops/hubcaps) for paving the
//! way here. This extends that effort in a generated way so the library is
//! always up to the date with the OpenAPI spec and no longer requires manual
//! contributions to add new endpoints.
#![feature(async_stream)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::nonstandard_macro_braces)]
#![allow(missing_docs)]

pub mod auth;
#[cfg(feature = "httpcache")]
pub mod http_cache;
#[doc(hidden)]
pub mod utils;

use anyhow::{anyhow, Error, Result};
use async_recursion::async_recursion;
use chrono::{DateTime, Utc};

const DEFAULT_HOST: &str = "https://api.github.com";

mod progenitor_support {
    use percent_encoding::{utf8_percent_encode, AsciiSet, CONTROLS};

    const PATH_SET: &AsciiSet = &CONTROLS
        .add(b' ')
        .add(b'"')
        .add(b'#')
        .add(b'<')
        .add(b'>')
        .add(b'?')
        .add(b'`')
        .add(b'{')
        .add(b'}');

    pub(crate) fn encode_path(pc: &str) -> String {
        utf8_percent_encode(pc, PATH_SET).to_string()
    }
}

/// The data types sent to and returned from the API client.
pub mod types {
    use chrono::{DateTime, NaiveDate, Utc};
    use schemars::JsonSchema;
    use serde::{Deserialize, Serialize};

    /// Simple User
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct User {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        /**
         * Simple User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Simple User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub site_admin: bool,
        /**
         * Simple User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// The set of permissions for the GitHub app
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Permissions {
        /**
         * The set of permissions for the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub checks: String,
        /**
         * The set of permissions for the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents: String,
        /**
         * The set of permissions for the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments: String,
        /**
         * The set of permissions for the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues: String,
        /**
         * The set of permissions for the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub metadata: String,
    }

    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Integration {
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * The list of events for the GitHub app
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the GitHub app
         */
        #[serde(default)]
        pub id: i64,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        /**
         * The name of the GitHub app
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        /**
         * The set of permissions for the GitHub app
         */
        #[serde()]
        pub permissions: Permissions,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    /// Basic Error
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BasicError {
        /**
         * Basic Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        /**
         * Basic Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * Basic Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        /**
         * Basic Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Validation Error Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ValidationErrorSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        /**
         * Validation Error Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    /// Configuration object of the webhook
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WebhookConfig {
        /**
         * Configuration object of the webhook
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        /**
         * Configuration object of the webhook
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        /**
         * Configuration object of the webhook
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        /**
         * Configuration object of the webhook
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// An enterprise account
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Enterprise {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * An enterprise account
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the enterprise
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the enterprise.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The slug url identifier for the enterprise.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * An enterprise account
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub website_url: String,
    }

    /**
     * The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Actions {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Actions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Actions::Read => "read",
                Actions::Write => "write",
                Actions::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Actions {
        fn default() -> Actions {
            Actions::Noop
        }
    }

    /**
     * The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Administration {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Administration {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Administration::Read => "read",
                Administration::Write => "write",
                Administration::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Administration {
        fn default() -> Administration {
            Administration::Noop
        }
    }

    /**
     * The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Checks {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Checks {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Checks::Read => "read",
                Checks::Write => "write",
                Checks::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Checks {
        fn default() -> Checks {
            Checks::Noop
        }
    }

    /**
     * The level of permission to grant the access token for notification of content references and creation content attachments. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ContentReferences {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for ContentReferences {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ContentReferences::Read => "read",
                ContentReferences::Write => "write",
                ContentReferences::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ContentReferences {
        fn default() -> ContentReferences {
            ContentReferences::Noop
        }
    }

    /**
     * The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Contents {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Contents {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Contents::Read => "read",
                Contents::Write => "write",
                Contents::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Contents {
        fn default() -> Contents {
            Contents::Noop
        }
    }

    /**
     * The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Deployments {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Deployments {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Deployments::Read => "read",
                Deployments::Write => "write",
                Deployments::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Deployments {
        fn default() -> Deployments {
            Deployments::Noop
        }
    }

    /**
     * The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Environments {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Environments {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Environments::Read => "read",
                Environments::Write => "write",
                Environments::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Environments {
        fn default() -> Environments {
            Environments::Noop
        }
    }

    /**
     * The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Issues {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Issues {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Issues::Read => "read",
                Issues::Write => "write",
                Issues::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Issues {
        fn default() -> Issues {
            Issues::Noop
        }
    }

    /**
     * The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Metadata {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Metadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Metadata::Read => "read",
                Metadata::Write => "write",
                Metadata::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Metadata {
        fn default() -> Metadata {
            Metadata::Noop
        }
    }

    /**
     * The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Packages {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Packages {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Packages::Read => "read",
                Packages::Write => "write",
                Packages::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Packages {
        fn default() -> Packages {
            Packages::Noop
        }
    }

    /**
     * The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Pages {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Pages {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Pages::Read => "read",
                Pages::Write => "write",
                Pages::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Pages {
        fn default() -> Pages {
            Pages::Noop
        }
    }

    /**
     * The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullRequests {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for PullRequests {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullRequests::Read => "read",
                PullRequests::Write => "write",
                PullRequests::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullRequests {
        fn default() -> PullRequests {
            PullRequests::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum RepositoryHooks {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for RepositoryHooks {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                RepositoryHooks::Read => "read",
                RepositoryHooks::Write => "write",
                RepositoryHooks::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for RepositoryHooks {
        fn default() -> RepositoryHooks {
            RepositoryHooks::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum RepositoryProjects {
        Admin,
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for RepositoryProjects {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                RepositoryProjects::Admin => "admin",
                RepositoryProjects::Read => "read",
                RepositoryProjects::Write => "write",
                RepositoryProjects::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for RepositoryProjects {
        fn default() -> RepositoryProjects {
            RepositoryProjects::Noop
        }
    }

    /**
     * The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SecretScanningAlerts {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for SecretScanningAlerts {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SecretScanningAlerts::Read => "read",
                SecretScanningAlerts::Write => "write",
                SecretScanningAlerts::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SecretScanningAlerts {
        fn default() -> SecretScanningAlerts {
            SecretScanningAlerts::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Secrets {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Secrets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Secrets::Read => "read",
                Secrets::Write => "write",
                Secrets::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Secrets {
        fn default() -> Secrets {
            Secrets::Noop
        }
    }

    /**
     * The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SecurityEvents {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for SecurityEvents {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SecurityEvents::Read => "read",
                SecurityEvents::Write => "write",
                SecurityEvents::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SecurityEvents {
        fn default() -> SecurityEvents {
            SecurityEvents::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SingleFile {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for SingleFile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SingleFile::Read => "read",
                SingleFile::Write => "write",
                SingleFile::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SingleFile {
        fn default() -> SingleFile {
            SingleFile::Noop
        }
    }

    /**
     * The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Statuses {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Statuses {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Statuses::Read => "read",
                Statuses::Write => "write",
                Statuses::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Statuses {
        fn default() -> Statuses {
            Statuses::Noop
        }
    }

    /**
     * The level of permission to grant the access token to retrieve Dependabot alerts. Can be one of: `read`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum VulnerabilityAlerts {
        Read,
        Noop,
    }

    impl std::fmt::Display for VulnerabilityAlerts {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                VulnerabilityAlerts::Read => "read",
                VulnerabilityAlerts::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for VulnerabilityAlerts {
        fn default() -> VulnerabilityAlerts {
            VulnerabilityAlerts::Noop
        }
    }

    /**
     * The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Workflows {
        Write,
        Noop,
    }

    impl std::fmt::Display for Workflows {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Workflows::Write => "write",
                Workflows::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Workflows {
        fn default() -> Workflows {
            Workflows::Noop
        }
    }

    /**
     * The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Members {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for Members {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Members::Read => "read",
                Members::Write => "write",
                Members::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Members {
        fn default() -> Members {
            Members::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationAdministration {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationAdministration {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationAdministration::Read => "read",
                OrganizationAdministration::Write => "write",
                OrganizationAdministration::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationAdministration {
        fn default() -> OrganizationAdministration {
            OrganizationAdministration::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationHooks {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationHooks {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationHooks::Read => "read",
                OrganizationHooks::Write => "write",
                OrganizationHooks::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationHooks {
        fn default() -> OrganizationHooks {
            OrganizationHooks::Noop
        }
    }

    /**
     * The level of permission to grant the access token for viewing an organization's plan. Can be one of: `read`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationPlan {
        Read,
        Noop,
    }

    impl std::fmt::Display for OrganizationPlan {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationPlan::Read => "read",
                OrganizationPlan::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationPlan {
        fn default() -> OrganizationPlan {
            OrganizationPlan::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage organization projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationProjects {
        Admin,
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationProjects {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationProjects::Admin => "admin",
                OrganizationProjects::Read => "read",
                OrganizationProjects::Write => "write",
                OrganizationProjects::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationProjects {
        fn default() -> OrganizationProjects {
            OrganizationProjects::Noop
        }
    }

    /**
     * The level of permission to grant the access token for organization packages published to GitHub Packages. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationPackages {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationPackages {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationPackages::Read => "read",
                OrganizationPackages::Write => "write",
                OrganizationPackages::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationPackages {
        fn default() -> OrganizationPackages {
            OrganizationPackages::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationSecrets {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationSecrets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationSecrets::Read => "read",
                OrganizationSecrets::Write => "write",
                OrganizationSecrets::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationSecrets {
        fn default() -> OrganizationSecrets {
            OrganizationSecrets::Noop
        }
    }

    /**
     * The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationSelfHostedRunners {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationSelfHostedRunners {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationSelfHostedRunners::Read => "read",
                OrganizationSelfHostedRunners::Write => "write",
                OrganizationSelfHostedRunners::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationSelfHostedRunners {
        fn default() -> OrganizationSelfHostedRunners {
            OrganizationSelfHostedRunners::Noop
        }
    }

    /**
     * The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationUserBlocking {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationUserBlocking {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationUserBlocking::Read => "read",
                OrganizationUserBlocking::Write => "write",
                OrganizationUserBlocking::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationUserBlocking {
        fn default() -> OrganizationUserBlocking {
            OrganizationUserBlocking::Noop
        }
    }

    /**
     * The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamDiscussions {
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for TeamDiscussions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamDiscussions::Read => "read",
                TeamDiscussions::Write => "write",
                TeamDiscussions::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamDiscussions {
        fn default() -> TeamDiscussions {
            TeamDiscussions::Noop
        }
    }

    /// The permissions granted to the user-to-server access token.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppPermissions {
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actions: Option<Actions>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub administration: Option<Administration>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub checks: Option<Checks>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub content_references: Option<ContentReferences>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub contents: Option<Contents>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployments: Option<Deployments>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub environments: Option<Environments>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issues: Option<Issues>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members: Option<Members>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub metadata: Option<Metadata>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_administration: Option<OrganizationAdministration>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_hooks: Option<OrganizationHooks>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_packages: Option<OrganizationPackages>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_plan: Option<OrganizationPlan>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_projects: Option<OrganizationProjects>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_secrets: Option<OrganizationSecrets>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_self_hosted_runners: Option<OrganizationSelfHostedRunners>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_user_blocking: Option<OrganizationUserBlocking>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub packages: Option<Packages>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pages: Option<Pages>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_requests: Option<PullRequests>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_hooks: Option<RepositoryHooks>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_projects: Option<RepositoryProjects>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub secret_scanning_alerts: Option<SecretScanningAlerts>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub secrets: Option<Secrets>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_events: Option<SecurityEvents>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub single_file: Option<SingleFile>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub statuses: Option<Statuses>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub team_discussions: Option<TeamDiscussions>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vulnerability_alerts: Option<VulnerabilityAlerts>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub workflows: Option<Workflows>,
    }

    /**
     * Describe whether all repositories have been selected or there's a selection involved
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum RepositorySelection {
        All,
        Selected,
        Noop,
    }

    impl std::fmt::Display for RepositorySelection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                RepositorySelection::All => "all",
                RepositorySelection::Selected => "selected",
                RepositorySelection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for RepositorySelection {
        fn default() -> RepositorySelection {
            RepositorySelection::Noop
        }
    }

    /// Installation
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Installation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_tokens_url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub account: User,
        #[serde(default)]
        pub app_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub app_slug: String,
        /**
         * Installation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contact_email: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        /**
         * Installation
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The ID of the installation.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde()]
        pub permissions: AppPermissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        /**
         * Describe whether all repositories have been selected or there's a selection involved
         */
        #[serde()]
        pub repository_selection: RepositorySelection,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file_name: String,
        /**
         * Installation
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
        #[serde()]
        pub suspended_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub suspended_by: User,
        /**
         * The ID of the user or organization this token is being scoped to.
         */
        #[serde(default)]
        pub target_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_type: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    /// License Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct License {
        /**
         * License Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryPermissions {
        #[serde(default)]
        pub admin: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintain: Option<bool>,
        #[serde(default)]
        pub pull: bool,
        #[serde(default)]
        pub push: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub triage: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Users {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryTemplatePermissions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TemplateRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fork: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues_count: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Users>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<RepositoryTemplatePermissions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pushed_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stargazers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers_count: Option<i64>,
    }

    /// A git repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Repository {
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        /**
         * Whether the repository is archived.
         */
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The default branch of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Returns whether or not this repository disabled.
         */
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        /**
         * Whether downloads are enabled.
         */
        #[serde(default)]
        pub has_downloads: bool,
        /**
         * Whether issues are enabled.
         */
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        /**
         * Whether projects are enabled.
         */
        #[serde(default)]
        pub has_projects: bool,
        /**
         * Whether the wiki is enabled.
         */
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the repository
         */
        #[serde(default)]
        pub id: i64,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        /**
         * A git repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        /**
         * The name of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization: Option<User>,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<RepositoryPermissions>,
        /**
         * Whether the repository is private or public.
         */
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        /**
         * A git repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        /**
         * A git repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        /**
         * A git repository
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * A git repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum InstallationTokenRepositorySelection {
        All,
        Selected,
        Noop,
    }

    impl std::fmt::Display for InstallationTokenRepositorySelection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                InstallationTokenRepositorySelection::All => "all",
                InstallationTokenRepositorySelection::Selected => "selected",
                InstallationTokenRepositorySelection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for InstallationTokenRepositorySelection {
        fn default() -> InstallationTokenRepositorySelection {
            InstallationTokenRepositorySelection::Noop
        }
    }

    /// Authentication token for a GitHub App installed on a user or org.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InstallationToken {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expires_at: String,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_selection: Option<InstallationTokenRepositorySelection>,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
        /**
         * Authentication token for a GitHub App installed on a user or org.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Errors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub field: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub index: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    /// Validation Error
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ValidationError {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        /**
         * Validation Error
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct App {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// The authorization associated with an OAuth Access.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ApplicationGrant {
        #[serde()]
        pub app: App,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * The authorization associated with an OAuth Access.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScopedInstallation {
        /**
         * Simple User
         */
        #[serde()]
        pub account: User,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        /**
         * The permissions granted to the user-to-server access token.
         */
        #[serde()]
        pub permissions: AppPermissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        /**
         * Describe whether all repositories have been selected or there's a selection involved
         */
        #[serde()]
        pub repository_selection: RepositorySelection,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
    }

    /// The authorization for an OAuth app, GitHub App, or a Personal Access Token.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Authorization {
        #[serde()]
        pub app: App,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hashed_token: String,
        #[serde(default)]
        pub id: i64,
        /**
         * The authorization for an OAuth app, GitHub App, or a Personal Access Token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installation: Option<ScopedInstallation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        /**
         * A list of scopes that this authorization is in.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token_last_eight: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * The authorization for an OAuth app, GitHub App, or a Personal Access Token.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    /// Code Of Conduct
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeOfConduct {
        /**
         * Code Of Conduct
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnabledOrganizations {
        All,
        None,
        Selected,
        Noop,
    }

    impl std::fmt::Display for EnabledOrganizations {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnabledOrganizations::All => "all",
                EnabledOrganizations::None => "none",
                EnabledOrganizations::Selected => "selected",
                EnabledOrganizations::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for EnabledOrganizations {
        fn default() -> EnabledOrganizations {
            EnabledOrganizations::Noop
        }
    }

    /**
     * The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AllowedActions {
        All,
        LocalOnly,
        Selected,
        Noop,
    }

    impl std::fmt::Display for AllowedActions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AllowedActions::All => "all",
                AllowedActions::LocalOnly => "local_only",
                AllowedActions::Selected => "selected",
                AllowedActions::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AllowedActions {
        fn default() -> AllowedActions {
            AllowedActions::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsEnterprisePermissions {
        /**
         * The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
         */
        #[serde()]
        pub allowed_actions: AllowedActions,
        /**
         * The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
         */
        #[serde()]
        pub enabled_organizations: EnabledOrganizations,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_organizations_url: String,
    }

    /// Organization Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SelectedActions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub github_owned_allowed: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub patterns_allowed: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified_allowed: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerGroupsEnterprise {
        #[serde(default)]
        pub allows_public_repositories: bool,
        #[serde(default)]
        pub default: bool,
        #[serde(default)]
        pub id: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub runners_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    /**
     * The type of label. Read-only labels are applied automatically when the runner is configured.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Type {
        Custom,
        ReadOnly,
        Noop,
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Type::Custom => "custom",
                Type::ReadOnly => "read-only",
                Type::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Type {
        fn default() -> Type {
            Type::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Labels {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
        pub type_: Option<Type>,
    }

    /// A self hosted runner
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Runner {
        #[serde(default)]
        pub busy: bool,
        /**
         * The id of the runner.
         */
        #[serde(default)]
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        /**
         * The name of the runner.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * The Operating System of the runner.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub os: String,
        /**
         * The status of the runner.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    /// Runner Application
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerApplication {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub architecture: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub os: String,
        /**
         * Runner Application
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha_256_checksum: String,
        /**
         * Runner Application
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_download_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Data {}

    /// Authentication Token
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuthenticationToken {
        /**
         * The time this token expires
         */
        #[serde()]
        pub expires_at: DateTime<Utc>,
        /**
         * Authentication Token
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Data>,
        /**
         * Authentication Token
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        /**
         * Authentication Token
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_selection: Option<RepositorySelection>,
        /**
         * Authentication Token
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
        /**
         * The token used for authentication
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActorLocation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub country_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuditLogEvent {
        #[serde(default, skip_serializing_if = "Option::is_none", rename = "@timestamp")]
        pub timestamp: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub document_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_was: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub actor: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor_location: Option<ActorLocation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blocked_user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub business: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config_was: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<Data>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deploy_key_fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emoji: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub events: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub events_were: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub explanation: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hook_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limited_availability: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub old_user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub openssh_public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub org: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub org_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read_only: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repo: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_public: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub team: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transport_protocol: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub transport_protocol_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinutesUsedBreakdown {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub macos: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ubuntu: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub windows: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsBillingUsage {
        /**
         * The amount of free GitHub Actions minutes available.
         */
        #[serde(default)]
        pub included_minutes: i64,
        #[serde()]
        pub minutes_used_breakdown: MinutesUsedBreakdown,
        /**
         * The sum of the free and paid GitHub Actions minutes used.
         */
        #[serde(default)]
        pub total_minutes_used: i64,
        /**
         * The total paid GitHub Actions minutes used.
         */
        #[serde(default)]
        pub total_paid_minutes_used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackagesBillingUsage {
        /**
         * Free storage space (GB) for GitHub Packages.
         */
        #[serde(default)]
        pub included_gigabytes_bandwidth: i64,
        /**
         * Sum of the free and paid storage space (GB) for GitHuub Packages.
         */
        #[serde(default)]
        pub total_gigabytes_bandwidth_used: i64,
        /**
         * Total paid storage space (GB) for GitHuub Packages.
         */
        #[serde(default)]
        pub total_paid_gigabytes_bandwidth_used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CombinedBillingUsage {
        /**
         * Numbers of days left in billing cycle.
         */
        #[serde(default)]
        pub days_left_in_billing_cycle: i64,
        /**
         * Estimated storage space (GB) used in billing cycle.
         */
        #[serde(default)]
        pub estimated_paid_storage_for_month: i64,
        /**
         * Estimated sum of free and paid storage space (GB) used in billing cycle.
         */
        #[serde(default)]
        pub estimated_storage_for_month: i64,
    }

    /// Actor
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Actor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        /**
         * Actor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Label {
        /**
         * 6-character hex code, without the leading #, identifying the color
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default)]
        pub default: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the label.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * URL for the label
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The state of the milestone.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum State {
        Closed,
        Open,
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                State::Closed => "closed",
                State::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for State {
        fn default() -> State {
            State::Open
        }
    }

    /// A collection of related issues and pull requests.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Milestone {
        #[serde()]
        pub closed_at: DateTime<Utc>,
        #[serde(default)]
        pub closed_issues: i64,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde()]
        pub due_on: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The number of the milestone.
         */
        #[serde(default)]
        pub number: i64,
        #[serde(default)]
        pub open_issues: i64,
        /**
         * The state of the milestone.
         */
        #[serde()]
        pub state: State,
        /**
         * The title of the milestone.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * How the author is associated with the repository.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AuthorAssociation {
        Collaborator,
        Contributor,
        FirstTimer,
        FirstTimeContributor,
        Mannequin,
        Member,
        None,
        Owner,
        Noop,
    }

    impl std::fmt::Display for AuthorAssociation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AuthorAssociation::Collaborator => "COLLABORATOR",
                AuthorAssociation::Contributor => "CONTRIBUTOR",
                AuthorAssociation::FirstTimer => "FIRST_TIMER",
                AuthorAssociation::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR",
                AuthorAssociation::Mannequin => "MANNEQUIN",
                AuthorAssociation::Member => "MEMBER",
                AuthorAssociation::None => "NONE",
                AuthorAssociation::Owner => "OWNER",
                AuthorAssociation::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AuthorAssociation {
        fn default() -> AuthorAssociation {
            AuthorAssociation::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub merged_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Issue Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueSimple {
        /**
         * Issue Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Issue Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<User>,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * Issue Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Issue Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Issue Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub closed_at: DateTime<Utc>,
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Label>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(default)]
        pub locked: bool,
        /**
         * A collection of related issues and pull requests.
         */
        #[serde()]
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub number: i64,
        /**
         * Issue Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Issue Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        /**
         * Issue Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        /**
         * Issue Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionRollup {
        #[serde(default, rename = "+1")]
        pub plus_one: i64,
        #[serde(default, rename = "-1")]
        pub minus_one: i64,
        #[serde(default)]
        pub confused: i64,
        #[serde(default)]
        pub eyes: i64,
        #[serde(default)]
        pub heart: i64,
        #[serde(default)]
        pub hooray: i64,
        #[serde(default)]
        pub laugh: i64,
        #[serde(default)]
        pub rocket: i64,
        #[serde(default)]
        pub total_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Comments provide a way for people to collaborate on an issue.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueComment {
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * Comments provide a way for people to collaborate on an issue.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Comments provide a way for people to collaborate on an issue.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Comments provide a way for people to collaborate on an issue.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the issue comment
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Comments provide a way for people to collaborate on an issue.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Comments provide a way for people to collaborate on an issue.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * URL for the issue comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Repo {
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EventPayloadPages {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub page_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Payload {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<IssueComment>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pages: Vec<EventPayloadPages>,
    }

    /// Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Event {
        /**
         * Actor
         */
        #[serde()]
        pub actor: Actor,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        /**
         * Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub org: Option<Actor>,
        #[serde()]
        pub payload: Payload,
        #[serde(default)]
        pub public: bool,
        #[serde()]
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    /// Hypermedia Link with Type
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LinkWithType {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Links {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_actor: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_organization: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub current_user_organizations: Vec<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_public: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_advisories: Option<LinkWithType>,
        /**
         * Hypermedia Link with Type
         */
        #[serde()]
        pub timeline: LinkWithType,
        /**
         * Hypermedia Link with Type
         */
        #[serde()]
        pub user: LinkWithType,
    }

    /// Feed
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Feed {
        #[serde()]
        pub links: Links,
        /**
         * Feed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_actor_url: String,
        /**
         * Feed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_organization_url: String,
        /**
         * Feed
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub current_user_organization_urls: Vec<String>,
        /**
         * Feed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_public_url: String,
        /**
         * Feed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_url: String,
        /**
         * Feed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub security_advisories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_url: String,
    }

    /// Base Gist
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BaseGist {
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde()]
        pub files: Data,
        /**
         * Base Gist
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        /**
         * Base Gist
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Base Gist
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<User>,
        #[serde(default)]
        pub public: bool,
        /**
         * Base Gist
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Plan {
        #[serde(default)]
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub private_repos: i64,
        #[serde(default)]
        pub space: i64,
    }

    /// Public User
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PublicUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub collaborators: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_usage: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(default)]
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(default)]
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owned_private_repos: Option<i64>,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private_gists: Option<i64>,
        #[serde(default)]
        pub public_gists: i64,
        #[serde(default)]
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        /**
         * Public User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_private_repos: Option<i64>,
        /**
         * Public User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Stats {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub additions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deletions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total: Option<i64>,
    }

    /// Gist History
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistHistory {
        /**
         * Gist History
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_status: Option<Stats>,
        /**
         * Gist History
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committed_at: Option<DateTime<Utc>>,
        /**
         * Gist History
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Gist History
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
        /**
         * Gist History
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Forks {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<PublicUser>,
    }

    /// Gist
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ForkOf {
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde()]
        pub files: Data,
        /**
         * Gist
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        /**
         * Gist
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Gist
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<User>,
        #[serde(default)]
        pub public: bool,
        /**
         * Gist
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Gist Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistSimple {
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comments: Option<i64>,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub files: Option<Data>,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fork_of: Option<ForkOf>,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<Forks>,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<GistHistory>,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<User>,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
        /**
         * Gist Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Gist Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user: String,
    }

    /// A comment made to a gist.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistComment {
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The comment text.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Gist Commit
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistCommit {
        #[serde()]
        pub change_status: Stats,
        #[serde()]
        pub committed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    /// Gitignore Template
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitignoreTemplate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub source: String,
    }

    /// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Issue {
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<User>,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub closed_at: DateTime<Utc>,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub closed_by: Option<User>,
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(default)]
        pub locked: bool,
        /**
         * A collection of related issues and pull requests.
         */
        #[serde()]
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Number uniquely identifying the issue within its repository
         */
        #[serde(default)]
        pub number: i64,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        /**
         * State of the issue; either 'open' or 'closed'
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        /**
         * Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        /**
         * Title of the issue
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * URL for the issue
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// License
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub conditions: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub featured: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub implementation: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub limitations: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub permissions: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Marketplace Listing Plan
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplaceListingPlan {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub accounts_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub bullets: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub has_free_trial: bool,
        #[serde(default)]
        pub id: i64,
        #[serde(default)]
        pub monthly_price_in_cents: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub price_model: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub unit_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub yearly_price_in_cents: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePendingChange {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub effective_date: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_installed: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<MarketplaceListingPlan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unit_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePurchase {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_cycle: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub free_trial_ends_on: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_installed: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub next_billing_date: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub on_free_trial: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<MarketplaceListingPlan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unit_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
    }

    /// Marketplace Purchase
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePurchaseData {
        /**
         * Marketplace Purchase
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Marketplace Purchase
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub marketplace_pending_change: Option<MarketplacePendingChange>,
        #[serde()]
        pub marketplace_purchase: MarketplacePurchase,
        /**
         * Marketplace Purchase
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SshKeyFingerprints {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha256_dsa: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha256_rsa: String,
    }

    /// Api Overview
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ApiOverview {
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub api: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub dependabot: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub git: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub hooks: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub importer: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub packages: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pages: Vec<String>,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ssh_key_fingerprints: Option<SshKeyFingerprints>,
        #[serde(default)]
        pub verifiable_password_authentication: bool,
        /**
         * Api Overview
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub web: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryPermissions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub triage: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryLicense {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Minimal Repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepository {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_of_conduct: Option<CodeOfConduct>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks: Option<i64>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_pages: Option<bool>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub license: Option<MinimalRepositoryLicense>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues: Option<i64>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues_count: Option<i64>,
        #[serde()]
        pub owner: Data,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<MinimalRepositoryPermissions>,
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pushed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stargazers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<Data>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Minimal Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers: Option<i64>,
        /**
         * Minimal Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Subject {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub latest_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Thread
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Thread {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub last_read_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        #[serde()]
        pub subject: Subject,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(default)]
        pub unread: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Thread Subscription
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ThreadSubscription {
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub ignored: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        /**
         * Thread Subscription
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(default)]
        pub subscribed: bool,
        /**
         * Thread Subscription
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub thread_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationFullPlan {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub filled_seats: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub private_repos: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub seats: Option<i64>,
        #[serde(default)]
        pub space: i64,
    }

    /// Organization Full
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationFull {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_email: String,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub collaborators: Option<i64>,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_repository_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_usage: Option<i64>,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub followers: i64,
        #[serde(default)]
        pub following: i64,
        #[serde(default)]
        pub has_organization_projects: bool,
        #[serde(default)]
        pub has_repository_projects: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_verified: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_allowed_repository_creation_type: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_internal_repositories: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_pages: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_pages: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_repositories: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_pages: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_repositories: Option<bool>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owned_private_repos: Option<i64>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<OrganizationFullPlan>,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private_gists: Option<i64>,
        #[serde(default)]
        pub public_gists: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        #[serde(default)]
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_private_repos: Option<i64>,
        /**
         * Organization Full
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        /**
         * Organization Full
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_factor_requirement_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnabledRepositories {
        All,
        None,
        Selected,
        Noop,
    }

    impl std::fmt::Display for EnabledRepositories {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnabledRepositories::All => "all",
                EnabledRepositories::None => "none",
                EnabledRepositories::Selected => "selected",
                EnabledRepositories::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for EnabledRepositories {
        fn default() -> EnabledRepositories {
            EnabledRepositories::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsOrganizationPermissions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed_actions: Option<AllowedActions>,
        /**
         * The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
         */
        #[serde()]
        pub enabled_repositories: EnabledRepositories,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerGroupsOrg {
        #[serde(default)]
        pub allows_public_repositories: bool,
        #[serde(default)]
        pub default: bool,
        #[serde(default)]
        pub id: f64,
        #[serde(default)]
        pub inherited: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inherited_allows_public_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub runners_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    /**
     * Visibility of a secret
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Visibility {
        All,
        Private,
        Selected,
        Noop,
    }

    impl std::fmt::Display for Visibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Visibility::All => "all",
                Visibility::Private => "private",
                Visibility::Selected => "selected",
                Visibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Visibility {
        fn default() -> Visibility {
            Visibility::Noop
        }
    }

    /// Secrets for GitHub Actions for an organization.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationActionsSecret {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The name of the secret.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Secrets for GitHub Actions for an organization.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * Visibility of a secret
         */
        #[serde()]
        pub visibility: Visibility,
    }

    /// The public key used for setting Actions Secrets.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsPublicKey {
        /**
         * The public key used for setting Actions Secrets.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        /**
         * The public key used for setting Actions Secrets.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        /**
         * The Base64 encoded public key.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        /**
         * The identifier for the key.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        /**
         * The public key used for setting Actions Secrets.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        /**
         * The public key used for setting Actions Secrets.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// An object without any properties.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EmptyObject {}

    /// Credential Authorization
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CredentialAuthorization {
        /**
         * Credential Authorization
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub authorized_credential_id: Option<i64>,
        /**
         * Credential Authorization
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorized_credential_note: String,
        /**
         * Credential Authorization
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorized_credential_title: String,
        /**
         * Credential Authorization
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub credential_accessed_at: Option<DateTime<Utc>>,
        /**
         * Date when the credential was authorized for use.
         */
        #[serde()]
        pub credential_authorized_at: DateTime<Utc>,
        /**
         * Unique identifier for the credential.
         */
        #[serde(default)]
        pub credential_id: i64,
        /**
         * Human-readable description of the credential type.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub credential_type: String,
        /**
         * Credential Authorization
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        /**
         * User login that owns the underlying credential.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Credential Authorization
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        /**
         * Credential Authorization
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token_last_eight: String,
    }

    /// Organization Invitation
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationInvitation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * Organization Invitation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_at: String,
        /**
         * Organization Invitation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_reason: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub invitation_teams_url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub inviter: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
        #[serde(default)]
        pub team_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgHookConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Org Hook
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgHook {
        #[serde(default)]
        pub active: bool,
        #[serde()]
        pub config: OrgHookConfig,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ping_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum InteractionGroup {
        CollaboratorsOnly,
        ContributorsOnly,
        ExistingUsers,
        Noop,
    }

    impl std::fmt::Display for InteractionGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                InteractionGroup::CollaboratorsOnly => "collaborators_only",
                InteractionGroup::ContributorsOnly => "contributors_only",
                InteractionGroup::ExistingUsers => "existing_users",
                InteractionGroup::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for InteractionGroup {
        fn default() -> InteractionGroup {
            InteractionGroup::Noop
        }
    }

    /// Interaction limit settings.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InteractionLimitResponse {
        #[serde()]
        pub expires_at: DateTime<Utc>,
        /**
         * The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
         */
        #[serde()]
        pub limit: InteractionGroup,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub origin: String,
    }

    /**
     * The duration of the interaction restriction. Can be one of: `one_day`, `three_days`, `one_week`, `one_month`, `six_months`. Default: `one_day`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum InteractionExpiry {
        OneDay,
        OneMonth,
        OneWeek,
        SixMonths,
        ThreeDays,
        Noop,
    }

    impl std::fmt::Display for InteractionExpiry {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                InteractionExpiry::OneDay => "one_day",
                InteractionExpiry::OneMonth => "one_month",
                InteractionExpiry::OneWeek => "one_week",
                InteractionExpiry::SixMonths => "six_months",
                InteractionExpiry::ThreeDays => "three_days",
                InteractionExpiry::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for InteractionExpiry {
        fn default() -> InteractionExpiry {
            InteractionExpiry::Noop
        }
    }

    /// Limit interactions to a specific type of user for a specified duration
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InteractionLimit {
        /**
         * Limit interactions to a specific type of user for a specified duration
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expiry: Option<InteractionExpiry>,
        /**
         * The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
         */
        #[serde()]
        pub limit: InteractionGroup,
    }

    /// Groups of organization members that gives permissions on specified repositories.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Parent {
        /**
         * Description of the team
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the team
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        /**
         * Name of the team
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Permission that the team will have for its repositories
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        /**
         * URL for the team
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamPermissions {
        #[serde(default)]
        pub admin: bool,
        #[serde(default)]
        pub maintain: bool,
        #[serde(default)]
        pub pull: bool,
        #[serde(default)]
        pub push: bool,
        #[serde(default)]
        pub triage: bool,
    }

    /// Groups of organization members that gives permissions on specified repositories.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Team {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde()]
        pub parent: Parent,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<TeamPermissions>,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgMembershipState {
        Active,
        Pending,
        Noop,
    }

    impl std::fmt::Display for OrgMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgMembershipState::Active => "active",
                OrgMembershipState::Pending => "pending",
                OrgMembershipState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrgMembershipState {
        fn default() -> OrgMembershipState {
            OrgMembershipState::Noop
        }
    }

    /**
     * The user's membership type in the organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Role {
        Admin,
        BillingManager,
        Member,
        Noop,
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Role::Admin => "admin",
                Role::BillingManager => "billing_manager",
                Role::Member => "member",
                Role::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Role {
        fn default() -> Role {
            Role::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgMembershipPermissions {
        #[serde(default)]
        pub can_create_repository: bool,
    }

    /// Org Membership
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgMembership {
        /**
         * Organization Simple
         */
        #[serde()]
        pub organization: OrganizationSimple,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_url: String,
        /**
         * Org Membership
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<OrgMembershipPermissions>,
        /**
         * The user's membership type in the organization.
         */
        #[serde()]
        pub role: Role,
        /**
         * The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
         */
        #[serde()]
        pub state: OrgMembershipState,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// A migration.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Migration {
        /**
         * A migration.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * A migration.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<serde_json::Value>,
        #[serde(default)]
        pub exclude_attachments: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub guid: String,
        #[serde(default)]
        pub id: i64,
        #[serde(default)]
        pub lock_repositories: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PackageType {
        Container,
        Docker,
        Maven,
        Npm,
        Nuget,
        Rubygems,
        Noop,
    }

    impl std::fmt::Display for PackageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PackageType::Container => "container",
                PackageType::Docker => "docker",
                PackageType::Maven => "maven",
                PackageType::Npm => "npm",
                PackageType::Nuget => "nuget",
                PackageType::Rubygems => "rubygems",
                PackageType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PackageType {
        fn default() -> PackageType {
            PackageType::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PackageVisibility {
        Private,
        Public,
        Noop,
    }

    impl std::fmt::Display for PackageVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PackageVisibility::Private => "private",
                PackageVisibility::Public => "public",
                PackageVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PackageVisibility {
        fn default() -> PackageVisibility {
            PackageVisibility::Noop
        }
    }

    /// A software package
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Package {
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the package.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the package.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * A software package
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<User>,
        #[serde()]
        pub package_type: PackageType,
        /**
         * A software package
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<MinimalRepository>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * The number of versions of the package.
         */
        #[serde(default)]
        pub version_count: i64,
        #[serde()]
        pub visibility: PackageVisibility,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Container {
        #[serde()]
        pub tags: serde_json::Value,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Docker {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tag: Option<serde_json::Value>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackageVersionMetadata {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub container: Option<Container>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub docker: Option<Docker>,
        #[serde()]
        pub package_type: PackageType,
    }

    /// A version of a software package
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackageVersion {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * A version of a software package
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deleted_at: Option<DateTime<Utc>>,
        /**
         * A version of a software package
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * A version of a software package
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the package version.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * A version of a software package
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license: String,
        /**
         * A version of a software package
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub metadata: Option<PackageVersionMetadata>,
        /**
         * The name of the package version.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub package_html_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The baseline permission that all organization members have on this project. Only present if owner is an organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrganizationPermission {
        Admin,
        None,
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for OrganizationPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrganizationPermission::Admin => "admin",
                OrganizationPermission::None => "none",
                OrganizationPermission::Read => "read",
                OrganizationPermission::Write => "write",
                OrganizationPermission::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrganizationPermission {
        fn default() -> OrganizationPermission {
            OrganizationPermission::Noop
        }
    }

    /// Projects are a way to organize columns and cards of work.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Project {
        /**
         * Body of the project
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub columns_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Name of the project
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub number: i64,
        /**
         * Projects are a way to organize columns and cards of work.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_permission: Option<OrganizationPermission>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner_url: String,
        /**
         * Projects are a way to organize columns and cards of work.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        /**
         * State of the project; either 'open' or 'closed'
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Groups {
        /**
         * a description of the group
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_description: String,
        /**
         * The ID of the group
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_id: String,
        /**
         * The name of the group
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub synced_at: String,
    }

    /// External Groups to be mapped to a team for membership
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GroupMapping {
        /**
         * External Groups to be mapped to a team for membership
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
    }

    /**
     * The level of privacy this team should have
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Privacy {
        Closed,
        Secret,
        Noop,
    }

    impl std::fmt::Display for Privacy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Privacy::Closed => "closed",
                Privacy::Secret => "secret",
                Privacy::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Privacy {
        fn default() -> Privacy {
            Privacy::Noop
        }
    }

    /// Groups of organization members that gives permissions on specified repositories.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamFull {
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the team
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(default)]
        pub members_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        /**
         * Name of the team
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Organization Full
         */
        #[serde()]
        pub organization: OrganizationFull,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent: Option<Parent>,
        /**
         * Permission that the team will have for its repositories
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        /**
         * Groups of organization members that gives permissions on specified repositories.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub privacy: Option<Privacy>,
        #[serde(default)]
        pub repos_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * URL for the team
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// A team discussion is a persistent record of a free-form conversation within a team.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamDiscussion {
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        /**
         * The main text of the discussion.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_version: String,
        #[serde(default)]
        pub comments_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde()]
        pub last_edited_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The unique sequence number of a team discussion.
         */
        #[serde(default)]
        pub number: i64,
        /**
         * Whether or not this discussion should be pinned for easy retrieval.
         */
        #[serde(default)]
        pub pinned: bool,
        /**
         * Whether or not this discussion should be restricted to team members and organization administrators.
         */
        #[serde(default)]
        pub private: bool,
        /**
         * A team discussion is a persistent record of a free-form conversation within a team.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub team_url: String,
        /**
         * The title of the discussion.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// A reply to a discussion within a team.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamDiscussionComment {
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        /**
         * The main text of the comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_version: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde()]
        pub last_edited_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The unique sequence number of a team discussion comment.
         */
        #[serde(default)]
        pub number: i64,
        /**
         * A reply to a discussion within a team.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The reaction to use
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Content {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for Content {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Content::PlusOne => "+1",
                Content::MinusOne => "-1",
                Content::Confused => "confused",
                Content::Eyes => "eyes",
                Content::Heart => "heart",
                Content::Hooray => "hooray",
                Content::Laugh => "laugh",
                Content::Rocket => "rocket",
                Content::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Content {
        fn default() -> Content {
            Content::Noop
        }
    }

    /// Reactions to conversations provide a way to help people express their feelings more simply and effectively.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Reaction {
        /**
         * The reaction to use
         */
        #[serde()]
        pub content: Content,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /**
     * The role of the user in the team.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamMembershipRole {
        Maintainer,
        Member,
    }

    impl std::fmt::Display for TeamMembershipRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamMembershipRole::Maintainer => "maintainer",
                TeamMembershipRole::Member => "member",
            }
            .fmt(f)
        }
    }

    impl Default for TeamMembershipRole {
        fn default() -> TeamMembershipRole {
            TeamMembershipRole::Member
        }
    }

    /**
     * The state of the user's membership in the team.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamMembershipState {
        Active,
        Pending,
        Noop,
    }

    impl std::fmt::Display for TeamMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamMembershipState::Active => "active",
                TeamMembershipState::Pending => "pending",
                TeamMembershipState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamMembershipState {
        fn default() -> TeamMembershipState {
            TeamMembershipState::Noop
        }
    }

    /// Team Membership
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamMembership {
        /**
         * The role of the user in the team.
         */
        #[serde()]
        pub role: TeamMembershipRole,
        /**
         * The state of the user's membership in the team.
         */
        #[serde()]
        pub state: TeamMembershipState,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamProjectPermissions {
        #[serde(default)]
        pub admin: bool,
        #[serde(default)]
        pub read: bool,
        #[serde(default)]
        pub write: bool,
    }

    /// A team's access to a project.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamProject {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub columns_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub number: i64,
        /**
         * A team's access to a project.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner_url: String,
        #[serde()]
        pub permissions: TeamProjectPermissions,
        /**
         * A team's access to a project.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// A team's access to a repository.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamRepository {
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        /**
         * Whether the repository is archived.
         */
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The default branch of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Returns whether or not this repository disabled.
         */
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        /**
         * Whether downloads are enabled.
         */
        #[serde(default)]
        pub has_downloads: bool,
        /**
         * Whether issues are enabled.
         */
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        /**
         * Whether projects are enabled.
         */
        #[serde(default)]
        pub has_projects: bool,
        /**
         * Whether the wiki is enabled.
         */
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the repository
         */
        #[serde(default)]
        pub id: i64,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        /**
         * A team's access to a repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        /**
         * The name of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<RepositoryPermissions>,
        /**
         * Whether the repository is private or public.
         */
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        /**
         * A team's access to a repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<Data>,
        /**
         * A team's access to a repository.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * A team's access to a repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    /// Project cards represent a scope of work.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectCard {
        /**
         * Project cards represent a scope of work.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        /**
         * Project cards represent a scope of work.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_url: String,
        /**
         * Project cards represent a scope of work.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        /**
         * The project card's ID
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        /**
         * Project cards represent a scope of work.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Project columns contain cards of work.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectColumn {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cards_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The unique identifier of the project column
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Name of the project column
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Repository Collaborator Permission
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryCollaboratorPermission {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RateLimit {
        #[serde(default)]
        pub limit: i64,
        #[serde(default)]
        pub remaining: i64,
        #[serde(default)]
        pub reset: i64,
        #[serde(default)]
        pub used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Resources {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_scanning_upload: Option<RateLimit>,
        #[serde()]
        pub core: RateLimit,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub graphql: Option<RateLimit>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub integration_manifest: Option<RateLimit>,
        #[serde()]
        pub search: RateLimit,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source_import: Option<RateLimit>,
    }

    /// Rate Limit Overview
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RateLimitOverview {
        #[serde()]
        pub rate: RateLimit,
        #[serde()]
        pub resources: Resources,
    }

    /// Code of Conduct Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeOfConductSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FullRepositoryPermissions {
        #[serde(default)]
        pub admin: bool,
        #[serde(default)]
        pub pull: bool,
        #[serde(default)]
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum FullRepositorySecurityAnalysisAdvancedStatus {
        Disabled,
        Enabled,
        Noop,
    }

    impl std::fmt::Display for FullRepositorySecurityAnalysisAdvancedStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                FullRepositorySecurityAnalysisAdvancedStatus::Disabled => "disabled",
                FullRepositorySecurityAnalysisAdvancedStatus::Enabled => "enabled",
                FullRepositorySecurityAnalysisAdvancedStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for FullRepositorySecurityAnalysisAdvancedStatus {
        fn default() -> FullRepositorySecurityAnalysisAdvancedStatus {
            FullRepositorySecurityAnalysisAdvancedStatus::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecretScanning {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<FullRepositorySecurityAnalysisAdvancedStatus>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecurityAnalysis {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub advanced_security: Option<SecretScanning>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub secret_scanning: Option<SecretScanning>,
    }

    /// Full Repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FullRepository {
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub anonymous_access_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_of_conduct: Option<CodeOfConductSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Returns whether or not this repository disabled.
         */
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default)]
        pub has_downloads: bool,
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        #[serde(default)]
        pub has_projects: bool,
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        /**
         * Full Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub network_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization: Option<User>,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent: Option<Repository>,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<FullRepositoryPermissions>,
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_and_analysis: Option<SecurityAnalysis>,
        #[serde(default)]
        pub size: i64,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default)]
        pub subscribers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        /**
         * Full Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<Data>,
        /**
         * Full Repository
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Full Repository
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    /// An artifact
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Artifact {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_download_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Whether or not the artifact has expired.
         */
        #[serde(default)]
        pub expired: bool,
        #[serde()]
        pub expires_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the artifact.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The size in bytes of the artifact.
         */
        #[serde(default)]
        pub size_in_bytes: i64,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The phase of the lifecycle that the job is currently in.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum JobStatus {
        Completed,
        InProgress,
        Queued,
        Noop,
    }

    impl std::fmt::Display for JobStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                JobStatus::Completed => "completed",
                JobStatus::InProgress => "in_progress",
                JobStatus::Queued => "queued",
                JobStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for JobStatus {
        fn default() -> JobStatus {
            JobStatus::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Steps {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        /**
         * The outcome of the job.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        /**
         * The name of the job.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        /**
         * The phase of the lifecycle that the job is currently in.
         */
        #[serde()]
        pub status: JobStatus,
    }

    /// Information of a job execution in a workflow run
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Job {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_run_url: String,
        /**
         * The time that the job finished, in ISO 8601 format.
         */
        #[serde()]
        pub completed_at: DateTime<Utc>,
        /**
         * The outcome of the job.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        /**
         * The SHA of the commit that is being run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The id of the job.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the job.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The id of the associated workflow run.
         */
        #[serde(default)]
        pub run_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub run_url: String,
        /**
         * The time that the job started, in ISO 8601 format.
         */
        #[serde()]
        pub started_at: DateTime<Utc>,
        /**
         * The phase of the lifecycle that the job is currently in.
         */
        #[serde()]
        pub status: JobStatus,
        /**
         * Information of a job execution in a workflow run
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub steps: Vec<Steps>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsRepositoryPermissions {
        /**
         * The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
         */
        #[serde()]
        pub allowed_actions: AllowedActions,
        /**
         * Whether GitHub Actions is enabled on the repository.
         */
        #[serde(default)]
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Head {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde()]
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestMinimal {
        #[serde()]
        pub base: Head,
        #[serde()]
        pub head: Head,
        #[serde(default)]
        pub id: i64,
        #[serde(default)]
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Author {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// Simple Commit
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HeadCommit {
        #[serde()]
        pub author: Author,
        #[serde()]
        pub committer: Author,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde()]
        pub timestamp: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tree_id: String,
    }

    /// An invocation of a workflow
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowRun {
        /**
         * The URL to the artifacts for the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub artifacts_url: String,
        /**
         * The URL to cancel the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cancel_url: String,
        /**
         * An invocation of a workflow
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub check_suite_id: Option<i64>,
        /**
         * An invocation of a workflow
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_suite_node_id: String,
        /**
         * The URL to the associated check suite.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_suite_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_branch: String,
        /**
         * Simple Commit
         */
        #[serde()]
        pub head_commit: HeadCommit,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub head_repository: MinimalRepository,
        /**
         * An invocation of a workflow
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub head_repository_id: Option<i64>,
        /**
         * The SHA of the head commit that points to the version of the worflow being run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The ID of the workflow run.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The URL to the jobs for the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub jobs_url: String,
        /**
         * The URL to download the logs for the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub logs_url: String,
        /**
         * An invocation of a workflow
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pull_requests: Vec<PullRequestMinimal>,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        /**
         * The URL to rerun the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub rerun_url: String,
        /**
         * The auto incrementing run number for the workflow run.
         */
        #[serde(default)]
        pub run_number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * The URL to the workflow run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * The ID of the parent workflow.
         */
        #[serde(default)]
        pub workflow_id: i64,
        /**
         * The URL to the workflow.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub workflow_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnvironmentApprovalsEnvironments {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * Whether deployment to the environment(s) was approved or rejected
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnvironmentApprovalsState {
        Approved,
        Rejected,
        Noop,
    }

    impl std::fmt::Display for EnvironmentApprovalsState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnvironmentApprovalsState::Approved => "approved",
                EnvironmentApprovalsState::Rejected => "rejected",
                EnvironmentApprovalsState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for EnvironmentApprovalsState {
        fn default() -> EnvironmentApprovalsState {
            EnvironmentApprovalsState::Noop
        }
    }

    /// An entry in the reviews log for environment deployments
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnvironmentApprovals {
        /**
         * The comment submitted with the deployment review
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comment: String,
        /**
         * The list of environments that were approved or rejected
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environments: Vec<EnvironmentApprovalsEnvironments>,
        /**
         * Whether deployment to the environment(s) was approved or rejected
         */
        #[serde()]
        pub state: EnvironmentApprovalsState,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /**
     * The type of reviewer. Must be one of: `User` or `Team`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum DeploymentReviewerType {
        Team,
        User,
        Noop,
    }

    impl std::fmt::Display for DeploymentReviewerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                DeploymentReviewerType::Team => "Team",
                DeploymentReviewerType::User => "User",
                DeploymentReviewerType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for DeploymentReviewerType {
        fn default() -> DeploymentReviewerType {
            DeploymentReviewerType::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Environment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Reviewers {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reviewer: Option<User>,
        #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
        pub type_: Option<DeploymentReviewerType>,
    }

    /// Details of a deployment that is waiting for protection rules to pass
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PendingDeployment {
        /**
         * Whether the currently authenticated user can approve the deployment
         */
        #[serde(default)]
        pub current_user_can_approve: bool,
        #[serde()]
        pub environment: Environment,
        /**
         * The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<Reviewers>,
        /**
         * The set duration of the wait timer
         */
        #[serde(default)]
        pub wait_timer: i64,
        /**
         * The time that the wait timer began.
         */
        #[serde()]
        pub wait_timer_started_at: DateTime<Utc>,
    }

    /// A request for a specific ref(branch,sha,tag) to be deployed
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Deployment {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Name for the target deployment environment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        /**
         * Unique identifier of the deployment
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * A request for a specific ref(branch,sha,tag) to be deployed
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_environment: String,
        #[serde()]
        pub payload: Data,
        /**
         * A request for a specific ref(branch,sha,tag) to be deployed
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * A request for a specific ref(branch,sha,tag) to be deployed
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        /**
         * The ref to deploy. This can be a branch, tag, or sha.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * Parameter to specify a task to execute
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        /**
         * A request for a specific ref(branch,sha,tag) to be deployed
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Macos {
        #[serde(default)]
        pub jobs: i64,
        #[serde(default)]
        pub total_ms: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Billable {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub macos: Option<Macos>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ubuntu: Option<Macos>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub windows: Option<Macos>,
    }

    /// Workflow Run Usage
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowRunUsage {
        #[serde()]
        pub billable: Billable,
        /**
         * Workflow Run Usage
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub run_duration_ms: Option<i64>,
    }

    /// Set secrets for GitHub Actions.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSecret {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The name of the secret.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum WorkflowState {
        Active,
        Deleted,
        DisabledFork,
        DisabledInactivity,
        DisabledManually,
        Noop,
    }

    impl std::fmt::Display for WorkflowState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                WorkflowState::Active => "active",
                WorkflowState::Deleted => "deleted",
                WorkflowState::DisabledFork => "disabled_fork",
                WorkflowState::DisabledInactivity => "disabled_inactivity",
                WorkflowState::DisabledManually => "disabled_manually",
                WorkflowState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for WorkflowState {
        fn default() -> WorkflowState {
            WorkflowState::Noop
        }
    }

    /// A GitHub Actions workflow
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Workflow {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub badge_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * A GitHub Actions workflow
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deleted_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde()]
        pub state: WorkflowState,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Windows {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_ms: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsageBillable {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub macos: Option<Windows>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ubuntu: Option<Windows>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub windows: Option<Windows>,
    }

    /// Workflow Usage
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsage {
        #[serde()]
        pub billable: WorkflowUsageBillable,
    }

    /// Protected Branch Admin Enforced
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchAdminEnforced {
        #[serde(default)]
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DismissalRestrictions {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<User>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    /// Protected Branch Pull Request Review
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchPullRequestReview {
        #[serde(default)]
        pub dismiss_stale_reviews: bool,
        /**
         * Protected Branch Pull Request Review
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<DismissalRestrictions>,
        #[serde(default)]
        pub require_code_owner_reviews: bool,
        /**
         * Protected Branch Pull Request Review
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
        /**
         * Protected Branch Pull Request Review
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Teams {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub parent: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicyAppsOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicyAppsPermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub metadata: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Apps {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<BranchRestrictionPolicyAppsOwner>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<BranchRestrictionPolicyAppsPermissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
    }

    /// Branch Restriction Policy
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicy {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<Apps>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub apps_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Teams>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<Users>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredStatusChecks {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contexts_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enforcement_level: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strict: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AllowDeletions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnforceAdmins {
        #[serde(default)]
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Branch Protection
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchProtection {
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<AllowDeletions>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<AllowDeletions>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforce_admins: Option<ProtectedBranchAdminEnforced>,
        /**
         * Branch Protection
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Branch Protection
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<AllowDeletions>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<AllowDeletions>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_pull_request_reviews: Option<ProtectedBranchPullRequestReview>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_signatures: Option<EnforceAdmins>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_status_checks: Option<RequiredStatusChecks>,
        /**
         * Branch Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub restrictions: Option<BranchRestrictionPolicy>,
        /**
         * Branch Protection
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Short Branch
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ShortBranch {
        #[serde()]
        pub commit: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub protected: bool,
        /**
         * Short Branch
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protection: Option<BranchProtection>,
        /**
         * Short Branch
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
    }

    /// Metaproperties for Git author/committer information.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitUser {
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Verification {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub payload: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        #[serde(default)]
        pub verified: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitData {
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde()]
        pub author: GitUser,
        #[serde(default)]
        pub comment_count: i64,
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde()]
        pub committer: GitUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde()]
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Parents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Files {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub additions: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub changes: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deletions: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    /// Commit
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitDataType {
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub commit: CommitData,
        /**
         * Simple User
         */
        #[serde()]
        pub committer: User,
        /**
         * Commit
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub files: Vec<Files>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Commit
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stats: Option<Stats>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchWithProtectionLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    /// Branch With Protection
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchWithProtection {
        #[serde()]
        pub links: BranchWithProtectionLinks,
        #[serde()]
        pub commit: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Branch With Protection
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pattern: String,
        #[serde(default)]
        pub protected: bool,
        /**
         * Branch Protection
         */
        #[serde()]
        pub protection: BranchProtection,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
        /**
         * Branch With Protection
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    /// Status Check Policy
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StatusCheckPolicy {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contexts_url: String,
        #[serde(default)]
        pub strict: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<User>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredPullRequestReviews {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchRequiredLinearHistory {
        #[serde(default)]
        pub enabled: bool,
    }

    /// Branch protections protect branches
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranch {
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<ProtectedBranchRequiredLinearHistory>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<ProtectedBranchRequiredLinearHistory>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforce_admins: Option<EnforceAdmins>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<AllowDeletions>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<ProtectedBranchRequiredLinearHistory>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_pull_request_reviews: Option<RequiredPullRequestReviews>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_signatures: Option<EnforceAdmins>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_status_checks: Option<StatusCheckPolicy>,
        /**
         * Branch protections protect branches
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub restrictions: Option<BranchRestrictionPolicy>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// A deployment created as the result of an Actions check run from a workflow that references an environment
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentSimple {
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Name for the target deployment environment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        /**
         * Unique identifier of the deployment
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * A deployment created as the result of an Actions check run from a workflow that references an environment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_environment: String,
        /**
         * A deployment created as the result of an Actions check run from a workflow that references an environment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * A deployment created as the result of an Actions check run from a workflow that references an environment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * Parameter to specify a task to execute
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        /**
         * A deployment created as the result of an Actions check run from a workflow that references an environment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The phase of the lifecycle that the check is currently in.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CheckRunStatus {
        Completed,
        InProgress,
        Queued,
        Noop,
    }

    impl std::fmt::Display for CheckRunStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CheckRunStatus::Completed => "completed",
                CheckRunStatus::InProgress => "in_progress",
                CheckRunStatus::Queued => "queued",
                CheckRunStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CheckRunStatus {
        fn default() -> CheckRunStatus {
            CheckRunStatus::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Conclusion {
        ActionRequired,
        Cancelled,
        Failure,
        Neutral,
        Skipped,
        Success,
        TimedOut,
        Noop,
    }

    impl std::fmt::Display for Conclusion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Conclusion::ActionRequired => "action_required",
                Conclusion::Cancelled => "cancelled",
                Conclusion::Failure => "failure",
                Conclusion::Neutral => "neutral",
                Conclusion::Skipped => "skipped",
                Conclusion::Success => "success",
                Conclusion::TimedOut => "timed_out",
                Conclusion::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Conclusion {
        fn default() -> Conclusion {
            Conclusion::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Output {
        #[serde(default)]
        pub annotations_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub annotations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuite {
        #[serde(default)]
        pub id: i64,
    }

    /// A check performed on the code of a given code change
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckRun {
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub app: Integration,
        #[serde()]
        pub check_suite: CheckSuite,
        #[serde()]
        pub completed_at: DateTime<Utc>,
        #[serde()]
        pub conclusion: Conclusion,
        /**
         * A check performed on the code of a given code change
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment: Option<DeploymentSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        /**
         * The SHA of the commit that is being checked.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The id of the check.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the check.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde()]
        pub output: Output,
        #[serde()]
        pub pull_requests: serde_json::Value,
        #[serde()]
        pub started_at: DateTime<Utc>,
        /**
         * The phase of the lifecycle that the check is currently in.
         */
        #[serde()]
        pub status: CheckRunStatus,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Check Annotation
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckAnnotation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub annotation_level: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_href: String,
        #[serde(default)]
        pub end_column: i64,
        #[serde(default)]
        pub end_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_details: String,
        #[serde(default)]
        pub start_column: i64,
        #[serde(default)]
        pub start_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CheckSuiteStatus {
        Completed,
        InProgress,
        Queued,
        Noop,
    }

    impl std::fmt::Display for CheckSuiteStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CheckSuiteStatus::Completed => "completed",
                CheckSuiteStatus::InProgress => "in_progress",
                CheckSuiteStatus::Queued => "queued",
                CheckSuiteStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CheckSuiteStatus {
        fn default() -> CheckSuiteStatus {
            CheckSuiteStatus::Noop
        }
    }

    /// A suite of checks performed on the code of a given code change
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuiteData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub after: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub before: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_runs_url: String,
        #[serde()]
        pub conclusion: Conclusion,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_branch: String,
        /**
         * Simple Commit
         */
        #[serde()]
        pub head_commit: HeadCommit,
        /**
         * The SHA of the head commit that is being checked.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(default)]
        pub id: i64,
        #[serde(default)]
        pub latest_check_runs_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pull_requests: Vec<PullRequestMinimal>,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        #[serde()]
        pub status: CheckSuiteStatus,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AutoTriggerChecks {
        #[serde(default)]
        pub app_id: i64,
        #[serde(default)]
        pub setting: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Preferences {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub auto_trigger_checks: Vec<AutoTriggerChecks>,
    }

    /// Check suite configuration preferences for a repository.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuitePreference {
        #[serde()]
        pub preferences: Preferences,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
    }

    /**
     * State of a code scanning alert.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CodeScanningAlertState {
        Closed,
        Dismissed,
        Fixed,
        Open,
        Noop,
    }

    impl std::fmt::Display for CodeScanningAlertState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CodeScanningAlertState::Closed => "closed",
                CodeScanningAlertState::Dismissed => "dismissed",
                CodeScanningAlertState::Fixed => "fixed",
                CodeScanningAlertState::Open => "open",
                CodeScanningAlertState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CodeScanningAlertState {
        fn default() -> CodeScanningAlertState {
            CodeScanningAlertState::Noop
        }
    }

    /**
     * The severity of the alert.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Severity {
        Error,
        None,
        Note,
        Warning,
        Noop,
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Severity::Error => "error",
                Severity::None => "none",
                Severity::Note => "note",
                Severity::Warning => "warning",
                Severity::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Severity {
        fn default() -> Severity {
            Severity::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertRuleSummary {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub severity: Option<Severity>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysisTool {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub guid: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    /// Describe a region within a file for the alert.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertLocation {
        /**
         * Describe a region within a file for the alert.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_column: Option<i64>,
        /**
         * Describe a region within a file for the alert.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_line: Option<i64>,
        /**
         * Describe a region within a file for the alert.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        /**
         * Describe a region within a file for the alert.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_column: Option<i64>,
        /**
         * Describe a region within a file for the alert.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
    }

    /**
     * A classification of the file. For example to identify it as generated.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CodeScanningAlertClassification {
        Generated,
        Library,
        Source,
        Test,
        Noop,
    }

    impl std::fmt::Display for CodeScanningAlertClassification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CodeScanningAlertClassification::Generated => "generated",
                CodeScanningAlertClassification::Library => "library",
                CodeScanningAlertClassification::Source => "source",
                CodeScanningAlertClassification::Test => "test",
                CodeScanningAlertClassification::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CodeScanningAlertClassification {
        fn default() -> CodeScanningAlertClassification {
            CodeScanningAlertClassification::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Message {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertInstance {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analysis_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub classifications: Vec<CodeScanningAlertClassification>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub location: Option<CodeScanningAlertLocation>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<Message>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<CodeScanningAlertState>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertItems {
        /**
         * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
         */
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
         */
        #[serde()]
        pub dismissed_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub dismissed_by: User,
        /**
         * **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
         */
        #[serde()]
        pub dismissed_reason: serde_json::Value,
        /**
         * The GitHub URL of the alert resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The REST API URL for fetching the list of instances for an alert.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub instances_url: String,
        #[serde()]
        pub most_recent_instance: CodeScanningAlertInstance,
        /**
         * The security alert number.
         */
        #[serde(default)]
        pub number: i64,
        #[serde()]
        pub rule: CodeScanningAlertRuleSummary,
        /**
         * State of a code scanning alert.
         */
        #[serde()]
        pub state: CodeScanningAlertState,
        #[serde()]
        pub tool: CodeScanningAnalysisTool,
        /**
         * The REST API URL of the alert resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The security severity of the alert.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SecuritySeverityLevel {
        Critical,
        High,
        Low,
        Medium,
        Noop,
    }

    impl std::fmt::Display for SecuritySeverityLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SecuritySeverityLevel::Critical => "critical",
                SecuritySeverityLevel::High => "high",
                SecuritySeverityLevel::Low => "low",
                SecuritySeverityLevel::Medium => "medium",
                SecuritySeverityLevel::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SecuritySeverityLevel {
        fn default() -> SecuritySeverityLevel {
            SecuritySeverityLevel::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertRule {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub help: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_severity_level: Option<SecuritySeverityLevel>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub severity: Option<Severity>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tags: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlert {
        /**
         * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
         */
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
         */
        #[serde()]
        pub dismissed_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub dismissed_by: User,
        /**
         * **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
         */
        #[serde()]
        pub dismissed_reason: serde_json::Value,
        /**
         * The GitHub URL of the alert resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub instances: Option<serde_json::Value>,
        /**
         * The REST API URL for fetching the list of instances for an alert.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub instances_url: String,
        #[serde()]
        pub most_recent_instance: CodeScanningAlertInstance,
        /**
         * The security alert number.
         */
        #[serde(default)]
        pub number: i64,
        #[serde()]
        pub rule: CodeScanningAlertRule,
        /**
         * State of a code scanning alert.
         */
        #[serde()]
        pub state: CodeScanningAlertState,
        #[serde()]
        pub tool: CodeScanningAnalysisTool,
        /**
         * The REST API URL of the alert resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CodeScanningAlertSetState {
        Dismissed,
        Open,
        Noop,
    }

    impl std::fmt::Display for CodeScanningAlertSetState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CodeScanningAlertSetState::Dismissed => "dismissed",
                CodeScanningAlertSetState::Open => "open",
                CodeScanningAlertSetState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CodeScanningAlertSetState {
        fn default() -> CodeScanningAlertSetState {
            CodeScanningAlertSetState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysis {
        /**
         * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analysis_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub category: String,
        /**
         * The SHA of the commit to which the analysis you are uploading relates.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        /**
         * The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
         */
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub deletable: bool,
        /**
         * Identifies the variable values associated with the environment in which this analysis was performed.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub error: String,
        /**
         * Unique identifier for this analysis.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The full Git reference, formatted as `refs/heads/<branch name>`,
         *  `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        /**
         * The total number of results in the analysis.
         */
        #[serde(default)]
        pub results_count: i64,
        /**
         * The total number of rules used in the analysis.
         */
        #[serde(default)]
        pub rules_count: i64,
        /**
         * An identifier for the upload.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sarif_id: String,
        #[serde()]
        pub tool: CodeScanningAnalysisTool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tool_name: String,
        /**
         * The REST API URL of the analysis resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Warning generated when processing the analysis
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub warning: String,
    }

    /// Successful deletion of a code scanning analysis
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysisDeletion {
        /**
         * Next deletable analysis in chain, with last analysis deletion confirmation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub confirm_delete_url: String,
        /**
         * Next deletable analysis in chain, without last analysis deletion confirmation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub next_analysis_url: String,
    }

    /// Scim Error
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimError {
        /**
         * Scim Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub detail: String,
        /**
         * Scim Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        /**
         * Scim Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * Scim Error
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        /**
         * Scim Error
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub scim_type: String,
        /**
         * Scim Error
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningSarifsReceipt {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * `pending` files have not yet been processed, while `complete` means all results in the SARIF have been stored.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProcessingStatus {
        Complete,
        Pending,
        Noop,
    }

    impl std::fmt::Display for ProcessingStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProcessingStatus::Complete => "complete",
                ProcessingStatus::Pending => "pending",
                ProcessingStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ProcessingStatus {
        fn default() -> ProcessingStatus {
            ProcessingStatus::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningSarifsStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analyses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub processing_status: Option<ProcessingStatus>,
    }

    /// Collaborator
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Collaborator {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        /**
         * Collaborator
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Collaborator
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        /**
         * Collaborator
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<FullRepositoryPermissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The permission associated with the invitation.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum RepositoryInvitationPermissions {
        Admin,
        Maintain,
        Read,
        Triage,
        Write,
        Noop,
    }

    impl std::fmt::Display for RepositoryInvitationPermissions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                RepositoryInvitationPermissions::Admin => "admin",
                RepositoryInvitationPermissions::Maintain => "maintain",
                RepositoryInvitationPermissions::Read => "read",
                RepositoryInvitationPermissions::Triage => "triage",
                RepositoryInvitationPermissions::Write => "write",
                RepositoryInvitationPermissions::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for RepositoryInvitationPermissions {
        fn default() -> RepositoryInvitationPermissions {
            RepositoryInvitationPermissions::Noop
        }
    }

    /// Repository invitations let you manage who you collaborate with.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryInvitation {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Repository invitations let you manage who you collaborate with.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expired: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the repository invitation.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Simple User
         */
        #[serde()]
        pub invitee: User,
        /**
         * Simple User
         */
        #[serde()]
        pub inviter: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The permission associated with the invitation.
         */
        #[serde()]
        pub permissions: RepositoryInvitationPermissions,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        /**
         * URL for the repository invitation
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Commit Comment
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitComment {
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(default)]
        pub line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default)]
        pub position: i64,
        /**
         * Commit Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Branch Short
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchShort {
        #[serde()]
        pub commit: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default)]
        pub protected: bool,
    }

    /// Hypermedia Link
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Link {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    /**
     * The merge method to use.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum MergeMethod {
        Merge,
        Rebase,
        Squash,
        Noop,
    }

    impl std::fmt::Display for MergeMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                MergeMethod::Merge => "merge",
                MergeMethod::Rebase => "rebase",
                MergeMethod::Squash => "squash",
                MergeMethod::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for MergeMethod {
        fn default() -> MergeMethod {
            MergeMethod::Noop
        }
    }

    /// The status of auto merging a pull request.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AutoMerge {
        /**
         * Commit message for the merge commit.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        /**
         * Title for the merge commit message.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_title: String,
        /**
         * Simple User
         */
        #[serde()]
        pub enabled_by: User,
        /**
         * The merge method to use.
         */
        #[serde()]
        pub merge_method: MergeMethod,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleLabels {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Base {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        /**
         * A git repository
         */
        #[serde()]
        pub repo: Repository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleLinks {
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub comments: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub commits: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub html: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub issue: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub review_comment: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub review_comments: Link,
        /**
         * Hypermedia Link
         */
        #[serde(rename = "self")]
        pub self_: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub statuses: Link,
    }

    /// Pull Request Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimple {
        #[serde()]
        pub links: PullRequestSimpleLinks,
        /**
         * Pull Request Simple
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Pull Request Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<User>,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The status of auto merging a pull request.
         */
        #[serde()]
        pub auto_merge: AutoMerge,
        #[serde()]
        pub base: Base,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde()]
        pub closed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        /**
         * Pull Request Simple
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde()]
        pub head: Base,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<PullRequestSimpleLabels>,
        #[serde(default)]
        pub locked: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_commit_sha: String,
        #[serde()]
        pub merged_at: DateTime<Utc>,
        /**
         * A collection of related issues and pull requests.
         */
        #[serde()]
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        /**
         * Pull Request Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_reviewers: Vec<User>,
        /**
         * Pull Request Simple
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SimpleCommitStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Combined Commit Status
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CombinedCommitStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub statuses: Vec<SimpleCommitStatus>,
        #[serde(default)]
        pub total_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// The status of a commit.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Status {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Readme {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityProfileFiles {
        /**
         * Code of Conduct Simple
         */
        #[serde()]
        pub code_of_conduct: CodeOfConductSimple,
        #[serde()]
        pub code_of_conduct_file: Readme,
        #[serde()]
        pub contributing: Readme,
        #[serde()]
        pub issue_template: Readme,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        #[serde()]
        pub pull_request_template: Readme,
        #[serde()]
        pub readme: Readme,
    }

    /// Community Profile
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityProfile {
        /**
         * Community Profile
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub content_reports_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation: String,
        #[serde()]
        pub files: CommunityProfileFiles,
        #[serde(default)]
        pub health_percentage: i64,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    /// Diff Entry
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DiffEntry {
        #[serde(default)]
        pub additions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_url: String,
        #[serde(default)]
        pub changes: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(default)]
        pub deletions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        /**
         * Diff Entry
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch: String,
        /**
         * Diff Entry
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum CommitComparisonStatus {
        Ahead,
        Behind,
        Diverged,
        Identical,
        Noop,
    }

    impl std::fmt::Display for CommitComparisonStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                CommitComparisonStatus::Ahead => "ahead",
                CommitComparisonStatus::Behind => "behind",
                CommitComparisonStatus::Diverged => "diverged",
                CommitComparisonStatus::Identical => "identical",
                CommitComparisonStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for CommitComparisonStatus {
        fn default() -> CommitComparisonStatus {
            CommitComparisonStatus::Noop
        }
    }

    /// Commit Comparison
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitComparison {
        #[serde(default)]
        pub ahead_by: i64,
        #[serde()]
        pub base_commit: Tree,
        #[serde(default)]
        pub behind_by: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub commits: Vec<Tree>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        /**
         * Commit Comparison
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub files: Vec<DiffEntry>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde()]
        pub merge_base_commit: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permalink_url: String,
        #[serde()]
        pub status: CommitComparisonStatus,
        #[serde(default)]
        pub total_commits: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Content Reference attachments allow you to provide context around URLs posted in comments
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentReferenceAttachment {
        /**
         * The body of the attachment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * The ID of the attachment
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Content Reference attachments allow you to provide context around URLs posted in comments
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The title of the attachment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTreeEntriesLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Entries {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Content Tree
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTree {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        /**
         * Content Tree
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub entries: Vec<Entries>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Content File
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentFile {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        /**
         * Content File
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub submodule_git_url: String,
        /**
         * Content File
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// An object describing a symlink
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSymlink {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// An object describing a symlink
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSubmodule {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub submodule_git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitContentLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitContent {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub links: Option<FileCommitContentLinks>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Committer {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitVerification {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub payload: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommit {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<Committer>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<Committer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<FileCommitParents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tree: Option<FileCommitTree>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<FileCommitVerification>,
    }

    /// File Commit
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitData {
        #[serde()]
        pub commit: FileCommit,
        #[serde()]
        pub content: FileCommitContent,
    }

    /// Contributor
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Contributor {
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(default)]
        pub contributions: i64,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Contributor
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        /**
         * Contributor
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        /**
         * Contributor
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The state of the status.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum DeploymentStatusState {
        Error,
        Failure,
        InProgress,
        Inactive,
        Pending,
        Queued,
        Success,
        Noop,
    }

    impl std::fmt::Display for DeploymentStatusState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                DeploymentStatusState::Error => "error",
                DeploymentStatusState::Failure => "failure",
                DeploymentStatusState::InProgress => "in_progress",
                DeploymentStatusState::Inactive => "inactive",
                DeploymentStatusState::Pending => "pending",
                DeploymentStatusState::Queued => "queued",
                DeploymentStatusState::Success => "success",
                DeploymentStatusState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for DeploymentStatusState {
        fn default() -> DeploymentStatusState {
            DeploymentStatusState::Noop
        }
    }

    /// The status of a deployment.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentStatus {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub creator: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployment_url: String,
        /**
         * A short description of the status.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * The status of a deployment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        /**
         * The status of a deployment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * The status of a deployment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub log_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The status of a deployment.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        /**
         * The state of the status.
         */
        #[serde()]
        pub state: DeploymentStatusState,
        /**
         * Deprecated: the URL to associate with this status.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentBranchPolicy {
        /**
         * Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
         */
        #[serde(default)]
        pub custom_branch_policies: bool,
        /**
         * Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
         */
        #[serde(default)]
        pub protected_branches: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectionRules {
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub wait_timer: Option<i64>,
    }

    /// Details of a deployment environment
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnvironmentData {
        /**
         * The time that the environment was created, in ISO 8601 format.
         */
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Details of a deployment environment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment_branch_policy: Option<DeploymentBranchPolicy>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The id of the environment.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * The name of the environment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Details of a deployment environment
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub protection_rules: Vec<ProtectionRules>,
        /**
         * The time that the environment was last updated, in ISO 8601 format.
         */
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Short Blob
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ShortBlob {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Blob
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Blob {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        /**
         * Blob
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub highlighted_content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Identifying information for the git-user
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitAuthor {
        /**
         * Timestamp of the commit
         */
        #[serde()]
        pub date: DateTime<Utc>,
        /**
         * Git email address of the user
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * Name of the git user
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitTree {
        /**
         * SHA for the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * SHA for the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Low-level Git commit operations within a repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommit {
        /**
         * Identifying information for the git-user
         */
        #[serde()]
        pub author: GitCommitAuthor,
        /**
         * Identifying information for the git-user
         */
        #[serde()]
        pub committer: GitCommitAuthor,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Message describing the purpose of the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<GitCommitParents>,
        /**
         * SHA for the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde()]
        pub tree: GitCommitTree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde()]
        pub verification: Verification,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Object {
        /**
         * SHA for the reference
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Git references within a repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitRef {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde()]
        pub object: Object,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tagger {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTagObject {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Metadata for a Git tag
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTag {
        /**
         * Message describing the purpose of the tag
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde()]
        pub object: GitTagObject,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Name of the tag
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag: String,
        #[serde()]
        pub tagger: Tagger,
        /**
         * URL for the tag
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Metadata for a Git tag
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mode: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// The hierarchy between files in a Git repository.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTreeData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Objects specifying a tree structure
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tree: Vec<GitTree>,
        #[serde(default)]
        pub truncated: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HookResponse {
        #[serde(default)]
        pub code: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HookConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub digest: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub room: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subdomain: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Webhooks for repositories.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Hook {
        /**
         * Determines whether the hook is actually triggered on pushes.
         */
        #[serde(default)]
        pub active: bool,
        #[serde()]
        pub config: HookConfig,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Determines what events the hook is triggered for. Default: ['push'].
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        /**
         * Unique identifier of the webhook.
         */
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub last_response: HookResponse,
        /**
         * The name of a valid service, use 'web' for a webhook.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ping_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub test_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ImportStatus {
        Auth,
        AuthFailed,
        Choose,
        Complete,
        Detecting,
        DetectionFoundMultiple,
        DetectionFoundNothing,
        DetectionNeedsAuth,
        Error,
        Importing,
        Mapping,
        None,
        Pushing,
        Setup,
        Unknown,
        WaitingToPush,
        Noop,
    }

    impl std::fmt::Display for ImportStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ImportStatus::Auth => "auth",
                ImportStatus::AuthFailed => "auth_failed",
                ImportStatus::Choose => "choose",
                ImportStatus::Complete => "complete",
                ImportStatus::Detecting => "detecting",
                ImportStatus::DetectionFoundMultiple => "detection_found_multiple",
                ImportStatus::DetectionFoundNothing => "detection_found_nothing",
                ImportStatus::DetectionNeedsAuth => "detection_needs_auth",
                ImportStatus::Error => "error",
                ImportStatus::Importing => "importing",
                ImportStatus::Mapping => "mapping",
                ImportStatus::None => "none",
                ImportStatus::Pushing => "pushing",
                ImportStatus::Setup => "setup",
                ImportStatus::Unknown => "unknown",
                ImportStatus::WaitingToPush => "waiting_to_push",
                ImportStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ImportStatus {
        fn default() -> ImportStatus {
            ImportStatus::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectChoices {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub human_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
    }

    /// A repository import from an external source.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Import {
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub authors_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authors_url: String,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub commit_count: Option<i64>,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub error_message: String,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_step: String,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_large_files: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub import_percent: Option<i64>,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub large_files_count: Option<i64>,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub large_files_size: Option<i64>,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub project_choices: Vec<ProjectChoices>,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push_percent: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde()]
        pub status: ImportStatus,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status_text: String,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svc_root: String,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_root: String,
        /**
         * A repository import from an external source.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * A repository import from an external source.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub use_lfs: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
        /**
         * The URL of the originating repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_url: String,
    }

    /// Porter Author
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PorterAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub import_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub remote_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub remote_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Porter Large File
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PorterLargeFile {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub oid: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ref_name: String,
        #[serde(default)]
        pub size: i64,
    }

    /// Issue Event Label
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventLabel {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventDismissedReview {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_message: String,
        #[serde(default)]
        pub review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    /// Issue Event Milestone
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventMilestone {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /// Issue Event Project Card
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Issue Event Project Card
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        #[serde(default)]
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Issue Event Rename
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventRename {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub from: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub to: String,
    }

    /// Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub assignee: Option<User>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub assigner: Option<User>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author_association: Option<AuthorAssociation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissed_review: Option<IssueEventDismissedReview>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<IssueEventLabel>,
        /**
         * Issue Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub lock_reason: String,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub milestone: Option<IssueEventMilestone>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<IssueEventProjectCard>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rename: Option<IssueEventRename>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<User>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        /**
         * Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub review_requester: Option<User>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabeledIssueEventLabel {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// Labeled Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabeledIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub label: LabeledIssueEventLabel,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Unlabeled Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UnlabeledIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub label: LabeledIssueEventLabel,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Assigned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AssignedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assigner: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Unassigned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UnassignedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assigner: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MilestonedIssueEventMilestone {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /// Milestoned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MilestonedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub milestone: MilestonedIssueEventMilestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Demilestoned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DemilestonedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub milestone: MilestonedIssueEventMilestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Rename {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub from: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub to: String,
    }

    /// Renamed Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RenamedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde()]
        pub rename: Rename,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Review Requested Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewRequestedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Review Requested Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<User>,
        /**
         * Review Requested Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        /**
         * Simple User
         */
        #[serde()]
        pub review_requester: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Review Request Removed Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewRequestRemovedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Review Request Removed Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<User>,
        /**
         * Review Request Removed Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        /**
         * Simple User
         */
        #[serde()]
        pub review_requester: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DismissedReview {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_message: String,
        #[serde(default)]
        pub review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    /// Review Dismissed Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewDismissedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde()]
        pub dismissed_review: DismissedReview,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Locked Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LockedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub lock_reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddedProjectIssueEventCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        #[serde(default)]
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Added to Project Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddedProjectIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Added to Project Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<AddedProjectIssueEventCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Moved Column in Project Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MovedColumnInProjectIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Moved Column in Project Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<AddedProjectIssueEventCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Removed from Project Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemovedFromProjectIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Removed from Project Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<AddedProjectIssueEventCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Converted Note to Issue Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ConvertedNoteIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        /**
         * Converted Note to Issue Issue Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<AddedProjectIssueEventCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Labeled Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventFor {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde()]
        pub label: LabeledIssueEventLabel,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Timeline Comment Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommentEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * Timeline Comment Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Timeline Comment Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Timeline Comment Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the issue comment
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Timeline Comment Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Timeline Comment Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * URL for the issue comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Source {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    /// Timeline Cross Referenced Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCrossReferencedEvent {
        /**
         * Timeline Cross Referenced Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor: Option<User>,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde()]
        pub source: Source,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    /// Timeline Committed Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommittedEvent {
        /**
         * Identifying information for the git-user
         */
        #[serde()]
        pub author: GitCommitAuthor,
        /**
         * Identifying information for the git-user
         */
        #[serde()]
        pub committer: GitCommitAuthor,
        /**
         * Timeline Committed Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Message describing the purpose of the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<GitCommitParents>,
        /**
         * SHA for the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde()]
        pub tree: GitCommitTree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde()]
        pub verification: Verification,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Html {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineReviewedEventLinks {
        #[serde()]
        pub html: Html,
        #[serde()]
        pub pull_request: Html,
    }

    /// Timeline Reviewed Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineReviewedEvent {
        #[serde()]
        pub links: TimelineReviewedEventLinks,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The text of the review.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Timeline Reviewed Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Timeline Reviewed Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        /**
         * A commit SHA for the review.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the review
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        /**
         * Timeline Reviewed Event
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub submitted_at: Option<DateTime<Utc>>,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewCommentLinks {
        #[serde()]
        pub html: Html,
        #[serde()]
        pub pull_request: Html,
        #[serde(rename = "self")]
        pub self_: Html,
    }

    /**
     * The side of the first line of the range for a multi-line comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum StartSide {
        Left,
        Right,
    }

    impl std::fmt::Display for StartSide {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                StartSide::Left => "LEFT",
                StartSide::Right => "RIGHT",
            }
            .fmt(f)
        }
    }

    impl Default for StartSide {
        fn default() -> StartSide {
            StartSide::Right
        }
    }

    /**
     * The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Side {
        Left,
        Right,
    }

    impl std::fmt::Display for Side {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Side::Left => "LEFT",
                Side::Right => "RIGHT",
            }
            .fmt(f)
        }
    }

    impl Default for Side {
        fn default() -> Side {
            Side::Right
        }
    }

    /// Pull Request Review Comments are comments on a portion of the Pull Request's diff.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewComment {
        #[serde()]
        pub links: PullRequestReviewCommentLinks,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The text of the comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        /**
         * The SHA of the commit to which the comment applies.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * The diff of the line that the comment refers to.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_hunk: String,
        /**
         * HTML URL for the pull request review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The ID of the pull request review comment.
         */
        #[serde(default)]
        pub id: i64,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to_id: Option<i64>,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        /**
         * The node ID of the pull request review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * The SHA of the original commit to which the comment applies.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_commit_id: String,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_line: Option<i64>,
        /**
         * The index of the original line in the diff to which the comment applies.
         */
        #[serde(default)]
        pub original_position: i64,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_start_line: Option<i64>,
        /**
         * The relative path of the file to which the comment applies.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        /**
         * The line index in the diff to which the comment applies.
         */
        #[serde(default)]
        pub position: i64,
        /**
         * The ID of the pull request review to which the comment belongs.
         */
        #[serde(default)]
        pub pull_request_review_id: i64,
        /**
         * URL for the pull request that the review comment belongs to.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub side: Option<Side>,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        /**
         * Pull Request Review Comments are comments on a portion of the Pull Request's diff.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_side: Option<StartSide>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * URL for the pull request review comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Timeline Line Commented Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineLineCommentedEvent {
        /**
         * Timeline Line Commented Event
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<PullRequestReviewComment>,
        /**
         * Timeline Line Commented Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        /**
         * Timeline Line Commented Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
    }

    /// Timeline Commit Commented Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommitCommentedEvent {
        /**
         * Timeline Commit Commented Event
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<CommitComment>,
        /**
         * Timeline Commit Commented Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        /**
         * Timeline Commit Commented Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        /**
         * Timeline Commit Commented Event
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
    }

    /// Timeline Assigned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineAssignedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Timeline Unassigned Issue Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineUnassignedIssueEvent {
        /**
         * Simple User
         */
        #[serde()]
        pub actor: User,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
         */
        #[serde()]
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Timeline Event
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineIssueEvents {}

    /// An SSH key granting access to a single repository.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeployKey {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default)]
        pub read_only: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub verified: bool,
    }

    /// Language
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Language {}

    /// License Content
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseContent {
        #[serde()]
        pub links: ContentTreeEntriesLinks,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesSourceHash {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PagesHttpsCertificateState {
        Approved,
        AuthorizationCreated,
        AuthorizationPending,
        AuthorizationRevoked,
        Authorized,
        BadAuthz,
        DestroyPending,
        DnsChanged,
        Errored,
        Issued,
        New,
        Uploaded,
        Noop,
    }

    impl std::fmt::Display for PagesHttpsCertificateState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PagesHttpsCertificateState::Approved => "approved",
                PagesHttpsCertificateState::AuthorizationCreated => "authorization_created",
                PagesHttpsCertificateState::AuthorizationPending => "authorization_pending",
                PagesHttpsCertificateState::AuthorizationRevoked => "authorization_revoked",
                PagesHttpsCertificateState::Authorized => "authorized",
                PagesHttpsCertificateState::BadAuthz => "bad_authz",
                PagesHttpsCertificateState::DestroyPending => "destroy_pending",
                PagesHttpsCertificateState::DnsChanged => "dns_changed",
                PagesHttpsCertificateState::Errored => "errored",
                PagesHttpsCertificateState::Issued => "issued",
                PagesHttpsCertificateState::New => "new",
                PagesHttpsCertificateState::Uploaded => "uploaded",
                PagesHttpsCertificateState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PagesHttpsCertificateState {
        fn default() -> PagesHttpsCertificateState {
            PagesHttpsCertificateState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesHttpsCertificate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Array of the domain set and its alternate name (if it is configured)
         */
        #[serde()]
        pub domains: serde_json::Value,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expires_at: Option<NaiveDate>,
        #[serde()]
        pub state: PagesHttpsCertificateState,
    }

    /**
     * The status of the most recent build of the Page.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PageStatus {
        Building,
        Built,
        Errored,
        Noop,
    }

    impl std::fmt::Display for PageStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PageStatus::Building => "building",
                PageStatus::Built => "built",
                PageStatus::Errored => "errored",
                PageStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PageStatus {
        fn default() -> PageStatus {
            PageStatus::Noop
        }
    }

    /// The configuration for GitHub Pages for a repository.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Page {
        /**
         * The Pages site's custom domain
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cname: String,
        /**
         * Whether the Page has a custom 404 page.
         */
        #[serde(default)]
        pub custom_404: bool,
        /**
         * The configuration for GitHub Pages for a repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * The configuration for GitHub Pages for a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_certificate: Option<PagesHttpsCertificate>,
        /**
         * The configuration for GitHub Pages for a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_enforced: Option<bool>,
        /**
         * Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
         */
        #[serde(default)]
        pub public: bool,
        /**
         * The configuration for GitHub Pages for a repository.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<PagesSourceHash>,
        /**
         * The status of the most recent build of the Page.
         */
        #[serde()]
        pub status: PageStatus,
        /**
         * The API address for accessing this Page resource.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Error {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    /// Page Build
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PageBuild {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub duration: i64,
        #[serde()]
        pub error: Error,
        /**
         * Simple User
         */
        #[serde()]
        pub pusher: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Page Build Status
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PageBuildStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Domain {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caa_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_resolves: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforces_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_cname_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_mx_records_present: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub host: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub https_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_a_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_apex_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cloudflare_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_fastly: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_github_user_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_fastly_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_https_eligible: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_non_github_pages_ip_present: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_old_ip_address: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pages_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pointed_to_github_pages_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_proxied: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_served_by_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid_domain: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub nameservers: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub responds_to_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub should_be_a_record: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub uri: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AltDomain {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caa_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_resolves: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforces_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_cname_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_mx_records_present: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub host: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub https_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_a_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_apex_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cloudflare_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_fastly: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_github_user_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_fastly_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_https_eligible: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_non_github_pages_ip_present: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_old_ip_address: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pages_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pointed_to_github_pages_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_proxied: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_served_by_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid_domain: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub nameservers: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub responds_to_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub should_be_a_record: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub uri: String,
    }

    /// Pages Health Check Status
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesHealthCheck {
        /**
         * Pages Health Check Status
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub alt_domain: Option<AltDomain>,
        /**
         * Pages Health Check Status
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub domain: Option<Domain>,
    }

    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullRequestState {
        Closed,
        Open,
        Noop,
    }

    impl std::fmt::Display for PullRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullRequestState::Closed => "closed",
                PullRequestState::Open => "open",
                PullRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullRequestState {
        fn default() -> PullRequestState {
            PullRequestState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadRepoOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadRepoLicense {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadRepo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default)]
        pub has_downloads: bool,
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        #[serde(default)]
        pub has_projects: bool,
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        #[serde()]
        pub license: PullRequestHeadRepoLicense,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        #[serde()]
        pub owner: PullRequestHeadRepoOwner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<FullRepositoryPermissions>,
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHead {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde()]
        pub repo: PullRequestHeadRepo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde()]
        pub user: PullRequestHeadRepoOwner,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBaseRepo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default)]
        pub has_downloads: bool,
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        #[serde(default)]
        pub has_projects: bool,
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        #[serde()]
        pub owner: PullRequestHeadRepoOwner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<FullRepositoryPermissions>,
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBase {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde()]
        pub repo: PullRequestBaseRepo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde()]
        pub user: PullRequestHeadRepoOwner,
    }

    /// Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestData {
        #[serde()]
        pub links: PullRequestSimpleLinks,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        #[serde(default)]
        pub additions: i64,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<User>,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The status of auto merging a pull request.
         */
        #[serde()]
        pub auto_merge: AutoMerge,
        #[serde()]
        pub base: PullRequestBase,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default)]
        pub changed_files: i64,
        #[serde()]
        pub closed_at: DateTime<Utc>,
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(default)]
        pub commits: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub deletions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde()]
        pub head: PullRequestHead,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<PullRequestSimpleLabels>,
        #[serde(default)]
        pub locked: bool,
        /**
         * Indicates whether maintainers can modify the pull request.
         */
        #[serde(default)]
        pub maintainer_can_modify: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_commit_sha: String,
        #[serde(default)]
        pub mergeable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mergeable_state: String,
        #[serde(default)]
        pub merged: bool,
        #[serde()]
        pub merged_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub merged_by: User,
        /**
         * A collection of related issues and pull requests.
         */
        #[serde()]
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Number uniquely identifying the pull request within its repository.
         */
        #[serde(default)]
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rebaseable: Option<bool>,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_reviewers: Vec<User>,
        /**
         * Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_teams: Vec<Parent>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comment_url: String,
        #[serde(default)]
        pub review_comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comments_url: String,
        /**
         * State of this Pull Request. Either `open` or `closed`.
         */
        #[serde()]
        pub state: PullRequestState,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        /**
         * The title of the pull request.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Pull Request Merge Result
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestMergeResult {
        #[serde(default)]
        pub merged: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    /// Pull Request Review Request
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReview {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<User>,
    }

    /// Pull Request Reviews are reviews on pull requests.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewData {
        #[serde()]
        pub links: TimelineReviewedEventLinks,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * The text of the review.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Pull Request Reviews are reviews on pull requests.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Pull Request Reviews are reviews on pull requests.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        /**
         * A commit SHA for the review.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Unique identifier of the review
         */
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        /**
         * Pull Request Reviews are reviews on pull requests.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub submitted_at: Option<DateTime<Utc>>,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewCommentLinks {
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub html: Link,
        /**
         * Hypermedia Link
         */
        #[serde()]
        pub pull_request: Link,
        /**
         * Hypermedia Link
         */
        #[serde(rename = "self")]
        pub self_: Link,
    }

    /// Legacy Review Comment
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewComment {
        #[serde()]
        pub links: ReviewCommentLinks,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Legacy Review Comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Legacy Review Comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_hunk: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to_id: Option<i64>,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_commit_id: String,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_line: Option<i64>,
        #[serde(default)]
        pub original_position: i64,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default)]
        pub position: i64,
        #[serde(default)]
        pub pull_request_review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub side: Option<StartSide>,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        /**
         * Legacy Review Comment
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_side: Option<StartSide>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /**
     * State of the release asset.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReleaseAssetState {
        Open,
        Uploaded,
        Noop,
    }

    impl std::fmt::Display for ReleaseAssetState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReleaseAssetState::Open => "open",
                ReleaseAssetState::Uploaded => "uploaded",
                ReleaseAssetState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReleaseAssetState {
        fn default() -> ReleaseAssetState {
            ReleaseAssetState::Noop
        }
    }

    /// Data related to a release.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReleaseAsset {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub browser_download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub download_count: i64,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        /**
         * The file name of the asset.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub size: i64,
        /**
         * State of the release asset.
         */
        #[serde()]
        pub state: ReleaseAssetState,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub uploader: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// A release.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Release {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assets: Vec<ReleaseAsset>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assets_url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        /**
         * A release.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * A release.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * A release.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * A release.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_url: String,
        /**
         * true to create a draft (unpublished) release, false to create a published one.
         */
        #[serde(default)]
        pub draft: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        /**
         * Whether to identify the release as a prerelease or a full release.
         */
        #[serde(default)]
        pub prerelease: bool,
        #[serde()]
        pub published_at: DateTime<Utc>,
        /**
         * A release.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        /**
         * The name of the tag.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tarball_url: String,
        /**
         * Specifies the commitish value that determines where the Git tag is created from.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub upload_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub zipball_url: String,
    }

    /**
     * Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SecretScanningAlertState {
        Open,
        Resolved,
        Noop,
    }

    impl std::fmt::Display for SecretScanningAlertState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SecretScanningAlertState::Open => "open",
                SecretScanningAlertState::Resolved => "resolved",
                SecretScanningAlertState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SecretScanningAlertState {
        fn default() -> SecretScanningAlertState {
            SecretScanningAlertState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecretScanningAlert {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub number: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolution: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolved_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolved_by: Option<User>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<SecretScanningAlertState>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Stargazer
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Stargazer {
        #[serde()]
        pub starred_at: DateTime<Utc>,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Commit Activity
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitActivity {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub days: Vec<i64>,
        #[serde(default)]
        pub total: i64,
        #[serde(default)]
        pub week: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Weeks {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub a: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub c: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub d: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub w: Option<i64>,
    }

    /// Contributor Activity
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContributorActivity {
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        #[serde(default)]
        pub total: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub weeks: Vec<Weeks>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ParticipationStats {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub all: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub owner: Vec<i64>,
    }

    /// Repository invitations let you manage who you collaborate with.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositorySubscription {
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Determines if all notifications should be blocked from this repository.
         */
        #[serde(default)]
        pub ignored: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        /**
         * Determines if notifications should be received from this repository.
         */
        #[serde(default)]
        pub subscribed: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Tag
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tag {
        #[serde()]
        pub commit: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tarball_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub zipball_url: String,
    }

    /// A topic aggregates entities that are related to a subject.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Topic {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub names: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Traffic {
        #[serde(default)]
        pub count: i64,
        #[serde()]
        pub timestamp: DateTime<Utc>,
        #[serde(default)]
        pub uniques: i64,
    }

    /// Clone Traffic
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CloneTraffic {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub clones: Vec<Traffic>,
        #[serde(default)]
        pub count: i64,
        #[serde(default)]
        pub uniques: i64,
    }

    /// Content Traffic
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTraffic {
        #[serde(default)]
        pub count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(default)]
        pub uniques: i64,
    }

    /// Referrer Traffic
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReferrerTraffic {
        #[serde(default)]
        pub count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub referrer: String,
        #[serde(default)]
        pub uniques: i64,
    }

    /// View Traffic
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ViewTraffic {
        #[serde(default)]
        pub count: i64,
        #[serde(default)]
        pub uniques: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub views: Vec<Traffic>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimGroupListEnterpriseResourcesMembers {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "$ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Meta {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub last_modified: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimGroupListEnterpriseResources {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<ScimGroupListEnterpriseResourcesMembers>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimGroupListEnterprise {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<ScimGroupListEnterpriseResources>,
        #[serde(default)]
        pub items_per_page: f64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(default)]
        pub start_index: f64,
        #[serde(default)]
        pub total_results: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimEnterpriseGroup {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<ScimGroupListEnterpriseResourcesMembers>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Name {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Emails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterpriseResourcesGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterpriseResources {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<ScimUserListEnterpriseResourcesGroups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterprise {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<ScimUserListEnterpriseResources>,
        #[serde(default)]
        pub items_per_page: f64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(default)]
        pub start_index: f64,
        #[serde(default)]
        pub total_results: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimEnterpriseUser {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<ScimUserListEnterpriseResourcesGroups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub formatted: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserEmails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserMeta {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_modified: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Op {
        Add,
        Remove,
        Replace,
        Noop,
    }

    impl std::fmt::Display for Op {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Op::Add => "add",
                Op::Remove => "remove",
                Op::Replace => "replace",
                Op::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Op {
        fn default() -> Op {
            Op::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Operations {
        #[serde()]
        pub op: Op,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    /// SCIM /Users provisioning endpoints
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUser {
        /**
         * The active status of the User.
         */
        #[serde(default)]
        pub active: bool,
        /**
         * SCIM /Users provisioning endpoints
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        /**
         * user emails
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<ScimUserEmails>,
        /**
         * The ID of the User.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        /**
         * SCIM /Users provisioning endpoints
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<serde_json::Value>,
        /**
         * Unique identifier of an external identity
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde()]
        pub meta: ScimUserMeta,
        #[serde()]
        pub name: ScimUserName,
        /**
         * SCIM /Users provisioning endpoints
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Operations>,
        /**
         * SCIM /Users provisioning endpoints
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_id: Option<i64>,
        /**
         * SCIM schema used.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        /**
         * Configured by the admin. Could be an email, login, or username
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    /// SCIM User List
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserList {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<ScimUser>,
        #[serde(default)]
        pub items_per_page: i64,
        /**
         * SCIM schema used.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(default)]
        pub start_index: i64,
        #[serde(default)]
        pub total_results: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Matches {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub indices: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SearchResultTextMatches {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fragment: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub matches: Vec<Matches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub property: String,
    }

    /// Code Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeSearchResultItem {
        /**
         * Code Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub file_size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        /**
         * Code Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        /**
         * Code Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_modified_at: Option<DateTime<Utc>>,
        /**
         * Code Search Result Item
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub line_numbers: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        #[serde(default)]
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Code Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemAuthor {
        #[serde()]
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItem {
        #[serde()]
        pub author: CommitSearchResultItemAuthor,
        #[serde(default)]
        pub comment_count: i64,
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde()]
        pub committer: GitUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde()]
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    /// Commit Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemData {
        /**
         * Simple User
         */
        #[serde()]
        pub author: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub commit: CommitSearchResultItem,
        /**
         * Metaproperties for Git author/committer information.
         */
        #[serde()]
        pub committer: GitUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<FileCommitParents>,
        /**
         * Minimal Repository
         */
        #[serde()]
        pub repository: MinimalRepository,
        #[serde(default)]
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        /**
         * Commit Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Issue Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueSearchResultItem {
        /**
         * Issue Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        /**
         * Simple User
         */
        #[serde()]
        pub assignee: User,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<User>,
        /**
         * How the author is associated with the repository.
         */
        #[serde()]
        pub author_association: AuthorAssociation,
        /**
         * Issue Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Issue Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        /**
         * Issue Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde()]
        pub closed_at: DateTime<Utc>,
        #[serde(default)]
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<PullRequestSimpleLabels>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(default)]
        pub locked: bool,
        /**
         * A collection of related issues and pull requests.
         */
        #[serde()]
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub number: i64,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(default)]
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        /**
         * Issue Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        /**
         * Issue Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Simple User
         */
        #[serde()]
        pub user: User,
    }

    /// Label Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabelSearchResultItem {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default)]
        pub default: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default)]
        pub score: f64,
        /**
         * Label Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Repo Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepoSearchResultItem {
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default)]
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Returns whether or not this repository disabled.
         */
        #[serde(default)]
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub fork: bool,
        #[serde(default)]
        pub forks: i64,
        #[serde(default)]
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default)]
        pub has_downloads: bool,
        #[serde(default)]
        pub has_issues: bool,
        #[serde(default)]
        pub has_pages: bool,
        #[serde(default)]
        pub has_projects: bool,
        #[serde(default)]
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        /**
         * License Simple
         */
        #[serde()]
        pub license: License,
        /**
         * Repo Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default)]
        pub open_issues: i64,
        #[serde(default)]
        pub open_issues_count: i64,
        /**
         * Simple User
         */
        #[serde()]
        pub owner: User,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<FullRepositoryPermissions>,
        #[serde(default)]
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde()]
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default)]
        pub score: f64,
        #[serde(default)]
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default)]
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        /**
         * Repo Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        /**
         * Repo Search Result Item
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub watchers: i64,
        #[serde(default)]
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TopicRelation {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub relation_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub topic_id: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Related {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub topic_relation: Option<TopicRelation>,
    }

    /// Topic Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TopicSearchResultItem {
        /**
         * Topic Search Result Item
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub aliases: Vec<Related>,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_by: String,
        #[serde(default)]
        pub curated: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default)]
        pub featured: bool,
        /**
         * Topic Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub logo_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        /**
         * Topic Search Result Item
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub related: Vec<Related>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub released: String,
        /**
         * Topic Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_count: Option<i64>,
        #[serde(default)]
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub short_description: String,
        /**
         * Topic Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    /// User Search Result Item
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UserSearchResultItem {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub followers: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub following: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hireable: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        /**
         * User Search Result Item
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_gists: Option<i64>,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_repos: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub score: f64,
        #[serde(default)]
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        /**
         * User Search Result Item
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Private User
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PrivateUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        /**
         * Private User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub business_plus: Option<bool>,
        #[serde(default)]
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub disk_usage: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default)]
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(default)]
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(default)]
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default)]
        pub id: i64,
        /**
         * Private User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(default)]
        pub owned_private_repos: i64,
        /**
         * Private User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        #[serde(default)]
        pub private_gists: i64,
        #[serde(default)]
        pub public_gists: i64,
        #[serde(default)]
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default)]
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        /**
         * Private User
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        #[serde(default)]
        pub total_private_repos: i64,
        /**
         * Private User
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        #[serde(default)]
        pub two_factor_authentication: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde()]
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// Email
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Email {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default)]
        pub primary: bool,
        #[serde(default)]
        pub verified: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GpgKeyEmails {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Subkeys {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_certify: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_encrypt_comms: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_encrypt_storage: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_sign: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expires_at: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary_key_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub subkeys: Vec<serde_json::Value>,
    }

    /// A unique encryption key
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GpgKey {
        #[serde(default)]
        pub can_certify: bool,
        #[serde(default)]
        pub can_encrypt_comms: bool,
        #[serde(default)]
        pub can_encrypt_storage: bool,
        #[serde(default)]
        pub can_sign: bool,
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<GpgKeyEmails>,
        #[serde()]
        pub expires_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(default)]
        pub primary_key_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub subkeys: Vec<Subkeys>,
    }

    /// Key
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Key {
        #[serde()]
        pub created_at: DateTime<Utc>,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default)]
        pub read_only: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default)]
        pub verified: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplaceAccount {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /// User Marketplace Purchase
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UserMarketplacePurchase {
        #[serde()]
        pub account: MarketplaceAccount,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_cycle: String,
        #[serde()]
        pub free_trial_ends_on: DateTime<Utc>,
        #[serde()]
        pub next_billing_date: DateTime<Utc>,
        #[serde(default)]
        pub on_free_trial: bool,
        /**
         * Marketplace Listing Plan
         */
        #[serde()]
        pub plan: MarketplaceListingPlan,
        #[serde(default)]
        pub unit_count: i64,
        #[serde()]
        pub updated_at: DateTime<Utc>,
    }

    /// Starred Repository
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StarredRepository {
        /**
         * A git repository
         */
        #[serde()]
        pub repo: Repository,
        #[serde()]
        pub starred_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Contexts {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub octicon: String,
    }

    /// Hovercard
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Hovercard {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<Contexts>,
    }

    /// Key Simple
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct KeySimple {
        #[serde(default)]
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
    }

    /**
     * The event types to include:
     *   
     *   - `web` - returns web (non-Git) events
     *   - `git` - returns Git events
     *   - `all` - returns both web and Git events
     *   
     *   The default is `web`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AuditLogInclude {
        All,
        Git,
        Web,
        Noop,
    }

    impl std::fmt::Display for AuditLogInclude {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AuditLogInclude::All => "all",
                AuditLogInclude::Git => "git",
                AuditLogInclude::Web => "web",
                AuditLogInclude::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AuditLogInclude {
        fn default() -> AuditLogInclude {
            AuditLogInclude::Noop
        }
    }

    /**
     * The order of audit log events. To list newest events first, specify `desc`. To list oldest events first, specify `asc`.
     *   
     *   The default is `desc`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AuditLogOrder {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for AuditLogOrder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AuditLogOrder::Asc => "asc",
                AuditLogOrder::Desc => "desc",
                AuditLogOrder::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AuditLogOrder {
        fn default() -> AuditLogOrder {
            AuditLogOrder::Noop
        }
    }

    /**
     * One of `asc` (ascending) or `desc` (descending).
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Direction {
        Asc,
        Desc,
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Direction::Asc => "asc",
                Direction::Desc => "desc",
            }
            .fmt(f)
        }
    }

    impl Default for Direction {
        fn default() -> Direction {
            Direction::Desc
        }
    }

    /**
     * One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Sort {
        Created,
        Updated,
    }

    impl std::fmt::Display for Sort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Sort::Created => "created",
                Sort::Updated => "updated",
            }
            .fmt(f)
        }
    }

    impl Default for Sort {
        fn default() -> Sort {
            Sort::Created
        }
    }

    /**
     * The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PackageTypeData {
        Container,
        Docker,
        Maven,
        Npm,
        Nuget,
        Rubygems,
        Noop,
    }

    impl std::fmt::Display for PackageTypeData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PackageTypeData::Container => "container",
                PackageTypeData::Docker => "docker",
                PackageTypeData::Maven => "maven",
                PackageTypeData::Npm => "npm",
                PackageTypeData::Nuget => "nuget",
                PackageTypeData::Rubygems => "rubygems",
                PackageTypeData::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PackageTypeData {
        fn default() -> PackageTypeData {
            PackageTypeData::Noop
        }
    }

    /**
     * Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run)."
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum WorkflowRunStatus {
        ActionRequired,
        Cancelled,
        Completed,
        Failure,
        InProgress,
        Neutral,
        Queued,
        Requested,
        Skipped,
        Stale,
        Success,
        TimedOut,
        Waiting,
        Noop,
    }

    impl std::fmt::Display for WorkflowRunStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                WorkflowRunStatus::ActionRequired => "action_required",
                WorkflowRunStatus::Cancelled => "cancelled",
                WorkflowRunStatus::Completed => "completed",
                WorkflowRunStatus::Failure => "failure",
                WorkflowRunStatus::InProgress => "in_progress",
                WorkflowRunStatus::Neutral => "neutral",
                WorkflowRunStatus::Queued => "queued",
                WorkflowRunStatus::Requested => "requested",
                WorkflowRunStatus::Skipped => "skipped",
                WorkflowRunStatus::Stale => "stale",
                WorkflowRunStatus::Success => "success",
                WorkflowRunStatus::TimedOut => "timed_out",
                WorkflowRunStatus::Waiting => "waiting",
                WorkflowRunStatus::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for WorkflowRunStatus {
        fn default() -> WorkflowRunStatus {
            WorkflowRunStatus::Noop
        }
    }

    /**
     * Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or `completed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum StatusData {
        Completed,
        InProgress,
        Queued,
        Noop,
    }

    impl std::fmt::Display for StatusData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                StatusData::Completed => "completed",
                StatusData::InProgress => "in_progress",
                StatusData::Queued => "queued",
                StatusData::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for StatusData {
        fn default() -> StatusData {
            StatusData::Noop
        }
    }

    /**
     * Must be one of: `day`, `week`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Per {
        Day,
        Week,
    }

    impl std::fmt::Display for Per {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Per::Day => "day",
                Per::Week => "week",
            }
            .fmt(f)
        }
    }

    impl Default for Per {
        fn default() -> Per {
            Per::Day
        }
    }

    /**
     * Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Order {
        Asc,
        Desc,
    }

    impl std::fmt::Display for Order {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Order::Asc => "asc",
                Order::Desc => "desc",
            }
            .fmt(f)
        }
    }

    impl Default for Order {
        fn default() -> Order {
            Order::Desc
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetMetaRootOkResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_authorizations_html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emails_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emojis_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub feeds_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hub_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub rate_limit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub topic_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsUpdateWebhookConfigAppRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsCreateInstallationAccessTokenRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsDeleteAuthorizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsCheckTokenRequest {
        /**
         * The access_token of the OAuth application.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsDeleteTokenRequest {
        /**
         * The OAuth access token used to authenticate to the GitHub API.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsScopeTokenRequest {
        /**
         * The OAuth access token used to authenticate to the GitHub API.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repository_ids: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub target_id: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OauthAuthorizationsCreateAuthorizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OauthAuthorizationsGetCreateAuthorizationAppRequest {
        /**
         * The OAuth app client secret for which to create the token.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OauthAuthorizationsGetCreateAuthorizationAppFingerprintRequest {
        /**
         * The OAuth app client secret for which to create the token.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OauthAuthorizationsUpdateAuthorizationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub add_scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub remove_scopes: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminSetGithubActionsPermissionsRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed_actions: Option<AllowedActions>,
        /**
         * The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
         */
        #[serde()]
        pub enabled_organizations: EnabledOrganizations,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetEnterpriseAdminListOrgAccessSelfHostedRunnerGroupInOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub organizations: Vec<OrganizationSimple>,
        #[serde(default)]
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsRequest {
        /**
         * List of organization IDs to enable for GitHub Actions.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetEnterpriseAdminListSelfHostedRunnerGroupsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runner_groups: Vec<RunnerGroupsEnterprise>,
        #[serde(default)]
        pub total_count: f64,
    }

    /**
     * Visibility of a runner group. You can select all organizations or select individual organization. Can be one of: `all` or `selected`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility {
        All,
        Selected,
        Noop,
    }

    impl std::fmt::Display for EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility::All => "all",
                EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility::Selected => "selected",
                EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility {
        fn default() -> EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility {
            EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminCreateSelfHostedRunnerGroupRequest {
        /**
         * Name of the runner group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<EnterpriseAdminCreateSelfHostedRunnerGroupRequestVisibility>,
    }

    /**
     * Visibility of a runner group. You can select all organizations or select individual organizations. Can be one of: `all` or `selected`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility {
        All,
        Selected,
    }

    impl std::fmt::Display for EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility::All => "all",
                EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility::Selected => "selected",
            }
            .fmt(f)
        }
    }

    impl Default for EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility {
        fn default() -> EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility {
            EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility::All
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminUpdateSelfHostedRunnerGroupRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<EnterpriseAdminUpdateSelfHostedRunnerGroupRequestVisibility>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminSetOrgAccessSelfHostedRunnerGroupInRequest {
        /**
         * List of organization IDs that can access the runner group.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListSelfHostedRunnersInGroupOrgOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        #[serde(default)]
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetSelfHostedRunnersInGroupOrgRequest {
        /**
         * List of runner IDs to add to the runner group.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetEnterpriseAdminListSelfHostedRunnersOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<f64>,
    }

    /// Names and content for the files that make up the gist
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistsCreateRequestFiles {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistsCreateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Names and content for the files that make up the gist
         */
        #[serde()]
        pub files: GistsCreateRequestFiles,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
    }

    /// Names of files to be updated
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistsUpdateRequestFiles {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistsUpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub files: Option<GistsUpdateRequestFiles>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistsCreateCommentRequest {
        /**
         * The comment text.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetAppsListInstallationReposOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Indicates which sorts of issues to return. Can be one of:  
     *   \* `assigned`: Issues assigned to you  
     *   \* `created`: Issues created by you  
     *   \* `mentioned`: Issues mentioning you  
     *   \* `subscribed`: Issues you're subscribed to updates for  
     *   \* `all`: All issues the authenticated user can see, regardless of participation or creation
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListFilter {
        All,
        Assigned,
        Created,
        Mentioned,
        Repos,
        Subscribed,
    }

    impl std::fmt::Display for IssuesListFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListFilter::All => "all",
                IssuesListFilter::Assigned => "assigned",
                IssuesListFilter::Created => "created",
                IssuesListFilter::Mentioned => "mentioned",
                IssuesListFilter::Repos => "repos",
                IssuesListFilter::Subscribed => "subscribed",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListFilter {
        fn default() -> IssuesListFilter {
            IssuesListFilter::Assigned
        }
    }

    /**
     * Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListState {
        All,
        Closed,
        Open,
    }

    impl std::fmt::Display for IssuesListState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListState::All => "all",
                IssuesListState::Closed => "closed",
                IssuesListState::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListState {
        fn default() -> IssuesListState {
            IssuesListState::Open
        }
    }

    /**
     * What to sort results by. Can be either `created`, `updated`, `comments`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListSort {
        Comments,
        Created,
        Updated,
    }

    impl std::fmt::Display for IssuesListSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListSort::Comments => "comments",
                IssuesListSort::Created => "created",
                IssuesListSort::Updated => "updated",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListSort {
        fn default() -> IssuesListSort {
            IssuesListSort::Created
        }
    }

    /**
     * The rendering mode.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Mode {
        Gfm,
        Markdown,
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Mode::Gfm => "gfm",
                Mode::Markdown => "markdown",
            }
            .fmt(f)
        }
    }

    impl Default for Mode {
        fn default() -> Mode {
            Mode::Markdown
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarkdownRenderRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mode: Option<Mode>,
        /**
         * The Markdown text to render in HTML.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    /**
     * To return the oldest accounts first, set to `asc`. Can be one of `asc` or `desc`. Ignored without the `sort` parameter.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AppsListAccountsPlanDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for AppsListAccountsPlanDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AppsListAccountsPlanDirection::Asc => "asc",
                AppsListAccountsPlanDirection::Desc => "desc",
                AppsListAccountsPlanDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AppsListAccountsPlanDirection {
        fn default() -> AppsListAccountsPlanDirection {
            AppsListAccountsPlanDirection::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActivityMarkNotificationsAsReadRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_read_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostReposCreateDeploymentAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActivitySetThreadSubscriptionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ignored: Option<bool>,
    }

    /**
     * Default permission level members have for organization repositories:  
     *   \* `read` - can pull, but not push to or administer this repository.  
     *   \* `write` - can pull and push, but not administer this repository.  
     *   \* `admin` - can pull, push, and administer this repository.  
     *   \* `none` - no permissions granted by default.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum DefaultRepositoryPermission {
        Admin,
        None,
        Read,
        Write,
    }

    impl std::fmt::Display for DefaultRepositoryPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                DefaultRepositoryPermission::Admin => "admin",
                DefaultRepositoryPermission::None => "none",
                DefaultRepositoryPermission::Read => "read",
                DefaultRepositoryPermission::Write => "write",
            }
            .fmt(f)
        }
    }

    impl Default for DefaultRepositoryPermission {
        fn default() -> DefaultRepositoryPermission {
            DefaultRepositoryPermission::Read
        }
    }

    /**
     * Specifies which types of repositories non-admin organization members can create. Can be one of:  
     *   \* `all` - all organization members can create public and private repositories.  
     *   \* `private` - members can create private repositories. This option is only available to repositories that are part of an organization on GitHub Enterprise Cloud.  
     *   \* `none` - only admin members can create repositories.  
     *   **Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum MembersAllowedRepositoryCreationType {
        All,
        None,
        Private,
        Noop,
    }

    impl std::fmt::Display for MembersAllowedRepositoryCreationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                MembersAllowedRepositoryCreationType::All => "all",
                MembersAllowedRepositoryCreationType::None => "none",
                MembersAllowedRepositoryCreationType::Private => "private",
                MembersAllowedRepositoryCreationType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for MembersAllowedRepositoryCreationType {
        fn default() -> MembersAllowedRepositoryCreationType {
            MembersAllowedRepositoryCreationType::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsUpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default_repository_permission: Option<DefaultRepositoryPermission>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_organization_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_repository_projects: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_allowed_repository_creation_type: Option<MembersAllowedRepositoryCreationType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_internal_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetGithubPermissionsOrganizationRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed_actions: Option<AllowedActions>,
        /**
         * The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
         */
        #[serde()]
        pub enabled_repositories: EnabledRepositories,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListSelectedRepositoriesEnabledGithubOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(default)]
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetSelectedRepositoriesEnabledGithubOrganizationRequest {
        /**
         * List of repository IDs to enable for GitHub Actions.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListSelfHostedRunnerGroupsOrgOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runner_groups: Vec<RunnerGroupsOrg>,
        #[serde(default)]
        pub total_count: f64,
    }

    /**
     * Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories. Can be one of: `all`, `selected`, or `private`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility {
        All,
        Private,
        Selected,
    }

    impl std::fmt::Display for ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility::All => "all",
                ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility::Private => "private",
                ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility::Selected => "selected",
            }
            .fmt(f)
        }
    }

    impl Default for ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility {
        fn default() -> ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility {
            ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility::All
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsCreateSelfHostedRunnerGroupOrgRequest {
        /**
         * Name of the runner group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<ActionsCreateSelfHostedRunnerGroupOrgRequestVisibility>,
    }

    /**
     * Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories. Can be one of: `all`, `selected`, or `private`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility {
        All,
        Private,
        Selected,
        Noop,
    }

    impl std::fmt::Display for ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility::All => "all",
                ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility::Private => "private",
                ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility::Selected => "selected",
                ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility {
        fn default() -> ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility {
            ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsUpdateSelfHostedRunnerGroupOrgRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<ActionsUpdateSelfHostedRunnerGroupOrgRequestVisibility>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListRepoAccessSelfHostedRunnerGroupInOrgOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<MinimalRepository>,
        #[serde(default)]
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetRepoAccessSelfHostedRunnerGroupInOrgRequest {
        /**
         * List of repository IDs that can access the runner group.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListSelfHostedRunnersOrgOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListOrgSecretsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub secrets: Vec<OrganizationActionsSecret>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Configures the access that repositories have to the organization secret. Can be one of:  
     *   \- `all` - All repositories in an organization can access the secret.  
     *   \- `private` - Private repositories in an organization can access the secret.  
     *   \- `selected` - Only specific repositories can access the secret.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ActionsCreateUpdateOrgSecretRequestVisibility {
        All,
        Private,
        Selected,
        Noop,
    }

    impl std::fmt::Display for ActionsCreateUpdateOrgSecretRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ActionsCreateUpdateOrgSecretRequestVisibility::All => "all",
                ActionsCreateUpdateOrgSecretRequestVisibility::Private => "private",
                ActionsCreateUpdateOrgSecretRequestVisibility::Selected => "selected",
                ActionsCreateUpdateOrgSecretRequestVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ActionsCreateUpdateOrgSecretRequestVisibility {
        fn default() -> ActionsCreateUpdateOrgSecretRequestVisibility {
            ActionsCreateUpdateOrgSecretRequestVisibility::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsCreateUpdateOrgSecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<String>,
        /**
         * Configures the access that repositories have to the organization secret. Can be one of:  
         *  \- `all` - All repositories in an organization can access the secret.  
         *  \- `private` - Private repositories in an organization can access the secret.  
         *  \- `selected` - Only specific repositories can access the secret.
         */
        #[serde()]
        pub visibility: ActionsCreateUpdateOrgSecretRequestVisibility,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListSelectedReposOrgSecretOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<MinimalRepository>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetSelectedReposOrgSecretRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    /// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsCreateWebhookRequestConfig {
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub password: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        /**
         * The URL to which the payloads will be delivered.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsCreateWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).
         */
        #[serde()]
        pub config: OrgsCreateWebhookRequestConfig,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        /**
         * Must be passed as "web".
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsUpdateWebhookRequestConfig {
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        /**
         * The URL to which the payloads will be delivered.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsUpdateWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<OrgsUpdateWebhookRequestConfig>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetAppsListInstallationsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub installations: Vec<Installation>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Specify role for new member. Can be one of:  
     *   \* `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  
     *   \* `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  
     *   \* `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsCreateInvitationRequestRole {
        Admin,
        BillingManager,
        DirectMember,
    }

    impl std::fmt::Display for OrgsCreateInvitationRequestRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsCreateInvitationRequestRole::Admin => "admin",
                OrgsCreateInvitationRequestRole::BillingManager => "billing_manager",
                OrgsCreateInvitationRequestRole::DirectMember => "direct_member",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsCreateInvitationRequestRole {
        fn default() -> OrgsCreateInvitationRequestRole {
            OrgsCreateInvitationRequestRole::DirectMember
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsCreateInvitationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub invitee_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub role: Option<OrgsCreateInvitationRequestRole>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_ids: Vec<i64>,
    }

    /**
     * Filter members returned in the list. Can be one of:  
     *   \* `2fa_disabled` - Members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled. Available for organization owners.  
     *   \* `all` - All members the authenticated user can see.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsListMembersFilter {
        TwoFaDisabled,
        All,
    }

    impl std::fmt::Display for OrgsListMembersFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsListMembersFilter::TwoFaDisabled => "2fa_disabled",
                OrgsListMembersFilter::All => "all",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsListMembersFilter {
        fn default() -> OrgsListMembersFilter {
            OrgsListMembersFilter::All
        }
    }

    /**
     * Filter members returned by their role. Can be one of:  
     *   \* `all` - All members of the organization, regardless of role.  
     *   \* `admin` - Organization owners.  
     *   \* `member` - Non-owner organization members.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsListMembersRole {
        Admin,
        All,
        Member,
    }

    impl std::fmt::Display for OrgsListMembersRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsListMembersRole::Admin => "admin",
                OrgsListMembersRole::All => "all",
                OrgsListMembersRole::Member => "member",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsListMembersRole {
        fn default() -> OrgsListMembersRole {
            OrgsListMembersRole::All
        }
    }

    /**
     * The role to give the user in the organization. Can be one of:  
     *   \* `admin` - The user will become an owner of the organization.  
     *   \* `member` - The user will become a non-owner member of the organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsSetMembershipUserRequestRole {
        Admin,
        Member,
    }

    impl std::fmt::Display for OrgsSetMembershipUserRequestRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsSetMembershipUserRequestRole::Admin => "admin",
                OrgsSetMembershipUserRequestRole::Member => "member",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsSetMembershipUserRequestRole {
        fn default() -> OrgsSetMembershipUserRequestRole {
            OrgsSetMembershipUserRequestRole::Member
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsSetMembershipUserRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub role: Option<OrgsSetMembershipUserRequestRole>,
    }

    /**
     * Allowed values that can be passed to the exclude param.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum MigrationsListOrgExclude {
        Repositories,
        Noop,
    }

    impl std::fmt::Display for MigrationsListOrgExclude {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                MigrationsListOrgExclude::Repositories => "repositories",
                MigrationsListOrgExclude::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for MigrationsListOrgExclude {
        fn default() -> MigrationsListOrgExclude {
            MigrationsListOrgExclude::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Exclude {
        Repositories,
        Noop,
    }

    impl std::fmt::Display for Exclude {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Exclude::Repositories => "repositories",
                Exclude::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Exclude {
        fn default() -> Exclude {
            Exclude::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsStartOrgRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<Exclude>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub exclude_attachments: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_repositories: Option<bool>,
        /**
         * A list of arrays indicating which repositories should be migrated.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
    }

    /**
     * Filter the list of outside collaborators. Can be one of:  
     *   \* `2fa_disabled`: Outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled.  
     *   \* `all`: All outside collaborators.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsListOutsideCollaboratorsFilter {
        TwoFaDisabled,
        All,
    }

    impl std::fmt::Display for OrgsListOutsideCollaboratorsFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsListOutsideCollaboratorsFilter::TwoFaDisabled => "2fa_disabled",
                OrgsListOutsideCollaboratorsFilter::All => "all",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsListOutsideCollaboratorsFilter {
        fn default() -> OrgsListOutsideCollaboratorsFilter {
            OrgsListOutsideCollaboratorsFilter::All
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteReposForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    /**
     * The state of the package, either active or deleted.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PackagesGetAllPackageVersionsOwnedByState {
        Active,
        Deleted,
    }

    impl std::fmt::Display for PackagesGetAllPackageVersionsOwnedByState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PackagesGetAllPackageVersionsOwnedByState::Active => "active",
                PackagesGetAllPackageVersionsOwnedByState::Deleted => "deleted",
            }
            .fmt(f)
        }
    }

    impl Default for PackagesGetAllPackageVersionsOwnedByState {
        fn default() -> PackagesGetAllPackageVersionsOwnedByState {
            PackagesGetAllPackageVersionsOwnedByState::Active
        }
    }

    /**
     * Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProjectsListOrgState {
        All,
        Closed,
        Open,
    }

    impl std::fmt::Display for ProjectsListOrgState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProjectsListOrgState::All => "all",
                ProjectsListOrgState::Closed => "closed",
                ProjectsListOrgState::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for ProjectsListOrgState {
        fn default() -> ProjectsListOrgState {
            ProjectsListOrgState::Open
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsCreateOrgRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * The name of the project.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /**
     * Specifies the types of repositories you want returned. Can be one of `all`, `public`, `private`, `forks`, `sources`, `member`, `internal`. Note: For GitHub AE, can be one of `all`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be `internal`. However, the `internal` value is not yet supported when a GitHub App calls this API with an installation access token.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListOrgType {
        All,
        Forks,
        Internal,
        Member,
        Private,
        Public,
        Sources,
        Noop,
    }

    impl std::fmt::Display for ReposListOrgType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListOrgType::All => "all",
                ReposListOrgType::Forks => "forks",
                ReposListOrgType::Internal => "internal",
                ReposListOrgType::Member => "member",
                ReposListOrgType::Private => "private",
                ReposListOrgType::Public => "public",
                ReposListOrgType::Sources => "sources",
                ReposListOrgType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListOrgType {
        fn default() -> ReposListOrgType {
            ReposListOrgType::Noop
        }
    }

    /**
     * Can be one of `created`, `updated`, `pushed`, `full_name`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListSort {
        Created,
        FullName,
        Pushed,
        Updated,
    }

    impl std::fmt::Display for ReposListSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListSort::Created => "created",
                ReposListSort::FullName => "full_name",
                ReposListSort::Pushed => "pushed",
                ReposListSort::Updated => "updated",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListSort {
        fn default() -> ReposListSort {
            ReposListSort::FullName
        }
    }

    /**
     * Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise `desc`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListOrgDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for ReposListOrgDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListOrgDirection::Asc => "asc",
                ReposListOrgDirection::Desc => "desc",
                ReposListOrgDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListOrgDirection {
        fn default() -> ReposListOrgDirection {
            ReposListOrgDirection::Noop
        }
    }

    /**
     * Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.  
     *   The `visibility` parameter overrides the `private` parameter when you use both parameters with the `nebula-preview` preview header.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposCreateInOrgRequestVisibility {
        Internal,
        Private,
        Public,
        Visibility,
        Noop,
    }

    impl std::fmt::Display for ReposCreateInOrgRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposCreateInOrgRequestVisibility::Internal => "internal",
                ReposCreateInOrgRequestVisibility::Private => "private",
                ReposCreateInOrgRequestVisibility::Public => "public",
                ReposCreateInOrgRequestVisibility::Visibility => "visibility",
                ReposCreateInOrgRequestVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposCreateInOrgRequestVisibility {
        fn default() -> ReposCreateInOrgRequestVisibility {
            ReposCreateInOrgRequestVisibility::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateInOrgRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_init: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gitignore_template: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license_template: String,
        /**
         * The name of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub team_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<ReposCreateInOrgRequestVisibility>,
    }

    /**
     * The level of privacy this team should have. The options are:  
     *   **For a non-nested team:**  
     *   \* `secret` - only visible to organization owners and members of this team.  
     *   \* `closed` - visible to all members of this organization.  
     *   Default: `secret`  
     *   **For a parent or child team:**  
     *   \* `closed` - visible to all members of this organization.  
     *   Default for child team: `closed`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsCreateRequestPrivacy {
        Closed,
        Secret,
        Noop,
    }

    impl std::fmt::Display for TeamsCreateRequestPrivacy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsCreateRequestPrivacy::Closed => "closed",
                TeamsCreateRequestPrivacy::Secret => "secret",
                TeamsCreateRequestPrivacy::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsCreateRequestPrivacy {
        fn default() -> TeamsCreateRequestPrivacy {
            TeamsCreateRequestPrivacy::Noop
        }
    }

    /**
     * **Deprecated**. The permission that new repositories will be added to the team with when none is specified. Can be one of:  
     *   \* `pull` - team members can pull, but not push to or administer newly-added repositories.  
     *   \* `push` - team members can pull and push, but not administer newly-added repositories.  
     *   \* `admin` - team members can pull, push and administer newly-added repositories.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Permission {
        Admin,
        Pull,
        Push,
    }

    impl std::fmt::Display for Permission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Permission::Admin => "admin",
                Permission::Pull => "pull",
                Permission::Push => "push",
            }
            .fmt(f)
        }
    }

    impl Default for Permission {
        fn default() -> Permission {
            Permission::Pull
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub maintainers: Vec<String>,
        /**
         * The name of the team.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<Permission>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub privacy: Option<TeamsCreateRequestPrivacy>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repo_names: Vec<String>,
    }

    /**
     * The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  
     *   **For a non-nested team:**  
     *   \* `secret` - only visible to organization owners and members of this team.  
     *   \* `closed` - visible to all members of this organization.  
     *   **For a parent or child team:**  
     *   \* `closed` - visible to all members of this organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsUpdateInOrgRequestPrivacy {
        Closed,
        Secret,
        Noop,
    }

    impl std::fmt::Display for TeamsUpdateInOrgRequestPrivacy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsUpdateInOrgRequestPrivacy::Closed => "closed",
                TeamsUpdateInOrgRequestPrivacy::Secret => "secret",
                TeamsUpdateInOrgRequestPrivacy::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsUpdateInOrgRequestPrivacy {
        fn default() -> TeamsUpdateInOrgRequestPrivacy {
            TeamsUpdateInOrgRequestPrivacy::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsUpdateInOrgRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<Permission>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub privacy: Option<TeamsUpdateInOrgRequestPrivacy>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateDiscussionInOrgRequest {
        /**
         * The discussion post's body text.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        /**
         * The discussion post's title.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsUpdateDiscussionInOrgRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateDiscussionCommentInOrgRequest {
        /**
         * The discussion comment's body text.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListTeamDiscussionCommentInOrgContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListTeamDiscussionCommentInOrgContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListTeamDiscussionCommentInOrgContent::PlusOne => "+1",
                ReactionsListTeamDiscussionCommentInOrgContent::MinusOne => "-1",
                ReactionsListTeamDiscussionCommentInOrgContent::Confused => "confused",
                ReactionsListTeamDiscussionCommentInOrgContent::Eyes => "eyes",
                ReactionsListTeamDiscussionCommentInOrgContent::Heart => "heart",
                ReactionsListTeamDiscussionCommentInOrgContent::Hooray => "hooray",
                ReactionsListTeamDiscussionCommentInOrgContent::Laugh => "laugh",
                ReactionsListTeamDiscussionCommentInOrgContent::Rocket => "rocket",
                ReactionsListTeamDiscussionCommentInOrgContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListTeamDiscussionCommentInOrgContent {
        fn default() -> ReactionsListTeamDiscussionCommentInOrgContent {
            ReactionsListTeamDiscussionCommentInOrgContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateTeamDiscussionCommentInOrgRequestContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateTeamDiscussionCommentInOrgRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::PlusOne => "+1",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::MinusOne => "-1",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Confused => "confused",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Eyes => "eyes",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Heart => "heart",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Hooray => "hooray",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Laugh => "laugh",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Rocket => "rocket",
                ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateTeamDiscussionCommentInOrgRequestContent {
        fn default() -> ReactionsCreateTeamDiscussionCommentInOrgRequestContent {
            ReactionsCreateTeamDiscussionCommentInOrgRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateTeamDiscussionCommentInOrgRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.
         */
        #[serde()]
        pub content: ReactionsCreateTeamDiscussionCommentInOrgRequestContent,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListTeamDiscussionInOrgContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListTeamDiscussionInOrgContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListTeamDiscussionInOrgContent::PlusOne => "+1",
                ReactionsListTeamDiscussionInOrgContent::MinusOne => "-1",
                ReactionsListTeamDiscussionInOrgContent::Confused => "confused",
                ReactionsListTeamDiscussionInOrgContent::Eyes => "eyes",
                ReactionsListTeamDiscussionInOrgContent::Heart => "heart",
                ReactionsListTeamDiscussionInOrgContent::Hooray => "hooray",
                ReactionsListTeamDiscussionInOrgContent::Laugh => "laugh",
                ReactionsListTeamDiscussionInOrgContent::Rocket => "rocket",
                ReactionsListTeamDiscussionInOrgContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListTeamDiscussionInOrgContent {
        fn default() -> ReactionsListTeamDiscussionInOrgContent {
            ReactionsListTeamDiscussionInOrgContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateTeamDiscussionInOrgRequestContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateTeamDiscussionInOrgRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateTeamDiscussionInOrgRequestContent::PlusOne => "+1",
                ReactionsCreateTeamDiscussionInOrgRequestContent::MinusOne => "-1",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Confused => "confused",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Eyes => "eyes",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Heart => "heart",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Hooray => "hooray",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Laugh => "laugh",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Rocket => "rocket",
                ReactionsCreateTeamDiscussionInOrgRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateTeamDiscussionInOrgRequestContent {
        fn default() -> ReactionsCreateTeamDiscussionInOrgRequestContent {
            ReactionsCreateTeamDiscussionInOrgRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateTeamDiscussionInOrgRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.
         */
        #[serde()]
        pub content: ReactionsCreateTeamDiscussionInOrgRequestContent,
    }

    /**
     * Filters members returned by their role in the team. Can be one of:  
     *   \* `member` - normal members of the team.  
     *   \* `maintainer` - team maintainers.  
     *   \* `all` - all members of the team.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsListMembersInOrgRole {
        All,
        Maintainer,
        Member,
    }

    impl std::fmt::Display for TeamsListMembersInOrgRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsListMembersInOrgRole::All => "all",
                TeamsListMembersInOrgRole::Maintainer => "maintainer",
                TeamsListMembersInOrgRole::Member => "member",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsListMembersInOrgRole {
        fn default() -> TeamsListMembersInOrgRole {
            TeamsListMembersInOrgRole::All
        }
    }

    /**
     * The role that this user should have in the team. Can be one of:  
     *   \* `member` - a normal member of the team.  
     *   \* `maintainer` - a team maintainer. Able to add/remove other team members, promote other team members to team maintainer, and edit the team's name and description.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsAddUpdateMembershipUserInOrgRequestRole {
        Maintainer,
        Member,
    }

    impl std::fmt::Display for TeamsAddUpdateMembershipUserInOrgRequestRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsAddUpdateMembershipUserInOrgRequestRole::Maintainer => "maintainer",
                TeamsAddUpdateMembershipUserInOrgRequestRole::Member => "member",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsAddUpdateMembershipUserInOrgRequestRole {
        fn default() -> TeamsAddUpdateMembershipUserInOrgRequestRole {
            TeamsAddUpdateMembershipUserInOrgRequestRole::Member
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsAddUpdateMembershipUserInOrgRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub role: Option<TeamsAddUpdateMembershipUserInOrgRequestRole>,
    }

    /**
     * The permission to grant to the team for this project. Can be one of:  
     *   \* `read` - team members can read, but not write to or administer this project.  
     *   \* `write` - team members can read and write, but not administer this project.  
     *   \* `admin` - team members can read, write and administer this project.  
     *   Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsAddUpdateProjectPermissionsInOrgRequestPermission {
        Admin,
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for TeamsAddUpdateProjectPermissionsInOrgRequestPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsAddUpdateProjectPermissionsInOrgRequestPermission::Admin => "admin",
                TeamsAddUpdateProjectPermissionsInOrgRequestPermission::Read => "read",
                TeamsAddUpdateProjectPermissionsInOrgRequestPermission::Write => "write",
                TeamsAddUpdateProjectPermissionsInOrgRequestPermission::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsAddUpdateProjectPermissionsInOrgRequestPermission {
        fn default() -> TeamsAddUpdateProjectPermissionsInOrgRequestPermission {
            TeamsAddUpdateProjectPermissionsInOrgRequestPermission::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsAddUpdateProjectPermissionsInOrgRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<TeamsAddUpdateProjectPermissionsInOrgRequestPermission>,
    }

    /**
     * The permission to grant the team on this repository. Can be one of:  
     *   \* `pull` - team members can pull, but not push to or administer this repository.  
     *   \* `push` - team members can pull and push, but not administer this repository.  
     *   \* `admin` - team members can pull, push and administer this repository.  
     *   \* `maintain` - team members can manage the repository without access to sensitive or destructive actions. Recommended for project managers. Only applies to repositories owned by organizations.  
     *   \* `triage` - team members can proactively manage issues and pull requests without write access. Recommended for contributors who triage a repository. Only applies to repositories owned by organizations.  
     *     
     *   If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsAddUpdateRepoPermissionsInOrgRequestPermission {
        Admin,
        Maintain,
        Pull,
        Push,
        Triage,
        Noop,
    }

    impl std::fmt::Display for TeamsAddUpdateRepoPermissionsInOrgRequestPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Admin => "admin",
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Maintain => "maintain",
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Pull => "pull",
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Push => "push",
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Triage => "triage",
                TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsAddUpdateRepoPermissionsInOrgRequestPermission {
        fn default() -> TeamsAddUpdateRepoPermissionsInOrgRequestPermission {
            TeamsAddUpdateRepoPermissionsInOrgRequestPermission::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsAddUpdateRepoPermissionsInOrgRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<TeamsAddUpdateRepoPermissionsInOrgRequestPermission>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateUpdateIdpGroupConnectionsInOrgRequestGroups {
        /**
         * Description of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_description: String,
        /**
         * ID of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_id: String,
        /**
         * Name of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateUpdateIdpGroupConnectionsInOrgRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<TeamsCreateUpdateIdpGroupConnectionsInOrgRequestGroups>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteProjectsForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsUpdateCardRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsMoveCardRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub column_id: Option<i64>,
        /**
         * The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub position: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostProjectsMoveCardForbiddenResponseErrors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub field: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostProjectsMoveCardForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<PostProjectsMoveCardForbiddenResponseErrors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostProjectsMoveCardServiceUnavailableResponseErrors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostProjectsMoveCardServiceUnavailableResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<PostProjectsMoveCardServiceUnavailableResponseErrors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsUpdateColumnRequest {
        /**
         * Name of the project column
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /**
     * Filters the project cards that are returned by the card's state. Can be one of `all`,`archived`, or `not_archived`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProjectsListCardsArchivedState {
        All,
        Archived,
        NotArchived,
    }

    impl std::fmt::Display for ProjectsListCardsArchivedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProjectsListCardsArchivedState::All => "all",
                ProjectsListCardsArchivedState::Archived => "archived",
                ProjectsListCardsArchivedState::NotArchived => "not_archived",
            }
            .fmt(f)
        }
    }

    impl Default for ProjectsListCardsArchivedState {
        fn default() -> ProjectsListCardsArchivedState {
            ProjectsListCardsArchivedState::NotArchived
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsCreateCardRequest {
        /**
         * The project card's note
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsMoveColumnRequest {
        /**
         * The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub position: String,
    }

    /**
     * The baseline permission that all organization members have on this project
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProjectsUpdateRequestOrganizationPermission {
        Admin,
        None,
        Read,
        Write,
        Noop,
    }

    impl std::fmt::Display for ProjectsUpdateRequestOrganizationPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProjectsUpdateRequestOrganizationPermission::Admin => "admin",
                ProjectsUpdateRequestOrganizationPermission::None => "none",
                ProjectsUpdateRequestOrganizationPermission::Read => "read",
                ProjectsUpdateRequestOrganizationPermission::Write => "write",
                ProjectsUpdateRequestOrganizationPermission::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ProjectsUpdateRequestOrganizationPermission {
        fn default() -> ProjectsUpdateRequestOrganizationPermission {
            ProjectsUpdateRequestOrganizationPermission::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsUpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_permission: Option<ProjectsUpdateRequestOrganizationPermission>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    /**
     * Filters the collaborators by their affiliation. Can be one of:  
     *   \* `outside`: Outside collaborators of a project that are not a member of the project's organization.  
     *   \* `direct`: Collaborators with permissions to a project, regardless of organization membership status.  
     *   \* `all`: All collaborators the authenticated user can see.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProjectsListCollaboratorsAffiliation {
        All,
        Direct,
        Outside,
    }

    impl std::fmt::Display for ProjectsListCollaboratorsAffiliation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProjectsListCollaboratorsAffiliation::All => "all",
                ProjectsListCollaboratorsAffiliation::Direct => "direct",
                ProjectsListCollaboratorsAffiliation::Outside => "outside",
            }
            .fmt(f)
        }
    }

    impl Default for ProjectsListCollaboratorsAffiliation {
        fn default() -> ProjectsListCollaboratorsAffiliation {
            ProjectsListCollaboratorsAffiliation::All
        }
    }

    /**
     * The permission to grant the collaborator.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ProjectsAddCollaboratorRequestPermission {
        Admin,
        Read,
        Write,
    }

    impl std::fmt::Display for ProjectsAddCollaboratorRequestPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ProjectsAddCollaboratorRequestPermission::Admin => "admin",
                ProjectsAddCollaboratorRequestPermission::Read => "read",
                ProjectsAddCollaboratorRequestPermission::Write => "write",
            }
            .fmt(f)
        }
    }

    impl Default for ProjectsAddCollaboratorRequestPermission {
        fn default() -> ProjectsAddCollaboratorRequestPermission {
            ProjectsAddCollaboratorRequestPermission::Write
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsAddCollaboratorRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<ProjectsAddCollaboratorRequestPermission>,
    }

    /**
     * Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides the `private` parameter when you use both along with the `nebula-preview` preview header.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposUpdateRequestVisibility {
        Internal,
        Private,
        Public,
        Visibility,
        Noop,
    }

    impl std::fmt::Display for ReposUpdateRequestVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposUpdateRequestVisibility::Internal => "internal",
                ReposUpdateRequestVisibility::Private => "private",
                ReposUpdateRequestVisibility::Public => "public",
                ReposUpdateRequestVisibility::Visibility => "visibility",
                ReposUpdateRequestVisibility::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposUpdateRequestVisibility {
        fn default() -> ReposUpdateRequestVisibility {
            ReposUpdateRequestVisibility::Noop
        }
    }

    /// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateRequestSecurityAnalysisAdvanced {
        /**
         * Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    /// Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateRequestSecurityAnalysisSecretScanning {
        /**
         * Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    /// Specify which security and analysis features to enable or disable. For example, to enable GitHub Advanced Security, use this data in the body of the PATCH request: `{"security_and_analysis": {"advanced_security": {"status": "enabled"}}}`. If you have admin permissions for a private repository covered by an Advanced Security license, you can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateRequestSecurityAnalysis {
        /**
         * Specify which security and analysis features to enable or disable. For example, to enable GitHub Advanced Security, use this data in the body of the PATCH request: `{"security_and_analysis": {"advanced_security": {"status": "enabled"}}}`. If you have admin permissions for a private repository covered by an Advanced Security license, you can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub advanced_security: Option<ReposUpdateRequestSecurityAnalysisAdvanced>,
        /**
         * Specify which security and analysis features to enable or disable. For example, to enable GitHub Advanced Security, use this data in the body of the PATCH request: `{"security_and_analysis": {"advanced_security": {"status": "enabled"}}}`. If you have admin permissions for a private repository covered by an Advanced Security license, you can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub secret_scanning: Option<ReposUpdateRequestSecurityAnalysisSecretScanning>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_and_analysis: Option<ReposUpdateRequestSecurityAnalysis>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub visibility: Option<ReposUpdateRequestVisibility>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListArtifactsRepoOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub artifacts: Vec<Artifact>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSetGithubPermissionsRepositoryRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed_actions: Option<AllowedActions>,
        /**
         * Whether GitHub Actions is enabled on the repository.
         */
        #[serde(default)]
        pub enabled: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListWorkflowRunsOkResponse {
        #[serde(default)]
        pub total_count: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub workflow_runs: Vec<WorkflowRun>,
    }

    /**
     * Filters jobs by their `completed_at` timestamp. Can be one of:  
     *   \* `latest`: Returns jobs from the most recent execution of the workflow run.  
     *   \* `all`: Returns all jobs for a workflow run, including from old executions of the workflow run.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ActionsListJobsWorkflowRunFilter {
        All,
        Latest,
    }

    impl std::fmt::Display for ActionsListJobsWorkflowRunFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ActionsListJobsWorkflowRunFilter::All => "all",
                ActionsListJobsWorkflowRunFilter::Latest => "latest",
            }
            .fmt(f)
        }
    }

    impl Default for ActionsListJobsWorkflowRunFilter {
        fn default() -> ActionsListJobsWorkflowRunFilter {
            ActionsListJobsWorkflowRunFilter::Latest
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListJobsWorkflowRunOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub jobs: Vec<Job>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Whether to approve or reject deployment to the specified environments. Must be one of: `approved` or `rejected`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ActionsReviewPendingDeploymentsRunRequestState {
        Approved,
        Rejected,
        Noop,
    }

    impl std::fmt::Display for ActionsReviewPendingDeploymentsRunRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ActionsReviewPendingDeploymentsRunRequestState::Approved => "approved",
                ActionsReviewPendingDeploymentsRunRequestState::Rejected => "rejected",
                ActionsReviewPendingDeploymentsRunRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ActionsReviewPendingDeploymentsRunRequestState {
        fn default() -> ActionsReviewPendingDeploymentsRunRequestState {
            ActionsReviewPendingDeploymentsRunRequestState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsReviewPendingDeploymentsRunRequest {
        /**
         * A comment to accompany the deployment review
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comment: String,
        /**
         * The list of environment ids to approve or reject
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environment_ids: Vec<i64>,
        /**
         * Whether to approve or reject deployment to the specified environments. Must be one of: `approved` or `rejected`
         */
        #[serde()]
        pub state: ActionsReviewPendingDeploymentsRunRequestState,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListRepoSecretsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub secrets: Vec<ActionsSecret>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsCreateUpdateRepoSecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetActionsListRepoWorkflowsOkResponse {
        #[serde(default)]
        pub total_count: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub workflows: Vec<Workflow>,
    }

    /// Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Inputs {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsCreateWorkflowDispatchRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Inputs>,
        /**
         * The git reference for the workflow. The reference can be a branch or tag name.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
    }

    /// Require status checks to pass before merging. Set to `null` to disable.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateBranchProtectionRequestRequiredStatusChecks {
        /**
         * The list of status checks to require in order to merge into this branch
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        /**
         * Require branches to be up to date before merging.
         */
        #[serde(default)]
        pub strict: bool,
    }

    /// Specify which users and teams can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateBranchProtectionRequestRequiredPullReviewsDismissalRestrictions {
        /**
         * Specify which users and teams can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
        /**
         * Specify which users and teams can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    /// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateBranchProtectionRequestRequiredPullReviews {
        /**
         * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        /**
         * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<ReposUpdateBranchProtectionRequestRequiredPullReviewsDismissalRestrictions>,
        /**
         * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        /**
         * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    /// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Restrictions {
        /**
         * Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
        /**
         * The list of team `slug`s with push access
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
        /**
         * The list of user `login`s with push access
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateBranchProtectionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<bool>,
        /**
         * Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
         */
        #[serde(default)]
        pub enforce_admins: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<bool>,
        /**
         * Require at least one approving review on a pull request, before merging. Set to `null` to disable.
         */
        #[serde()]
        pub required_pull_request_reviews: ReposUpdateBranchProtectionRequestRequiredPullReviews,
        /**
         * Require status checks to pass before merging. Set to `null` to disable.
         */
        #[serde()]
        pub required_status_checks: ReposUpdateBranchProtectionRequestRequiredStatusChecks,
        /**
         * Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
         */
        #[serde()]
        pub restrictions: Restrictions,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdatePullRequestReviewProtection {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<ReposUpdateBranchProtectionRequestRequiredPullReviewsDismissalRestrictions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateStatusCheckProtectionRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strict: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposAddStatusCheckContextsRequest {
        /**
         * contexts parameter
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposAddAppAccessRestrictionsRequest {
        /**
         * apps parameter
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposAddTeamAccessRestrictionsRequest {
        /**
         * teams parameter
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposAddUserAccessRestrictionsRequest {
        /**
         * users parameter
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposRenameBranchRequest {
        /**
         * The new name of the branch.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_name: String,
    }

    /**
     * The current status. Can be one of `queued`, `in_progress`, or `completed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ChecksCreateRequestStatus {
        Completed,
        InProgress,
        Queued,
    }

    impl std::fmt::Display for ChecksCreateRequestStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ChecksCreateRequestStatus::Completed => "completed",
                ChecksCreateRequestStatus::InProgress => "in_progress",
                ChecksCreateRequestStatus::Queued => "queued",
            }
            .fmt(f)
        }
    }

    impl Default for ChecksCreateRequestStatus {
        fn default() -> ChecksCreateRequestStatus {
            ChecksCreateRequestStatus::Queued
        }
    }

    /**
     * **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. Can be one of `action_required`, `cancelled`, `failure`, `neutral`, `success`, `skipped`, `stale`, or `timed_out`. When the conclusion is `action_required`, additional details should be provided on the site specified by `details_url`.  
     *   **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ChecksCreateRequestConclusion {
        ActionRequired,
        Cancelled,
        Failure,
        Neutral,
        Skipped,
        Stale,
        Success,
        TimedOut,
        Noop,
    }

    impl std::fmt::Display for ChecksCreateRequestConclusion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ChecksCreateRequestConclusion::ActionRequired => "action_required",
                ChecksCreateRequestConclusion::Cancelled => "cancelled",
                ChecksCreateRequestConclusion::Failure => "failure",
                ChecksCreateRequestConclusion::Neutral => "neutral",
                ChecksCreateRequestConclusion::Skipped => "skipped",
                ChecksCreateRequestConclusion::Stale => "stale",
                ChecksCreateRequestConclusion::Success => "success",
                ChecksCreateRequestConclusion::TimedOut => "timed_out",
                ChecksCreateRequestConclusion::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ChecksCreateRequestConclusion {
        fn default() -> ChecksCreateRequestConclusion {
            ChecksCreateRequestConclusion::Noop
        }
    }

    /**
     * The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum AnnotationLevel {
        Failure,
        Notice,
        Warning,
        Noop,
    }

    impl std::fmt::Display for AnnotationLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                AnnotationLevel::Failure => "failure",
                AnnotationLevel::Notice => "notice",
                AnnotationLevel::Warning => "warning",
                AnnotationLevel::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for AnnotationLevel {
        fn default() -> AnnotationLevel {
            AnnotationLevel::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Annotations {
        /**
         * The level of the annotation. Can be one of `notice`, `warning`, or `failure`.
         */
        #[serde()]
        pub annotation_level: AnnotationLevel,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_column: Option<i64>,
        /**
         * The end line of the annotation.
         */
        #[serde(default)]
        pub end_line: i64,
        /**
         * A short description of the feedback for these lines of code. The maximum size is 64 KB.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * The path of the file to add an annotation to. For example, `assets/css/main.css`.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_details: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_column: Option<i64>,
        /**
         * The start line of the annotation.
         */
        #[serde(default)]
        pub start_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Images {
        /**
         * The alternative text for the image.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub alt: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caption: String,
        /**
         * The full URL of the image.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub image_url: String,
    }

    /// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object) description.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksCreateRequestOutput {
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object) description.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub annotations: Vec<Annotations>,
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object) description.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub images: Vec<Images>,
        /**
         * The summary of the check run. This parameter supports Markdown.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object) description.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        /**
         * The title of the check run.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksCreateRequestActions {
        /**
         * A short explanation of what this action would do. The maximum size is 40 characters.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * A reference for the action on the integrator's system. The maximum size is 20 characters.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub identifier: String,
        /**
         * The text to be displayed on a button in the web UI. The maximum size is 20 characters.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksCreateRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<ChecksCreateRequestActions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conclusion: Option<ChecksCreateRequestConclusion>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        /**
         * The SHA of the commit.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        /**
         * The name of the check. For example, "code-coverage".
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub output: Option<ChecksCreateRequestOutput>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ChecksCreateRequestStatus>,
    }

    /**
     * **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. Can be one of `action_required`, `cancelled`, `failure`, `neutral`, `success`, `skipped`, `stale`, or `timed_out`.  
     *   **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ChecksUpdateRequestConclusion {
        ActionRequired,
        Cancelled,
        Failure,
        Neutral,
        Skipped,
        Stale,
        Success,
        TimedOut,
        Noop,
    }

    impl std::fmt::Display for ChecksUpdateRequestConclusion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ChecksUpdateRequestConclusion::ActionRequired => "action_required",
                ChecksUpdateRequestConclusion::Cancelled => "cancelled",
                ChecksUpdateRequestConclusion::Failure => "failure",
                ChecksUpdateRequestConclusion::Neutral => "neutral",
                ChecksUpdateRequestConclusion::Skipped => "skipped",
                ChecksUpdateRequestConclusion::Stale => "stale",
                ChecksUpdateRequestConclusion::Success => "success",
                ChecksUpdateRequestConclusion::TimedOut => "timed_out",
                ChecksUpdateRequestConclusion::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ChecksUpdateRequestConclusion {
        fn default() -> ChecksUpdateRequestConclusion {
            ChecksUpdateRequestConclusion::Noop
        }
    }

    /// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object-1) description.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksUpdateRequestOutput {
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object-1) description.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub annotations: Vec<Annotations>,
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object-1) description.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub images: Vec<Images>,
        /**
         * Can contain Markdown.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object-1) description.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        /**
         * Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. See the [`output` object](https://docs.github.com/rest/reference/checks#output-object-1) description.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksUpdateRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<ChecksCreateRequestActions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conclusion: Option<ChecksUpdateRequestConclusion>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub output: Option<ChecksUpdateRequestOutput>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ChecksCreateRequestStatus>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksCreateSuiteRequest {
        /**
         * The sha of the head commit.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksSetSuitesPreferencesRequestAutoTrigger {
        /**
         * The `id` of the GitHub App.
         */
        #[serde(default)]
        pub app_id: i64,
        /**
         * Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.
         */
        #[serde(default)]
        pub setting: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChecksSetSuitesPreferencesRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub auto_trigger_checks: Vec<ChecksSetSuitesPreferencesRequestAutoTrigger>,
    }

    /**
     * Filters check runs by their `completed_at` timestamp. Can be one of `latest` (returning the most recent check runs) or `all`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ChecksListRefFilter {
        All,
        Latest,
    }

    impl std::fmt::Display for ChecksListRefFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ChecksListRefFilter::All => "all",
                ChecksListRefFilter::Latest => "latest",
            }
            .fmt(f)
        }
    }

    impl Default for ChecksListRefFilter {
        fn default() -> ChecksListRefFilter {
            ChecksListRefFilter::Latest
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetChecksListRefOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub check_runs: Vec<CheckRun>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningUpdateAlertRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissed_reason: Option<serde_json::Value>,
        /**
         * Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`.
         */
        #[serde()]
        pub state: CodeScanningAlertSetState,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningUploadSarifRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub checkout_uri: String,
        /**
         * The SHA of the commit to which the analysis you are uploading relates.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        /**
         * The full Git reference, formatted as `refs/heads/<branch name>`,
         *  `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        /**
         * A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sarif: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tool_name: String,
    }

    /**
     * Filter collaborators returned by their affiliation. Can be one of:  
     *   \* `outside`: All outside collaborators of an organization-owned repository.  
     *   \* `direct`: All collaborators with permissions to an organization-owned repository, regardless of organization membership status.  
     *   \* `all`: All collaborators the authenticated user can see.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListCollaboratorsAffiliation {
        All,
        Direct,
        Outside,
    }

    impl std::fmt::Display for ReposListCollaboratorsAffiliation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListCollaboratorsAffiliation::All => "all",
                ReposListCollaboratorsAffiliation::Direct => "direct",
                ReposListCollaboratorsAffiliation::Outside => "outside",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListCollaboratorsAffiliation {
        fn default() -> ReposListCollaboratorsAffiliation {
            ReposListCollaboratorsAffiliation::All
        }
    }

    /**
     * The permission to grant the collaborator. **Only valid on organization-owned repositories.** Can be one of:  
     *   \* `pull` - can pull, but not push to or administer this repository.  
     *   \* `push` - can pull and push, but not administer this repository.  
     *   \* `admin` - can pull, push and administer this repository.  
     *   \* `maintain` - Recommended for project managers who need to manage the repository without access to sensitive or destructive actions.  
     *   \* `triage` - Recommended for contributors who need to proactively manage issues and pull requests without write access.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposAddCollaboratorRequestPermission {
        Admin,
        Maintain,
        Pull,
        Push,
        Triage,
    }

    impl std::fmt::Display for ReposAddCollaboratorRequestPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposAddCollaboratorRequestPermission::Admin => "admin",
                ReposAddCollaboratorRequestPermission::Maintain => "maintain",
                ReposAddCollaboratorRequestPermission::Pull => "pull",
                ReposAddCollaboratorRequestPermission::Push => "push",
                ReposAddCollaboratorRequestPermission::Triage => "triage",
            }
            .fmt(f)
        }
    }

    impl Default for ReposAddCollaboratorRequestPermission {
        fn default() -> ReposAddCollaboratorRequestPermission {
            ReposAddCollaboratorRequestPermission::Push
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposAddCollaboratorRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<ReposAddCollaboratorRequestPermission>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permissions: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateCommitCommentRequest {
        /**
         * The contents of the comment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListCommitCommentContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListCommitCommentContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListCommitCommentContent::PlusOne => "+1",
                ReactionsListCommitCommentContent::MinusOne => "-1",
                ReactionsListCommitCommentContent::Confused => "confused",
                ReactionsListCommitCommentContent::Eyes => "eyes",
                ReactionsListCommitCommentContent::Heart => "heart",
                ReactionsListCommitCommentContent::Hooray => "hooray",
                ReactionsListCommitCommentContent::Laugh => "laugh",
                ReactionsListCommitCommentContent::Rocket => "rocket",
                ReactionsListCommitCommentContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListCommitCommentContent {
        fn default() -> ReactionsListCommitCommentContent {
            ReactionsListCommitCommentContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the commit comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateCommitCommentRequestContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateCommitCommentRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateCommitCommentRequestContent::PlusOne => "+1",
                ReactionsCreateCommitCommentRequestContent::MinusOne => "-1",
                ReactionsCreateCommitCommentRequestContent::Confused => "confused",
                ReactionsCreateCommitCommentRequestContent::Eyes => "eyes",
                ReactionsCreateCommitCommentRequestContent::Heart => "heart",
                ReactionsCreateCommitCommentRequestContent::Hooray => "hooray",
                ReactionsCreateCommitCommentRequestContent::Laugh => "laugh",
                ReactionsCreateCommitCommentRequestContent::Rocket => "rocket",
                ReactionsCreateCommitCommentRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateCommitCommentRequestContent {
        fn default() -> ReactionsCreateCommitCommentRequestContent {
            ReactionsCreateCommitCommentRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateCommitCommentRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the commit comment.
         */
        #[serde()]
        pub content: ReactionsCreateCommitCommentRequestContent,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateCommitCommentRequest {
        /**
         * The contents of the comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetChecksListSuitesRefOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub check_suites: Vec<CheckSuite>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppsCreateContentAttachmentRequest {
        /**
         * The body of the attachment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * The title of the attachment
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /// The person that committed the file. Default: the authenticated user.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUpdateFileContentsRequestCommitter {
        /**
         * The person that committed the file. Default: the authenticated user.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        /**
         * The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUpdateFileContentsRequestAuthor {
        /**
         * The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        /**
         * The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUpdateFileContentsRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<ReposCreateUpdateFileContentsRequestAuthor>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<ReposCreateUpdateFileContentsRequestCommitter>,
        /**
         * The new file content, using Base64 encoding.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        /**
         * The commit message.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    /// object containing information about the committer.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposDeleteFileRequestCommitter {
        /**
         * object containing information about the committer.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * object containing information about the committer.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// object containing information about the author.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposDeleteFileRequestAuthor {
        /**
         * object containing information about the author.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * object containing information about the author.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposDeleteFileRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<ReposDeleteFileRequestAuthor>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<ReposDeleteFileRequestCommitter>,
        /**
         * The commit message.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * The blob SHA of the file being replaced.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateDeploymentRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub payload: Option<Data>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        /**
         * The ref to deploy. This can be a branch, tag, or SHA.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub required_contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
    }

    /**
     * The state of the status. Can be one of `error`, `failure`, `inactive`, `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive` state, you must provide the [`application/vnd.github.ant-man-preview+json`](https://docs.github.com/rest/overview/api-previews#enhanced-deployments) custom media type. To use the `in_progress` and `queued` states, you must provide the [`application/vnd.github.flash-preview+json`](https://docs.github.com/rest/overview/api-previews#deployment-statuses) custom media type. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposCreateDeploymentStatusRequestState {
        Error,
        Failure,
        InProgress,
        Inactive,
        Pending,
        Queued,
        Success,
        Noop,
    }

    impl std::fmt::Display for ReposCreateDeploymentStatusRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposCreateDeploymentStatusRequestState::Error => "error",
                ReposCreateDeploymentStatusRequestState::Failure => "failure",
                ReposCreateDeploymentStatusRequestState::InProgress => "in_progress",
                ReposCreateDeploymentStatusRequestState::Inactive => "inactive",
                ReposCreateDeploymentStatusRequestState::Pending => "pending",
                ReposCreateDeploymentStatusRequestState::Queued => "queued",
                ReposCreateDeploymentStatusRequestState::Success => "success",
                ReposCreateDeploymentStatusRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposCreateDeploymentStatusRequestState {
        fn default() -> ReposCreateDeploymentStatusRequestState {
            ReposCreateDeploymentStatusRequestState::Noop
        }
    }

    /**
     * Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. **Note:** This parameter requires you to use the [`application/vnd.github.flash-preview+json`](https://docs.github.com/rest/overview/api-previews#deployment-statuses) custom media type.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposCreateDeploymentStatusRequestEnvironment {
        Production,
        Qa,
        Staging,
        Noop,
    }

    impl std::fmt::Display for ReposCreateDeploymentStatusRequestEnvironment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposCreateDeploymentStatusRequestEnvironment::Production => "production",
                ReposCreateDeploymentStatusRequestEnvironment::Qa => "qa",
                ReposCreateDeploymentStatusRequestEnvironment::Staging => "staging",
                ReposCreateDeploymentStatusRequestEnvironment::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposCreateDeploymentStatusRequestEnvironment {
        fn default() -> ReposCreateDeploymentStatusRequestEnvironment {
            ReposCreateDeploymentStatusRequestEnvironment::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateDeploymentStatusRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_inactive: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub environment: Option<ReposCreateDeploymentStatusRequestEnvironment>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub log_url: String,
        /**
         * The state of the status. Can be one of `error`, `failure`, `inactive`, `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive` state, you must provide the [`application/vnd.github.ant-man-preview+json`](https://docs.github.com/rest/overview/api-previews#enhanced-deployments) custom media type. To use the `in_progress` and `queued` states, you must provide the [`application/vnd.github.flash-preview+json`](https://docs.github.com/rest/overview/api-previews#deployment-statuses) custom media type. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
         */
        #[serde()]
        pub state: ReposCreateDeploymentStatusRequestState,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
    }

    /// JSON payload with extra information about the webhook event that your action or worklow may use.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ClientPayload {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateDispatchEventRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub client_payload: Option<ClientPayload>,
        /**
         * A custom webhook event name.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetReposAllEnvironmentsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environments: Vec<Environment>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUpdateEnvironmentRequestReviewers {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
        pub type_: Option<DeploymentReviewerType>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUpdateEnvironmentRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment_branch_policy: Option<DeploymentBranchPolicy>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<ReposCreateUpdateEnvironmentRequestReviewers>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub wait_timer: Option<i64>,
    }

    /**
     * The sort order. Can be either `newest`, `oldest`, or `stargazers`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListForksSort {
        Newest,
        Oldest,
        Stargazers,
        Watchers,
    }

    impl std::fmt::Display for ReposListForksSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListForksSort::Newest => "newest",
                ReposListForksSort::Oldest => "oldest",
                ReposListForksSort::Stargazers => "stargazers",
                ReposListForksSort::Watchers => "watchers",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListForksSort {
        fn default() -> ReposListForksSort {
            ReposListForksSort::Newest
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateForkRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateBlobRequest {
        /**
         * The new blob's content.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
    }

    /// Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateCommitRequestAuthor {
        /**
         * Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        /**
         * The email of the author (or committer) of the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * The name of the author (or committer) of the commit
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateCommitRequestCommitter {
        /**
         * Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        /**
         * Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateCommitRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<GitCreateCommitRequestAuthor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<GitCreateCommitRequestCommitter>,
        /**
         * The commit message
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        /**
         * The SHA of the tree object this commit points to
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tree: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateRefRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        /**
         * The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        /**
         * The SHA1 value for this reference.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitUpdateRefRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub force: Option<bool>,
        /**
         * The SHA1 value to set this reference to
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    /**
     * The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum GitCreateTagRequestType {
        Blob,
        Commit,
        Tree,
        Noop,
    }

    impl std::fmt::Display for GitCreateTagRequestType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                GitCreateTagRequestType::Blob => "blob",
                GitCreateTagRequestType::Commit => "commit",
                GitCreateTagRequestType::Tree => "tree",
                GitCreateTagRequestType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for GitCreateTagRequestType {
        fn default() -> GitCreateTagRequestType {
            GitCreateTagRequestType::Noop
        }
    }

    /// An object with information about the individual creating the tag.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateTagRequestTagger {
        /**
         * An object with information about the individual creating the tag.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        /**
         * The email of the author of the tag
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        /**
         * The name of the author of the tag
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateTagRequest {
        /**
         * The tag message.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        /**
         * The SHA of the git object this is tagging.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object: String,
        /**
         * The tag's name. This is typically a version (e.g., "v0.0.1").
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tagger: Option<GitCreateTagRequestTagger>,
        /**
         * The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
         */
        #[serde(rename = "type")]
        pub type_: GitCreateTagRequestType,
    }

    /**
     * The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum GitCreateTreeRequestMode {
        SubdirectoryTree,
        FileBlob,
        ExecutableBlob,
        SymlinkPathBlob,
        SubmoduleCommit,
        Noop,
    }

    impl std::fmt::Display for GitCreateTreeRequestMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                GitCreateTreeRequestMode::SubdirectoryTree => "040000",
                GitCreateTreeRequestMode::FileBlob => "100644",
                GitCreateTreeRequestMode::ExecutableBlob => "100755",
                GitCreateTreeRequestMode::SymlinkPathBlob => "120000",
                GitCreateTreeRequestMode::SubmoduleCommit => "160000",
                GitCreateTreeRequestMode::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for GitCreateTreeRequestMode {
        fn default() -> GitCreateTreeRequestMode {
            GitCreateTreeRequestMode::Noop
        }
    }

    /**
     * Either `blob`, `tree`, or `commit`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum GitCreateTreeRequestType {
        Blob,
        Commit,
        Tree,
        Noop,
    }

    impl std::fmt::Display for GitCreateTreeRequestType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                GitCreateTreeRequestType::Blob => "blob",
                GitCreateTreeRequestType::Commit => "commit",
                GitCreateTreeRequestType::Tree => "tree",
                GitCreateTreeRequestType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for GitCreateTreeRequestType {
        fn default() -> GitCreateTreeRequestType {
            GitCreateTreeRequestType::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateTreeRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mode: Option<GitCreateTreeRequestMode>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
        pub type_: Option<GitCreateTreeRequestType>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCreateTreeRequestData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base_tree: String,
        /**
         * Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tree: Vec<GitCreateTreeRequest>,
    }

    /// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateWebhookRequestConfig {
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub digest: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<ReposCreateWebhookRequestConfig>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateWebhookRequestConfig {
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub address: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub room: String,
        /**
         * Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        /**
         * The URL to which the payloads will be delivered.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub add_events: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<ReposUpdateWebhookRequestConfig>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub remove_events: Vec<String>,
    }

    /**
     * The originating VCS type. Can be one of `subversion`, `git`, `mercurial`, or `tfvc`. Please be aware that without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Vcs {
        Git,
        Mercurial,
        Subversion,
        Tfvc,
        Noop,
    }

    impl std::fmt::Display for Vcs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Vcs::Git => "git",
                Vcs::Mercurial => "mercurial",
                Vcs::Subversion => "subversion",
                Vcs::Tfvc => "tfvc",
                Vcs::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for Vcs {
        fn default() -> Vcs {
            Vcs::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsStartImportRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vcs: Option<Vcs>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_password: String,
        /**
         * The URL of the originating repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsUpdateImportRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsMapCommitAuthorRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /**
     * Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out` (large files will be removed during the import).
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum UseLfs {
        OptIn,
        OptOut,
        Noop,
    }

    impl std::fmt::Display for UseLfs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                UseLfs::OptIn => "opt_in",
                UseLfs::OptOut => "opt_out",
                UseLfs::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for UseLfs {
        fn default() -> UseLfs {
            UseLfs::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsSetLfsPreferenceRequest {
        /**
         * Can be one of `opt_in` (large files will be stored using Git LFS) or `opt_out` (large files will be removed during the import).
         */
        #[serde()]
        pub use_lfs: UseLfs,
    }

    /**
     * The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposUpdateInvitationRequestPermissions {
        Admin,
        Maintain,
        Read,
        Triage,
        Write,
        Noop,
    }

    impl std::fmt::Display for ReposUpdateInvitationRequestPermissions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposUpdateInvitationRequestPermissions::Admin => "admin",
                ReposUpdateInvitationRequestPermissions::Maintain => "maintain",
                ReposUpdateInvitationRequestPermissions::Read => "read",
                ReposUpdateInvitationRequestPermissions::Triage => "triage",
                ReposUpdateInvitationRequestPermissions::Write => "write",
                ReposUpdateInvitationRequestPermissions::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposUpdateInvitationRequestPermissions {
        fn default() -> ReposUpdateInvitationRequestPermissions {
            ReposUpdateInvitationRequestPermissions::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateInvitationRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<ReposUpdateInvitationRequestPermissions>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesCreateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignee: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestone: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /**
     * Either `asc` or `desc`. Ignored without the `sort` parameter.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListCommentsRepoDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for IssuesListCommentsRepoDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListCommentsRepoDirection::Asc => "asc",
                IssuesListCommentsRepoDirection::Desc => "desc",
                IssuesListCommentsRepoDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListCommentsRepoDirection {
        fn default() -> IssuesListCommentsRepoDirection {
            IssuesListCommentsRepoDirection::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesUpdateCommentRequest {
        /**
         * The contents of the comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListIssueCommentContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListIssueCommentContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListIssueCommentContent::PlusOne => "+1",
                ReactionsListIssueCommentContent::MinusOne => "-1",
                ReactionsListIssueCommentContent::Confused => "confused",
                ReactionsListIssueCommentContent::Eyes => "eyes",
                ReactionsListIssueCommentContent::Heart => "heart",
                ReactionsListIssueCommentContent::Hooray => "hooray",
                ReactionsListIssueCommentContent::Laugh => "laugh",
                ReactionsListIssueCommentContent::Rocket => "rocket",
                ReactionsListIssueCommentContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListIssueCommentContent {
        fn default() -> ReactionsListIssueCommentContent {
            ReactionsListIssueCommentContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateIssueCommentRequestContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateIssueCommentRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateIssueCommentRequestContent::PlusOne => "+1",
                ReactionsCreateIssueCommentRequestContent::MinusOne => "-1",
                ReactionsCreateIssueCommentRequestContent::Confused => "confused",
                ReactionsCreateIssueCommentRequestContent::Eyes => "eyes",
                ReactionsCreateIssueCommentRequestContent::Heart => "heart",
                ReactionsCreateIssueCommentRequestContent::Hooray => "hooray",
                ReactionsCreateIssueCommentRequestContent::Laugh => "laugh",
                ReactionsCreateIssueCommentRequestContent::Rocket => "rocket",
                ReactionsCreateIssueCommentRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateIssueCommentRequestContent {
        fn default() -> ReactionsCreateIssueCommentRequestContent {
            ReactionsCreateIssueCommentRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateIssueCommentRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue comment.
         */
        #[serde()]
        pub content: ReactionsCreateIssueCommentRequestContent,
    }

    /**
     * State of the issue. Either `open` or `closed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesUpdateRequestState {
        Closed,
        Open,
        Noop,
    }

    impl std::fmt::Display for IssuesUpdateRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesUpdateRequestState::Closed => "closed",
                IssuesUpdateRequestState::Open => "open",
                IssuesUpdateRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesUpdateRequestState {
        fn default() -> IssuesUpdateRequestState {
            IssuesUpdateRequestState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesUpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignee: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestone: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<IssuesUpdateRequestState>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesAddAssigneesRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesRemoveAssigneesRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesAddLabelsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
    }

    /**
     * The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  
     *   \* `off-topic`  
     *   \* `too heated`  
     *   \* `resolved`  
     *   \* `spam`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum LockReason {
        OffTopic,
        Resolved,
        Spam,
        TooHeated,
        Noop,
    }

    impl std::fmt::Display for LockReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                LockReason::OffTopic => "off-topic",
                LockReason::Resolved => "resolved",
                LockReason::Spam => "spam",
                LockReason::TooHeated => "too heated",
                LockReason::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for LockReason {
        fn default() -> LockReason {
            LockReason::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesLockRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_reason: Option<LockReason>,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListIssueContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListIssueContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListIssueContent::PlusOne => "+1",
                ReactionsListIssueContent::MinusOne => "-1",
                ReactionsListIssueContent::Confused => "confused",
                ReactionsListIssueContent::Eyes => "eyes",
                ReactionsListIssueContent::Heart => "heart",
                ReactionsListIssueContent::Hooray => "hooray",
                ReactionsListIssueContent::Laugh => "laugh",
                ReactionsListIssueContent::Rocket => "rocket",
                ReactionsListIssueContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListIssueContent {
        fn default() -> ReactionsListIssueContent {
            ReactionsListIssueContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateIssueRequestContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateIssueRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateIssueRequestContent::PlusOne => "+1",
                ReactionsCreateIssueRequestContent::MinusOne => "-1",
                ReactionsCreateIssueRequestContent::Confused => "confused",
                ReactionsCreateIssueRequestContent::Eyes => "eyes",
                ReactionsCreateIssueRequestContent::Heart => "heart",
                ReactionsCreateIssueRequestContent::Hooray => "hooray",
                ReactionsCreateIssueRequestContent::Laugh => "laugh",
                ReactionsCreateIssueRequestContent::Rocket => "rocket",
                ReactionsCreateIssueRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateIssueRequestContent {
        fn default() -> ReactionsCreateIssueRequestContent {
            ReactionsCreateIssueRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateIssueRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue.
         */
        #[serde()]
        pub content: ReactionsCreateIssueRequestContent,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateDeployKeyRequest {
        /**
         * The contents of the key.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read_only: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesCreateLabelRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesUpdateLabelRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposMergeRequest {
        /**
         * The name of the base branch that the head will be merged into.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        /**
         * The head to merge. This can be a branch name or a commit SHA1.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head: String,
    }

    /**
     * The state of the milestone. Either `open`, `closed`, or `all`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListMilestonesState {
        All,
        Closed,
        Open,
    }

    impl std::fmt::Display for IssuesListMilestonesState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListMilestonesState::All => "all",
                IssuesListMilestonesState::Closed => "closed",
                IssuesListMilestonesState::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListMilestonesState {
        fn default() -> IssuesListMilestonesState {
            IssuesListMilestonesState::Open
        }
    }

    /**
     * What to sort results by. Either `due_on` or `completeness`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListMilestonesSort {
        Completeness,
        DueOn,
    }

    impl std::fmt::Display for IssuesListMilestonesSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListMilestonesSort::Completeness => "completeness",
                IssuesListMilestonesSort::DueOn => "due_on",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListMilestonesSort {
        fn default() -> IssuesListMilestonesSort {
            IssuesListMilestonesSort::DueOn
        }
    }

    /**
     * The direction of the sort. Either `asc` or `desc`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesListMilestonesDirection {
        Asc,
        Desc,
    }

    impl std::fmt::Display for IssuesListMilestonesDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesListMilestonesDirection::Asc => "asc",
                IssuesListMilestonesDirection::Desc => "desc",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesListMilestonesDirection {
        fn default() -> IssuesListMilestonesDirection {
            IssuesListMilestonesDirection::Asc
        }
    }

    /**
     * The state of the milestone. Either `open` or `closed`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum IssuesCreateMilestoneRequestState {
        Closed,
        Open,
    }

    impl std::fmt::Display for IssuesCreateMilestoneRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                IssuesCreateMilestoneRequestState::Closed => "closed",
                IssuesCreateMilestoneRequestState::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for IssuesCreateMilestoneRequestState {
        fn default() -> IssuesCreateMilestoneRequestState {
            IssuesCreateMilestoneRequestState::Open
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesCreateMilestoneRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub due_on: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<IssuesCreateMilestoneRequestState>,
        /**
         * The title of the milestone.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssuesUpdateMilestoneRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub due_on: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<IssuesCreateMilestoneRequestState>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActivityMarkRepoNotificationsAsReadRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_read_at: Option<DateTime<Utc>>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutPullsUpdateBranchAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    /**
     * The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum Path {
        Root,
        Docs,
    }

    impl std::fmt::Display for Path {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                Path::Root => "/",
                Path::Docs => "/docs",
            }
            .fmt(f)
        }
    }

    impl Default for Path {
        fn default() -> Path {
            Path::Root
        }
    }

    /// The source branch and directory used to publish your Pages site.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreatePagesSiteRequestSource {
        /**
         * The repository branch used to publish your site's source files.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        /**
         * The source branch and directory used to publish your Pages site.
         */
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub path: Option<Path>,
    }

    /// The source branch and directory used to publish your Pages site.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreatePagesSiteRequest {
        /**
         * The source branch and directory used to publish your Pages site.
         */
        #[serde()]
        pub source: ReposCreatePagesSiteRequestSource,
    }

    /**
     * Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`, `"master"`, and `"master /docs"`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SourceData {
        GhPages,
        Master,
        MasterDocs,
        Noop,
    }

    impl std::fmt::Display for SourceData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SourceData::GhPages => "gh-pages",
                SourceData::Master => "master",
                SourceData::MasterDocs => "master /docs",
                SourceData::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SourceData {
        fn default() -> SourceData {
            SourceData::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateInformationAboutPagesSiteRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cname: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_enforced: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<SourceData>,
    }

    /**
     * Either `open`, `closed`, or `all` to filter by state.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsListState {
        All,
        Closed,
        Open,
    }

    impl std::fmt::Display for PullsListState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsListState::All => "all",
                PullsListState::Closed => "closed",
                PullsListState::Open => "open",
            }
            .fmt(f)
        }
    }

    impl Default for PullsListState {
        fn default() -> PullsListState {
            PullsListState::Open
        }
    }

    /**
     * What to sort results by. Can be either `created`, `updated`, `popularity` (comment count) or `long-running` (age, filtering by pulls updated in the last month).
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsListSort {
        Created,
        LongRunning,
        Popularity,
        Updated,
    }

    impl std::fmt::Display for PullsListSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsListSort::Created => "created",
                PullsListSort::LongRunning => "long-running",
                PullsListSort::Popularity => "popularity",
                PullsListSort::Updated => "updated",
            }
            .fmt(f)
        }
    }

    impl Default for PullsListSort {
        fn default() -> PullsListSort {
            PullsListSort::Created
        }
    }

    /**
     * The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsListDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for PullsListDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsListDirection::Asc => "asc",
                PullsListDirection::Desc => "desc",
                PullsListDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsListDirection {
        fn default() -> PullsListDirection {
            PullsListDirection::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsCreateRequest {
        /**
         * The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        /**
         * The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintainer_can_modify: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsListReviewCommentsRepoSort {
        Created,
        CreatedAt,
        Updated,
        Noop,
    }

    impl std::fmt::Display for PullsListReviewCommentsRepoSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsListReviewCommentsRepoSort::Created => "created",
                PullsListReviewCommentsRepoSort::CreatedAt => "created_at",
                PullsListReviewCommentsRepoSort::Updated => "updated",
                PullsListReviewCommentsRepoSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsListReviewCommentsRepoSort {
        fn default() -> PullsListReviewCommentsRepoSort {
            PullsListReviewCommentsRepoSort::Noop
        }
    }

    /**
     * Can be either `asc` or `desc`. Ignored without `sort` parameter.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsListReviewCommentsDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for PullsListReviewCommentsDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsListReviewCommentsDirection::Asc => "asc",
                PullsListReviewCommentsDirection::Desc => "desc",
                PullsListReviewCommentsDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsListReviewCommentsDirection {
        fn default() -> PullsListReviewCommentsDirection {
            PullsListReviewCommentsDirection::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsUpdateReviewCommentRequest {
        /**
         * The text of the reply to the review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    /**
     * Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsListPullRequestReviewCommentContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsListPullRequestReviewCommentContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsListPullRequestReviewCommentContent::PlusOne => "+1",
                ReactionsListPullRequestReviewCommentContent::MinusOne => "-1",
                ReactionsListPullRequestReviewCommentContent::Confused => "confused",
                ReactionsListPullRequestReviewCommentContent::Eyes => "eyes",
                ReactionsListPullRequestReviewCommentContent::Heart => "heart",
                ReactionsListPullRequestReviewCommentContent::Hooray => "hooray",
                ReactionsListPullRequestReviewCommentContent::Laugh => "laugh",
                ReactionsListPullRequestReviewCommentContent::Rocket => "rocket",
                ReactionsListPullRequestReviewCommentContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsListPullRequestReviewCommentContent {
        fn default() -> ReactionsListPullRequestReviewCommentContent {
            ReactionsListPullRequestReviewCommentContent::Noop
        }
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the pull request review comment.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreatePullRequestReviewCommentContent {
        PlusOne,
        MinusOne,
        Confused,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreatePullRequestReviewCommentContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreatePullRequestReviewCommentContent::PlusOne => "+1",
                ReactionsCreatePullRequestReviewCommentContent::MinusOne => "-1",
                ReactionsCreatePullRequestReviewCommentContent::Confused => "confused",
                ReactionsCreatePullRequestReviewCommentContent::Eyes => "eyes",
                ReactionsCreatePullRequestReviewCommentContent::Heart => "heart",
                ReactionsCreatePullRequestReviewCommentContent::Hooray => "hooray",
                ReactionsCreatePullRequestReviewCommentContent::Laugh => "laugh",
                ReactionsCreatePullRequestReviewCommentContent::Rocket => "rocket",
                ReactionsCreatePullRequestReviewCommentContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreatePullRequestReviewCommentContent {
        fn default() -> ReactionsCreatePullRequestReviewCommentContent {
            ReactionsCreatePullRequestReviewCommentContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreatePullRequestReviewComment {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the pull request review comment.
         */
        #[serde()]
        pub content: ReactionsCreatePullRequestReviewCommentContent,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsUpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintainer_can_modify: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state: Option<PullRequestState>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /**
     * **Required with `comfort-fade` preview**. In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://help.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsCreateReviewCommentRequestSide {
        Left,
        Right,
        Noop,
    }

    impl std::fmt::Display for PullsCreateReviewCommentRequestSide {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsCreateReviewCommentRequestSide::Left => "LEFT",
                PullsCreateReviewCommentRequestSide::Right => "RIGHT",
                PullsCreateReviewCommentRequestSide::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsCreateReviewCommentRequestSide {
        fn default() -> PullsCreateReviewCommentRequestSide {
            PullsCreateReviewCommentRequestSide::Noop
        }
    }

    /**
     * **Required when using multi-line comments**. To create multi-line comments, you must use the `comfort-fade` preview header. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsCreateReviewCommentRequestStartSide {
        Left,
        Right,
        Side,
        Noop,
    }

    impl std::fmt::Display for PullsCreateReviewCommentRequestStartSide {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsCreateReviewCommentRequestStartSide::Left => "LEFT",
                PullsCreateReviewCommentRequestStartSide::Right => "RIGHT",
                PullsCreateReviewCommentRequestStartSide::Side => "side",
                PullsCreateReviewCommentRequestStartSide::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsCreateReviewCommentRequestStartSide {
        fn default() -> PullsCreateReviewCommentRequestStartSide {
            PullsCreateReviewCommentRequestStartSide::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsCreateReviewCommentRequest {
        /**
         * The text of the review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub side: Option<PullsCreateReviewCommentRequestSide>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_side: Option<PullsCreateReviewCommentRequestStartSide>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsCreateReplyReviewCommentRequest {
        /**
         * The text of the review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    /**
     * Merge method to use. Possible values are `merge`, `squash` or `rebase`. Default is `merge`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsMergeRequestMethod {
        Merge,
        Rebase,
        Squash,
        Noop,
    }

    impl std::fmt::Display for PullsMergeRequestMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsMergeRequestMethod::Merge => "merge",
                PullsMergeRequestMethod::Rebase => "rebase",
                PullsMergeRequestMethod::Squash => "squash",
                PullsMergeRequestMethod::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsMergeRequestMethod {
        fn default() -> PullsMergeRequestMethod {
            PullsMergeRequestMethod::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsMergeRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_title: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub merge_method: Option<PullsMergeRequestMethod>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsRequestReviewers {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_reviewers: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsRemoveRequestedReviewersRequest {
        /**
         * An array of user `login`s that will be removed.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_reviewers: Vec<String>,
    }

    /**
     * The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/reference/pulls#submit-a-review-for-a-pull-request) when you are ready.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsCreateReviewRequestEvent {
        Approve,
        Comment,
        RequestChanges,
        Noop,
    }

    impl std::fmt::Display for PullsCreateReviewRequestEvent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsCreateReviewRequestEvent::Approve => "APPROVE",
                PullsCreateReviewRequestEvent::Comment => "COMMENT",
                PullsCreateReviewRequestEvent::RequestChanges => "REQUEST_CHANGES",
                PullsCreateReviewRequestEvent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsCreateReviewRequestEvent {
        fn default() -> PullsCreateReviewRequestEvent {
            PullsCreateReviewRequestEvent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Comments {
        /**
         * Text of the review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        /**
         * The relative path to the file that necessitates a review comment.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub side: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub start_side: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsCreateReviewRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<Comments>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub event: Option<PullsCreateReviewRequestEvent>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsUpdateReviewRequest {
        /**
         * The body text of the pull request review.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsDismissReviewRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        /**
         * The message for the pull request review dismissal
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    /**
     * The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum PullsSubmitReviewRequestEvent {
        Approve,
        Comment,
        RequestChanges,
        Noop,
    }

    impl std::fmt::Display for PullsSubmitReviewRequestEvent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                PullsSubmitReviewRequestEvent::Approve => "APPROVE",
                PullsSubmitReviewRequestEvent::Comment => "COMMENT",
                PullsSubmitReviewRequestEvent::RequestChanges => "REQUEST_CHANGES",
                PullsSubmitReviewRequestEvent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for PullsSubmitReviewRequestEvent {
        fn default() -> PullsSubmitReviewRequestEvent {
            PullsSubmitReviewRequestEvent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsSubmitReviewRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
         */
        #[serde()]
        pub event: PullsSubmitReviewRequestEvent,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullsUpdateBranchRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expected_head_sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateReleaseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_category_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prerelease: Option<bool>,
        /**
         * The name of the tag.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateReleaseAssetRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposUpdateReleaseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_category_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prerelease: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
    }

    /**
     * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the release.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReactionsCreateReleaseRequestContent {
        PlusOne,
        Eyes,
        Heart,
        Hooray,
        Laugh,
        Rocket,
        Noop,
    }

    impl std::fmt::Display for ReactionsCreateReleaseRequestContent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReactionsCreateReleaseRequestContent::PlusOne => "+1",
                ReactionsCreateReleaseRequestContent::Eyes => "eyes",
                ReactionsCreateReleaseRequestContent::Heart => "heart",
                ReactionsCreateReleaseRequestContent::Hooray => "hooray",
                ReactionsCreateReleaseRequestContent::Laugh => "laugh",
                ReactionsCreateReleaseRequestContent::Rocket => "rocket",
                ReactionsCreateReleaseRequestContent::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReactionsCreateReleaseRequestContent {
        fn default() -> ReactionsCreateReleaseRequestContent {
            ReactionsCreateReleaseRequestContent::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionsCreateReleaseRequest {
        /**
         * The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the release.
         */
        #[serde()]
        pub content: ReactionsCreateReleaseRequestContent,
    }

    /**
     * Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SecretScanningListAlertsRepoState {
        Open,
        Resolved,
        Noop,
    }

    impl std::fmt::Display for SecretScanningListAlertsRepoState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SecretScanningListAlertsRepoState::Open => "open",
                SecretScanningListAlertsRepoState::Resolved => "resolved",
                SecretScanningListAlertsRepoState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SecretScanningListAlertsRepoState {
        fn default() -> SecretScanningListAlertsRepoState {
            SecretScanningListAlertsRepoState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecretScanningUpdateAlertRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolution: Option<serde_json::Value>,
        /**
         * Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.
         */
        #[serde()]
        pub state: SecretScanningAlertState,
    }

    /**
     * The state of the status. Can be one of `error`, `failure`, `pending`, or `success`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposCreateCommitStatusRequestState {
        Error,
        Failure,
        Pending,
        Success,
        Noop,
    }

    impl std::fmt::Display for ReposCreateCommitStatusRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposCreateCommitStatusRequestState::Error => "error",
                ReposCreateCommitStatusRequestState::Failure => "failure",
                ReposCreateCommitStatusRequestState::Pending => "pending",
                ReposCreateCommitStatusRequestState::Success => "success",
                ReposCreateCommitStatusRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposCreateCommitStatusRequestState {
        fn default() -> ReposCreateCommitStatusRequestState {
            ReposCreateCommitStatusRequestState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateCommitStatusRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * The state of the status. Can be one of `error`, `failure`, `pending`, or `success`.
         */
        #[serde()]
        pub state: ReposCreateCommitStatusRequestState,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActivitySetRepoSubscriptionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ignored: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribed: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposReplaceAllTopicsRequest {
        /**
         * An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` cannot contain uppercase letters.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub names: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposTransferRequest {
        /**
         * The username or organization name the repository will be transferred to.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_owner: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateUsingTemplateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_all_branches: Option<bool>,
        /**
         * The name of the new repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsCreateUpdateEnvironmentSecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminProvisionInviteGroupRequestMembers {
        /**
         * The SCIM user ID for a user.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminProvisionInviteGroupRequest {
        /**
         * The name of the SCIM group. This must match the GitHub organization that the group maps to.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<EnterpriseAdminProvisionInviteGroupRequestMembers>,
        /**
         * The SCIM schema URIs.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum EnterpriseAdminUpdateAttributeGroupRequestOperationsOp {
        Add,
        Remove,
        Replace,
        Noop,
    }

    impl std::fmt::Display for EnterpriseAdminUpdateAttributeGroupRequestOperationsOp {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                EnterpriseAdminUpdateAttributeGroupRequestOperationsOp::Add => "Add",
                EnterpriseAdminUpdateAttributeGroupRequestOperationsOp::Remove => "Remove",
                EnterpriseAdminUpdateAttributeGroupRequestOperationsOp::Replace => "Replace",
                EnterpriseAdminUpdateAttributeGroupRequestOperationsOp::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for EnterpriseAdminUpdateAttributeGroupRequestOperationsOp {
        fn default() -> EnterpriseAdminUpdateAttributeGroupRequestOperationsOp {
            EnterpriseAdminUpdateAttributeGroupRequestOperationsOp::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminUpdateAttributeGroupRequestOperations {
        #[serde()]
        pub op: EnterpriseAdminUpdateAttributeGroupRequestOperationsOp,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminUpdateAttributeGroupRequest {
        /**
         * Array of [SCIM operations](https://tools.ietf.org/html/rfc7644#section-3.5.2).
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<EnterpriseAdminUpdateAttributeGroupRequestOperations>,
        /**
         * The SCIM schema URIs.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminProvisionInviteUserRequestName {
        /**
         * The last name of the user.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        /**
         * The first name of the user.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminProvisionInviteUserRequestEmails {
        /**
         * Whether this email address is the primary address.
         */
        #[serde(default)]
        pub primary: bool,
        /**
         * The type of email address.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        /**
         * The email address.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminProvisionInviteUserRequest {
        /**
         * List of user emails.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<EnterpriseAdminProvisionInviteUserRequestEmails>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<ScimUserListEnterpriseResourcesGroups>,
        #[serde()]
        pub name: EnterpriseAdminProvisionInviteUserRequestName,
        /**
         * The SCIM schema URIs.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        /**
         * The username for the user.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnterpriseAdminUpdateAttributeUserRequest {
        /**
         * Array of [SCIM operations](https://tools.ietf.org/html/rfc7644#section-3.5.2).
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Data>,
        /**
         * The SCIM schema URIs.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimProvisionInviteUserRequestEmails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimProvisionInviteUserRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        /**
         * user emails
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<ScimProvisionInviteUserRequestEmails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<String>,
        #[serde()]
        pub name: ScimUserName,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        /**
         * Configured by the admin. Could be an email, login, or username
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Value {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUpdateAttributeUserRequestOperations {
        #[serde()]
        pub op: Op,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub value: Option<Value>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUpdateAttributeUserRequest {
        /**
         * Set of operations to be performed
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<ScimUpdateAttributeUserRequestOperations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    /**
     * Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchCodeSort {
        Indexed,
        Noop,
    }

    impl std::fmt::Display for SearchCodeSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchCodeSort::Indexed => "indexed",
                SearchCodeSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchCodeSort {
        fn default() -> SearchCodeSort {
            SearchCodeSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchCodeOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<CodeSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchCommitsSort {
        AuthorDate,
        CommitterDate,
        Noop,
    }

    impl std::fmt::Display for SearchCommitsSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchCommitsSort::AuthorDate => "author-date",
                SearchCommitsSort::CommitterDate => "committer-date",
                SearchCommitsSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchCommitsSort {
        fn default() -> SearchCommitsSort {
            SearchCommitsSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchCommitsOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<CommitSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchIssuesPullRequestsSort {
        Comments,
        Created,
        Interactions,
        Reactions,
        ReactionsPlusOne,
        ReactionsMinusOne,
        ReactionsHeart,
        ReactionsSmile,
        ReactionsTada,
        ReactionsThinkingFace,
        Updated,
        Noop,
    }

    impl std::fmt::Display for SearchIssuesPullRequestsSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchIssuesPullRequestsSort::Comments => "comments",
                SearchIssuesPullRequestsSort::Created => "created",
                SearchIssuesPullRequestsSort::Interactions => "interactions",
                SearchIssuesPullRequestsSort::Reactions => "reactions",
                SearchIssuesPullRequestsSort::ReactionsPlusOne => "reactions-+1",
                SearchIssuesPullRequestsSort::ReactionsMinusOne => "reactions--1",
                SearchIssuesPullRequestsSort::ReactionsHeart => "reactions-heart",
                SearchIssuesPullRequestsSort::ReactionsSmile => "reactions-smile",
                SearchIssuesPullRequestsSort::ReactionsTada => "reactions-tada",
                SearchIssuesPullRequestsSort::ReactionsThinkingFace => "reactions-thinking_face",
                SearchIssuesPullRequestsSort::Updated => "updated",
                SearchIssuesPullRequestsSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchIssuesPullRequestsSort {
        fn default() -> SearchIssuesPullRequestsSort {
            SearchIssuesPullRequestsSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchIssuesPullRequestsOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<IssueSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchLabelsSort {
        Created,
        Updated,
        Noop,
    }

    impl std::fmt::Display for SearchLabelsSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchLabelsSort::Created => "created",
                SearchLabelsSort::Updated => "updated",
                SearchLabelsSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchLabelsSort {
        fn default() -> SearchLabelsSort {
            SearchLabelsSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchLabelsOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<LabelSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchReposSort {
        Forks,
        HelpWantedIssues,
        Stars,
        Updated,
        Noop,
    }

    impl std::fmt::Display for SearchReposSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchReposSort::Forks => "forks",
                SearchReposSort::HelpWantedIssues => "help-wanted-issues",
                SearchReposSort::Stars => "stars",
                SearchReposSort::Updated => "updated",
                SearchReposSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchReposSort {
        fn default() -> SearchReposSort {
            SearchReposSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchReposOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<RepoSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchTopicsOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<TopicSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchUsersSort {
        Followers,
        Joined,
        Repositories,
        Noop,
    }

    impl std::fmt::Display for SearchUsersSort {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                SearchUsersSort::Followers => "followers",
                SearchUsersSort::Joined => "joined",
                SearchUsersSort::Repositories => "repositories",
                SearchUsersSort::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for SearchUsersSort {
        fn default() -> SearchUsersSort {
            SearchUsersSort::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchUsersOkResponse {
        #[serde(default)]
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<UserSearchResultItem>,
        #[serde(default)]
        pub total_count: i64,
    }

    /**
     * The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  
     *   **For a non-nested team:**  
     *   \* `secret` - only visible to organization owners and members of this team.  
     *   \* `closed` - visible to all members of this organization.  
     *   **For a parent or child team:**  
     *   \* `closed` - visible to all members of this organization.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsUpdateLegacyRequestPrivacy {
        Closed,
        Secret,
        Noop,
    }

    impl std::fmt::Display for TeamsUpdateLegacyRequestPrivacy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsUpdateLegacyRequestPrivacy::Closed => "closed",
                TeamsUpdateLegacyRequestPrivacy::Secret => "secret",
                TeamsUpdateLegacyRequestPrivacy::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsUpdateLegacyRequestPrivacy {
        fn default() -> TeamsUpdateLegacyRequestPrivacy {
            TeamsUpdateLegacyRequestPrivacy::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsUpdateLegacyRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * The name of the team.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<Permission>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub privacy: Option<TeamsUpdateLegacyRequestPrivacy>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsAddUpdateProjectPermissionsLegacyRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<TeamsAddUpdateProjectPermissionsInOrgRequestPermission>,
    }

    /**
     * The permission to grant the team on this repository. Can be one of:  
     *   \* `pull` - team members can pull, but not push to or administer this repository.  
     *   \* `push` - team members can pull and push, but not administer this repository.  
     *   \* `admin` - team members can pull, push and administer this repository.  
     *     
     *   If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum TeamsAddUpdateRepoPermissionsLegacyRequestPermission {
        Admin,
        Pull,
        Push,
        Noop,
    }

    impl std::fmt::Display for TeamsAddUpdateRepoPermissionsLegacyRequestPermission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                TeamsAddUpdateRepoPermissionsLegacyRequestPermission::Admin => "admin",
                TeamsAddUpdateRepoPermissionsLegacyRequestPermission::Pull => "pull",
                TeamsAddUpdateRepoPermissionsLegacyRequestPermission::Push => "push",
                TeamsAddUpdateRepoPermissionsLegacyRequestPermission::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for TeamsAddUpdateRepoPermissionsLegacyRequestPermission {
        fn default() -> TeamsAddUpdateRepoPermissionsLegacyRequestPermission {
            TeamsAddUpdateRepoPermissionsLegacyRequestPermission::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsAddUpdateRepoPermissionsLegacyRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permission: Option<TeamsAddUpdateRepoPermissionsLegacyRequestPermission>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateUpdateIdpGroupConnectionsLegacyRequestGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        /**
         * Description of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_description: String,
        /**
         * ID of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_id: String,
        /**
         * Name of the IdP group.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamsCreateUpdateIdpGroupConnectionsLegacyRequest {
        /**
         * The IdP groups you want to connect to a GitHub team. When updating, the new `groups` object will replace the original one. You must include any existing groups that you don't want to remove.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<TeamsCreateUpdateIdpGroupConnectionsLegacyRequestGroups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub synced_at: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersUpdateAuthenticatedRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hireable: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
    }

    /**
     * Denotes whether an email is publicly visible.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum UsersSetPrimaryEmailVisibilityAuthenticatedRequest {
        Private,
        Public,
        Noop,
    }

    impl std::fmt::Display for UsersSetPrimaryEmailVisibilityAuthenticatedRequest {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                UsersSetPrimaryEmailVisibilityAuthenticatedRequest::Private => "private",
                UsersSetPrimaryEmailVisibilityAuthenticatedRequest::Public => "public",
                UsersSetPrimaryEmailVisibilityAuthenticatedRequest::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for UsersSetPrimaryEmailVisibilityAuthenticatedRequest {
        fn default() -> UsersSetPrimaryEmailVisibilityAuthenticatedRequest {
            UsersSetPrimaryEmailVisibilityAuthenticatedRequest::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersSetPrimaryEmailVisibilityAuthenticatedRequestData {
        /**
         * Denotes whether an email is publicly visible.
         */
        #[serde()]
        pub visibility: UsersSetPrimaryEmailVisibilityAuthenticatedRequest,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersAddEmailAuthenticatedRequest {
        /**
         * Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<String>,
    }

    /// Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersDeleteEmailAuthenticatedRequest {
        /**
         * Email addresses associated with the GitHub user account.
         */
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersCreateGpgKeyAuthenticatedRequest {
        /**
         * A GPG key in ASCII-armored format.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub armored_public_key: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UsersCreatePublicSshKeyAuthenticatedRequest {
        /**
         * The public SSH key to add to your GitHub account.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    /**
     * Indicates the state of the memberships to return. Can be either `active` or `pending`. If not specified, the API returns both active and pending memberships.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsListMembershipsState {
        Active,
        Pending,
        Noop,
    }

    impl std::fmt::Display for OrgsListMembershipsState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsListMembershipsState::Active => "active",
                OrgsListMembershipsState::Pending => "pending",
                OrgsListMembershipsState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsListMembershipsState {
        fn default() -> OrgsListMembershipsState {
            OrgsListMembershipsState::Noop
        }
    }

    /**
     * The state that the membership should be in. Only `"active"` will be accepted.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum OrgsUpdateMembershipRequestState {
        Active,
        Noop,
    }

    impl std::fmt::Display for OrgsUpdateMembershipRequestState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                OrgsUpdateMembershipRequestState::Active => "active",
                OrgsUpdateMembershipRequestState::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for OrgsUpdateMembershipRequestState {
        fn default() -> OrgsUpdateMembershipRequestState {
            OrgsUpdateMembershipRequestState::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgsUpdateMembershipRequest {
        /**
         * The state that the membership should be in. Only `"active"` will be accepted.
         */
        #[serde()]
        pub state: OrgsUpdateMembershipRequestState,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MigrationsStartRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<MigrationsListOrgExclude>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub exclude_attachments: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectsCreateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        /**
         * Name of the project
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    /**
     * Can be one of `all`, `public`, or `private`. Note: For GitHub AE, can be one of `all`, `internal`, or `private`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListVisibility {
        All,
        Private,
        Public,
    }

    impl std::fmt::Display for ReposListVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListVisibility::All => "all",
                ReposListVisibility::Private => "private",
                ReposListVisibility::Public => "public",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListVisibility {
        fn default() -> ReposListVisibility {
            ReposListVisibility::All
        }
    }

    /**
     * Can be one of `all`, `owner`, `public`, `private`, `member`. Note: For GitHub AE, can be one of `all`, `owner`, `internal`, `private`, `member`. Default: `all`  
     *     
     *   Will cause a `422` error if used in the same request as **visibility** or **affiliation**. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListType {
        All,
        Member,
        Owner,
        Private,
        Public,
    }

    impl std::fmt::Display for ReposListType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListType::All => "all",
                ReposListType::Member => "member",
                ReposListType::Owner => "owner",
                ReposListType::Private => "private",
                ReposListType::Public => "public",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListType {
        fn default() -> ReposListType {
            ReposListType::All
        }
    }

    /**
     * Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc`
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListDirection {
        Asc,
        Desc,
        Noop,
    }

    impl std::fmt::Display for ReposListDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListDirection::Asc => "asc",
                ReposListDirection::Desc => "desc",
                ReposListDirection::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListDirection {
        fn default() -> ReposListDirection {
            ReposListDirection::Noop
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReposCreateRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_init: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gitignore_template: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license_template: String,
        /**
         * The name of the repository.
         */
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub team_id: Option<i64>,
    }

    /**
     * Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum UsersGetContextUserSubjectType {
        Issue,
        Organization,
        PullRequest,
        Repository,
        Noop,
    }

    impl std::fmt::Display for UsersGetContextUserSubjectType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                UsersGetContextUserSubjectType::Issue => "issue",
                UsersGetContextUserSubjectType::Organization => "organization",
                UsersGetContextUserSubjectType::PullRequest => "pull_request",
                UsersGetContextUserSubjectType::Repository => "repository",
                UsersGetContextUserSubjectType::Noop => "",
            }
            .fmt(f)
        }
    }

    impl Default for UsersGetContextUserSubjectType {
        fn default() -> UsersGetContextUserSubjectType {
            UsersGetContextUserSubjectType::Noop
        }
    }

    /**
     * Can be one of `all`, `owner`, `member`.
     */
    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    #[serde(rename_all = "snake_case")]
    pub enum ReposListUserType {
        All,
        Member,
        Owner,
    }

    impl std::fmt::Display for ReposListUserType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match *self {
                ReposListUserType::All => "all",
                ReposListUserType::Member => "member",
                ReposListUserType::Owner => "owner",
            }
            .fmt(f)
        }
    }

    impl Default for ReposListUserType {
        fn default() -> ReposListUserType {
            ReposListUserType::Owner
        }
    }
}

/// Entrypoint for interacting with the API client.
pub struct Client {
    host: String,
    agent: String,
    client: reqwest::Client,
    credentials: Option<crate::auth::Credentials>,
    #[cfg(feature = "httpcache")]
    http_cache: crate::http_cache::BoxedHttpCache,
}

impl Client {
    pub fn new<A, C>(agent: A, credentials: C) -> Result<Self>
    where
        A: Into<String>,
        C: Into<Option<crate::auth::Credentials>>,
    {
        Self::host(DEFAULT_HOST, agent, credentials)
    }

    pub fn host<H, A, C>(host: H, agent: A, credentials: C) -> Result<Self>
    where
        H: Into<String>,
        A: Into<String>,
        C: Into<Option<crate::auth::Credentials>>,
    {
        let http = reqwest::Client::builder().build()?;
        #[cfg(feature = "httpcache")]
        {
            Ok(Self::custom(host, agent, credentials, http, <dyn crate::http_cache::HttpCache>::noop()))
        }
        #[cfg(not(feature = "httpcache"))]
        {
            Ok(Self::custom(host, agent, credentials, http))
        }
    }

    #[cfg(feature = "httpcache")]
    pub fn custom<H, A, CR>(host: H, agent: A, credentials: CR, http: reqwest::Client, http_cache: crate::http_cache::BoxedHttpCache) -> Self
    where
        H: Into<String>,
        A: Into<String>,
        CR: Into<Option<crate::auth::Credentials>>,
    {
        Self {
            host: host.into(),
            agent: agent.into(),
            client: http,
            credentials: credentials.into(),
            http_cache,
        }
    }

    #[cfg(not(feature = "httpcache"))]
    pub fn custom<H, A, CR>(host: H, agent: A, credentials: CR, http: reqwest::Client) -> Self
    where
        H: Into<String>,
        A: Into<String>,
        CR: Into<Option<crate::auth::Credentials>>,
    {
        Self {
            host: host.into(),
            agent: agent.into(),
            client: http,
            credentials: credentials.into(),
        }
    }

    pub fn set_credentials<CR>(&mut self, credentials: CR)
    where
        CR: Into<Option<crate::auth::Credentials>>,
    {
        self.credentials = credentials.into();
    }

    fn credentials(&self, authentication: crate::auth::AuthenticationConstraint) -> Option<&crate::auth::Credentials> {
        match (authentication, self.credentials.as_ref()) {
            (crate::auth::AuthenticationConstraint::Unconstrained, creds) => creds,
            (crate::auth::AuthenticationConstraint::JWT, creds @ Some(&crate::auth::Credentials::JWT(_))) => creds,
            (crate::auth::AuthenticationConstraint::JWT, Some(&crate::auth::Credentials::InstallationToken(ref apptoken))) => Some(apptoken.jwt()),
            (crate::auth::AuthenticationConstraint::JWT, creds) => {
                println!("Request needs JWT authentication but only {:?} available", creds);
                None
            }
        }
    }

    async fn url_and_auth(&self, uri: &str, authentication: crate::auth::AuthenticationConstraint) -> Result<(reqwest::Url, Option<String>)> {
        let parsed_url = uri.parse::<reqwest::Url>();

        match self.credentials(authentication) {
            Some(&crate::auth::Credentials::Client(ref id, ref secret)) => parsed_url
                .map(|mut u| {
                    u.query_pairs_mut().append_pair("client_id", id).append_pair("client_secret", secret);
                    (u, None)
                })
                .map_err(Error::from),
            Some(&crate::auth::Credentials::Token(ref token)) => {
                let auth = format!("token {}", token);
                parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
            }
            Some(&crate::auth::Credentials::JWT(ref jwt)) => {
                let auth = format!("Bearer {}", jwt.token());
                parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
            }
            Some(&crate::auth::Credentials::InstallationToken(ref apptoken)) => {
                if let Some(token) = apptoken.token() {
                    let auth = format!("token {}", token);
                    parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
                } else {
                    println!("App token is stale, refreshing");
                    let token_ref = apptoken.access_key.clone();

                    let token = self
                        .apps_create_installation_access_token(
                            apptoken.installation_id as i64,
                            &types::AppsCreateInstallationAccessTokenRequest {
                                permissions: Default::default(),
                                repositories: Default::default(),
                                repository_ids: Default::default(),
                            },
                        )
                        .await
                        .unwrap();
                    let auth = format!("token {}", &token.token);
                    *token_ref.lock().unwrap() = Some(token.token);
                    parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
                }
            }
            None => parsed_url.map(|u| (u, None)).map_err(Error::from),
        }
    }

    async fn request<Out>(
        &self,
        method: http::Method,
        uri: &str,
        body: Option<reqwest::Body>,
        media_type: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<(Option<hyperx::header::Link>, Out)>
    where
        Out: serde::de::DeserializeOwned + 'static + Send,
    {
        #[cfg(feature = "httpcache")]
        let uri2 = uri.to_string();

        let (url, auth) = self.url_and_auth(uri, authentication).await?;

        let instance = <&Client>::clone(&self);

        #[cfg(not(feature = "httpcache"))]
        let mut req = instance.client.request(method, url);

        #[cfg(feature = "httpcache")]
        let mut req = {
            let mut req = instance.client.request(method.clone(), url);
            if method == http::Method::GET {
                if let Ok(etag) = instance.http_cache.lookup_etag(&uri2) {
                    req = req.header(http::header::IF_NONE_MATCH, etag);
                }
            }
            req
        };

        req = req.header(http::header::USER_AGENT, &*instance.agent);
        req = req.header(
            http::header::ACCEPT,
            &*format!("{}", hyperx::header::qitem::<mime::Mime>(From::from(media_type))),
        );

        if let Some(auth_str) = auth {
            req = req.header(http::header::AUTHORIZATION, &*auth_str);
        }

        if let Some(body) = body {
            //println!("Body: {:?}", String::from_utf8(body.as_bytes().unwrap().to_vec()).unwrap());
            req = req.body(body);
        }
        println!("Request: {:?}", &req);
        let response = req.send().await?;

        #[cfg(feature = "httpcache")]
        let instance2 = <&Client>::clone(&self);

        #[cfg(feature = "httpcache")]
        let uri3 = uri.to_string();

        #[cfg(not(feature = "httpcache"))]
        let (remaining, reset) = crate::utils::get_header_values(response.headers());

        #[cfg(feature = "httpcache")]
        let (remaining, reset, etag) = crate::utils::get_header_values(response.headers());

        let status = response.status();
        let link = response
            .headers()
            .get(http::header::LINK)
            .and_then(|l| l.to_str().ok())
            .and_then(|l| l.parse().ok());

        let response_body = response.bytes().await?;

        if status.is_success() {
            println!("response payload {}", String::from_utf8_lossy(&response_body));
            #[cfg(feature = "httpcache")]
            {
                if let Some(etag) = etag {
                    let next_link = link.as_ref().and_then(|l| crate::utils::next_link(l));
                    if let Err(e) = instance2.http_cache.cache_response(&uri3, &response_body, &etag, &next_link) {
                        // failing to cache isn't fatal, so just log & swallow the error
                        println!("Failed to cache body & etag: {}", e);
                    }
                }
            }
            let parsed_response = if status == http::StatusCode::NO_CONTENT {
                serde_json::from_str("null")
            } else {
                serde_json::from_slice::<Out>(&response_body)
            };
            parsed_response.map(|out| (link, out)).map_err(Error::from)
        } else if status == http::StatusCode::NOT_MODIFIED {
            // only supported case is when client provides if-none-match
            // header when cargo builds with --cfg feature="httpcache"
            #[cfg(feature = "httpcache")]
            {
                let body = instance2.http_cache.lookup_body(&uri3).unwrap();
                let out = serde_json::from_str::<Out>(&body).unwrap();
                let link = match link {
                    Some(link) => Ok(Some(link)),
                    None => instance2.http_cache.lookup_next_link(&uri3).map(|next_link| {
                        next_link.map(|next| {
                            let next = hyperx::header::LinkValue::new(next).push_rel(hyperx::header::RelationType::Next);
                            hyperx::header::Link::new(vec![next])
                        })
                    }),
                };
                link.map(|link| (link, out))
            }
            #[cfg(not(feature = "httpcache"))]
            {
                unreachable!("this should not be reachable without the httpcache feature enabled")
            }
        } else {
            println!(
                "error status: {:?}, response payload: {}",
                status,
                String::from_utf8_lossy(&response_body),
            );
            let error = match (remaining, reset) {
                (Some(remaining), Some(reset)) if remaining == 0 => {
                    let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs();
                    anyhow!("rate limit exceeded, will reset in {} seconds", u64::from(reset) - now)
                }
                _ => {
                    if response_body.is_empty() {
                        anyhow!("code: {}, empty response", status)
                    } else {
                        anyhow!("code: {}, error: {:?}", status, serde_json::from_slice(&response_body)?)
                    }
                }
            };
            Err(error)
        }
    }

    async fn request_entity<D>(
        &self,
        method: http::Method,
        uri: &str,
        body: Option<reqwest::Body>,
        media_type: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        let (_, r) = self.request(method, uri, body, media_type, authentication).await?;
        Ok(r)
    }

    async fn get<D>(&self, uri: &str) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.get_media(uri, crate::utils::MediaType::Json).await
    }

    async fn get_media<D>(&self, uri: &str, media: crate::utils::MediaType) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::GET,
            &(self.host.clone() + uri),
            None,
            media,
            self::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn get_all_pages<D>(&self, uri: &str) -> Result<Vec<D>>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.unfold(uri).await
    }

    async fn get_pages<D>(&self, uri: &str) -> Result<(Option<hyperx::header::Link>, Vec<D>)>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request(
            http::Method::GET,
            &(self.host.clone() + uri),
            None,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn get_pages_url<D>(&self, url: &reqwest::Url) -> Result<(Option<hyperx::header::Link>, Vec<D>)>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request(
            http::Method::GET,
            url.as_str(),
            None,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn post<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.post_media(
            uri,
            message,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn post_media<D>(
        &self,
        uri: &str,
        message: Option<reqwest::Body>,
        media: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(http::Method::POST, &(self.host.clone() + uri), message, media, authentication)
            .await
    }

    async fn patch_media<D>(&self, uri: &str, message: Option<reqwest::Body>, media: crate::utils::MediaType) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::PATCH,
            &(self.host.clone() + uri),
            message,
            media,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn patch<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.patch_media(uri, message, crate::utils::MediaType::Json).await
    }

    async fn put<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.put_media(uri, message, crate::utils::MediaType::Json).await
    }

    async fn put_media<D>(&self, uri: &str, message: Option<reqwest::Body>, media: crate::utils::MediaType) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::PUT,
            &(self.host.clone() + uri),
            message,
            media,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn delete<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::DELETE,
            &(self.host.clone() + uri),
            message,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    /// "unfold" paginated results of a vector of items
    async fn unfold<D>(&self, uri: &str) -> Result<Vec<D>>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        let mut global_items = Vec::new();
        let (new_link, mut items) = self.get_pages(uri).await.unwrap();
        let mut link = new_link;
        items.reverse();
        while !items.is_empty() {
            match items.pop() {
                Some(item) => global_items.push(item),
                // We need to get the next link.
                None => {
                    if let Some(url) = link.as_ref().and_then(|l| crate::utils::next_link(l)) {
                        let url = reqwest::Url::parse(&url).unwrap();
                        let (new_link, new_items) = self.get_pages_url(&url).await?;
                        link = new_link;
                        items = new_items;
                    }
                }
            }
        }

        Ok(global_items)
    }

    /**
     * GitHub API Root.
     *
     * This function performs a `GET` to the `/` endpoint.
     *
     * Get Hypermedia links to resources accessible in GitHub's REST API
     *
     * FROM: <https://docs.github.com/rest/overview/resources-in-the-rest-api#root-endpoint>
     */
    pub async fn meta_root(&self) -> Result<types::GetMetaRootOkResponse> {
        let url = "".to_string();
        self.get(&url).await
    }

    /**
     * Get the authenticated app.
     *
     * This function performs a `GET` to the `/app` endpoint.
     *
     * Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-the-authenticated-app>
     */
    pub async fn apps_get_authenticated(&self) -> Result<types::Integration> {
        let url = "/app".to_string();
        self.get(&url).await
    }

    /**
     * Create a GitHub App from a manifest.
     *
     * This function performs a `POST` to the `/app-manifests/{code}/conversions` endpoint.
     *
     * Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#create-a-github-app-from-a-manifest>
     *
     * **Parameters:**
     *
     * * `code: &str`
     */
    pub async fn apps_create_from_manifest(&self, code: &str, body: &types::Data) -> Result<types::Integration> {
        let url = format!("/app-manifests/{}/conversions", progenitor_support::encode_path(&code.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a webhook configuration for an app.
     *
     * This function performs a `GET` to the `/app/hook/config` endpoint.
     *
     * Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-a-webhook-configuration-for-an-app>
     */
    pub async fn apps_get_webhook_config_for_app(&self) -> Result<types::WebhookConfig> {
        let url = "/app/hook/config".to_string();
        self.get(&url).await
    }

    /**
     * Update a webhook configuration for an app.
     *
     * This function performs a `PATCH` to the `/app/hook/config` endpoint.
     *
     * Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#update-a-webhook-configuration-for-an-app>
     */
    pub async fn apps_update_webhook_config_for_app(&self, body: &types::AppsUpdateWebhookConfigAppRequest) -> Result<types::WebhookConfig> {
        let url = "/app/hook/config".to_string();
        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List installations for the authenticated app.
     *
     * This function performs a `GET` to the `/app/installations` endpoint.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * The permissions the installation has are included under the `permissions` key.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `outdated: &str`
     */
    pub async fn apps_list_installations(&self, per_page: i64, page: i64, since: DateTime<Utc>, outdated: &str) -> Result<Vec<types::Installation>> {
        let url = format!(
            "/app/installations?outdated={}&page={}&per_page={}&since={}",
            outdated.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get an installation for the authenticated app.
     *
     * This function performs a `GET` to the `/app/installations/{installation_id}` endpoint.
     *
     * Enables an authenticated GitHub App to find an installation's information using the installation id. The installation's account type (`target_type`) will be either an organization or a user account, depending which account the repository belongs to.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-an-installation-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     */
    pub async fn apps_get_installation(&self, installation_id: i64) -> Result<types::Installation> {
        let url = format!("/app/installations/{}", progenitor_support::encode_path(&installation_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete an installation for the authenticated app.
     *
     * This function performs a `DELETE` to the `/app/installations/{installation_id}` endpoint.
     *
     * Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#delete-an-installation-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     */
    pub async fn apps_delete_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!("/app/installations/{}", progenitor_support::encode_path(&installation_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Create an installation access token for an app.
     *
     * This function performs a `POST` to the `/app/installations/{installation_id}/access_tokens` endpoint.
     *
     * Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps/#create-an-installation-access-token-for-an-app>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     */
    #[async_recursion]
    pub async fn apps_create_installation_access_token(
        &self,
        installation_id: i64,
        body: &types::AppsCreateInstallationAccessTokenRequest,
    ) -> Result<types::InstallationToken> {
        let url = format!(
            "/app/installations/{}/access_tokens",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.post_media(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::JWT,
        )
        .await
    }

    /**
     * Suspend an app installation.
     *
     * This function performs a `PUT` to the `/app/installations/{installation_id}/suspended` endpoint.
     *
     * Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#suspend-an-app-installation>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     */
    pub async fn apps_suspend_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!(
            "/app/installations/{}/suspended",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Unsuspend an app installation.
     *
     * This function performs a `DELETE` to the `/app/installations/{installation_id}/suspended` endpoint.
     *
     * Removes a GitHub App installation suspension.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#unsuspend-an-app-installation>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     */
    pub async fn apps_unsuspend_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!(
            "/app/installations/{}/suspended",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List your grants.
     *
     * This function performs a `GET` to the `/applications/grants` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * You can use this API to list the set of OAuth applications that have been granted access to your account. Unlike the [list your authorizations](https://docs.github.com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage individual tokens. This API will return one entry for each OAuth application that has been granted access to your account, regardless of the number of tokens an application has generated for your user. The list of OAuth applications returned matches what is shown on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized). The `scopes` returned are the union of scopes authorized for the application. For example, if an application has one token with `repo` scope and another token with `user` scope, the grant will return `["repo", "user"]`.
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#list-your-grants>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn oauth_authorizations_list_grants(&self, per_page: i64, page: i64, client_id: &str) -> Result<Vec<types::ApplicationGrant>> {
        let url = format!(
            "/applications/grants?client_id={}&page={}&per_page={}",
            client_id.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a single grant.
     *
     * This function performs a `GET` to the `/applications/grants/{grant_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-a-single-grant>
     *
     * **Parameters:**
     *
     * * `grant_id: i64` -- grant_id parameter.
     */
    pub async fn oauth_authorizations_get_grant(&self, grant_id: i64) -> Result<types::ApplicationGrant> {
        let url = format!("/applications/grants/{}", progenitor_support::encode_path(&grant_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a grant.
     *
     * This function performs a `DELETE` to the `/applications/grants/{grant_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for your user. Once deleted, the application has no access to your account and is no longer listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#delete-a-grant>
     *
     * **Parameters:**
     *
     * * `grant_id: i64` -- grant_id parameter.
     */
    pub async fn oauth_authorizations_delete_grant(&self, grant_id: i64) -> Result<()> {
        let url = format!("/applications/grants/{}", progenitor_support::encode_path(&grant_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Delete an app authorization.
     *
     * This function performs a `DELETE` to the `/applications/{client_id}/grant` endpoint.
     *
     * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.
     * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
     *
     * FROM: <https://docs.github.com/rest/reference/apps#delete-an-app-authorization>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn apps_delete_authorization(&self, client_id: &str, body: &types::AppsDeleteAuthorizationRequest) -> Result<()> {
        let url = format!("/applications/{}/grant", progenitor_support::encode_path(&client_id.to_string()),);

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Revoke a grant for an application.
     *
     * This function performs a `DELETE` to the `/applications/{client_id}/grants/{access_token}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid token as `:access_token` and the grant for the token's owner will be deleted.
     *
     * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the Applications settings page under "Authorized OAuth Apps" on GitHub](https://github.com/settings/applications#authorized).
     *
     * FROM: <https://docs.github.com/rest/reference/apps#revoke-a-grant-for-an-application>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     * * `access_token: &str`
     */
    pub async fn apps_revoke_grant_for_application(&self, client_id: &str, access_token: &str) -> Result<()> {
        let url = format!(
            "/applications/{}/grants/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Check a token.
     *
     * This function performs a `POST` to the `/applications/{client_id}/token` endpoint.
     *
     * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#check-a-token>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn apps_check_token(&self, client_id: &str, body: &types::AppsCheckTokenRequest) -> Result<types::Authorization> {
        let url = format!("/applications/{}/token", progenitor_support::encode_path(&client_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an app token.
     *
     * This function performs a `DELETE` to the `/applications/{client_id}/token` endpoint.
     *
     * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#delete-an-app-token>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn apps_delete_token(&self, client_id: &str, body: &types::AppsDeleteTokenRequest) -> Result<()> {
        let url = format!("/applications/{}/token", progenitor_support::encode_path(&client_id.to_string()),);

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Reset a token.
     *
     * This function performs a `PATCH` to the `/applications/{client_id}/token` endpoint.
     *
     * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#reset-a-token>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn apps_reset_token(&self, client_id: &str, body: &types::AppsCheckTokenRequest) -> Result<types::Authorization> {
        let url = format!("/applications/{}/token", progenitor_support::encode_path(&client_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a scoped access token.
     *
     * This function performs a `POST` to the `/applications/{client_id}/token/scoped` endpoint.
     *
     * Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#create-a-scoped-access-token>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn apps_scope_token(&self, client_id: &str, body: &types::AppsScopeTokenRequest) -> Result<types::Authorization> {
        let url = format!("/applications/{}/token/scoped", progenitor_support::encode_path(&client_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Check an authorization.
     *
     * This function performs a `GET` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#check-an-authorization>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     * * `access_token: &str`
     */
    pub async fn apps_check_authorization(&self, client_id: &str, access_token: &str) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Reset an authorization.
     *
     * This function performs a `POST` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#reset-an-authorization>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     * * `access_token: &str`
     */
    pub async fn apps_reset_authorization(&self, client_id: &str, access_token: &str) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Revoke an authorization for an application.
     *
     * This function performs a `DELETE` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#revoke-an-authorization-for-an-application>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     * * `access_token: &str`
     */
    pub async fn apps_revoke_authorization_for_application(&self, client_id: &str, access_token: &str) -> Result<()> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get an app.
     *
     * This function performs a `GET` to the `/apps/{app_slug}` endpoint.
     *
     * **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
     *
     * If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps/#get-an-app>
     *
     * **Parameters:**
     *
     * * `app_slug: &str`
     */
    pub async fn apps_get_by_slug(&self, app_slug: &str) -> Result<types::Integration> {
        let url = format!("/apps/{}", progenitor_support::encode_path(&app_slug.to_string()),);

        self.get(&url).await
    }

    /**
     * List your authorizations.
     *
     * This function performs a `GET` to the `/authorizations` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#list-your-authorizations>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn oauth_authorizations_list_authorizations(&self, per_page: i64, page: i64, client_id: &str) -> Result<Vec<types::Authorization>> {
        let url = format!(
            "/authorizations?client_id={}&page={}&per_page={}",
            client_id.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a new authorization.
     *
     * This function performs a `POST` to the `/authorizations` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * Creates OAuth tokens using [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * To create tokens for a particular OAuth application using this endpoint, you must authenticate as the user you want to create an authorization for and provide the app's client ID and secret, found on your OAuth application's settings page. If your OAuth application intends to create multiple tokens for one user, use `fingerprint` to differentiate between them.
     *
     * You can also create tokens on GitHub from the [personal access tokens settings](https://github.com/settings/tokens) page. Read more about these tokens in [the GitHub Help documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
     *
     * Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about allowing tokens in [the GitHub Help documentation](https://help.github.com/articles/about-identity-and-access-management-with-saml-single-sign-on).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#create-a-new-authorization>
     */
    pub async fn oauth_authorizations_create_authorization(
        &self,
        body: &types::OauthAuthorizationsCreateAuthorizationRequest,
    ) -> Result<types::Authorization> {
        let url = "/authorizations".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get-or-create an authorization for a specific app.
     *
     * This function performs a `PUT` to the `/authorizations/clients/{client_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * Creates a new authorization for the specified OAuth application, only if an authorization for that application doesn't already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-or-create-an-authorization-for-a-specific-app>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     */
    pub async fn oauth_authorizations_get_or_create_authorization_for_app(
        &self,
        client_id: &str,
        body: &types::OauthAuthorizationsGetCreateAuthorizationAppRequest,
    ) -> Result<types::Authorization> {
        let url = format!("/authorizations/clients/{}", progenitor_support::encode_path(&client_id.to_string()),);

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get-or-create an authorization for a specific app and fingerprint.
     *
     * This function performs a `PUT` to the `/authorizations/clients/{client_id}/{fingerprint}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * This method will create a new authorization for the specified OAuth application, only if an authorization for that application and fingerprint do not already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint` is a unique string to distinguish an authorization from others created for the same client ID and user. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-or-create-an-authorization-for-a-specific-app-and-fingerprint>
     *
     * **Parameters:**
     *
     * * `client_id: &str` -- The client ID of your GitHub app.
     * * `fingerprint: &str`
     */
    pub async fn oauth_authorizations_get_or_create_authorization_for_app_and_fingerprint(
        &self,
        client_id: &str,
        fingerprint: &str,
        body: &types::OauthAuthorizationsGetCreateAuthorizationAppFingerprintRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/authorizations/clients/{}/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&fingerprint.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a single authorization.
     *
     * This function performs a `GET` to the `/authorizations/{authorization_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-a-single-authorization>
     *
     * **Parameters:**
     *
     * * `authorization_id: i64` -- authorization_id parameter.
     */
    pub async fn oauth_authorizations_get_authorization(&self, authorization_id: i64) -> Result<types::Authorization> {
        let url = format!("/authorizations/{}", progenitor_support::encode_path(&authorization_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete an authorization.
     *
     * This function performs a `DELETE` to the `/authorizations/{authorization_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#delete-an-authorization>
     *
     * **Parameters:**
     *
     * * `authorization_id: i64` -- authorization_id parameter.
     */
    pub async fn oauth_authorizations_delete_authorization(&self, authorization_id: i64) -> Result<()> {
        let url = format!("/authorizations/{}", progenitor_support::encode_path(&authorization_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update an existing authorization.
     *
     * This function performs a `PATCH` to the `/authorizations/{authorization_id}` endpoint.
     *
     * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * You can only send one of these scope keys at a time.
     *
     * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#update-an-existing-authorization>
     *
     * **Parameters:**
     *
     * * `authorization_id: i64` -- authorization_id parameter.
     */
    pub async fn oauth_authorizations_update_authorization(
        &self,
        authorization_id: i64,
        body: &types::OauthAuthorizationsUpdateAuthorizationRequest,
    ) -> Result<types::Authorization> {
        let url = format!("/authorizations/{}", progenitor_support::encode_path(&authorization_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get all codes of conduct.
     *
     * This function performs a `GET` to the `/codes_of_conduct` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-all-codes-of-conduct>
     */
    pub async fn codes_of_conduct_get_all_codes_of_conduct(&self) -> Result<Vec<types::CodeOfConduct>> {
        let url = "/codes_of_conduct".to_string();
        self.get_all_pages(&url).await
    }

    /**
     * Get a code of conduct.
     *
     * This function performs a `GET` to the `/codes_of_conduct/{key}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-a-code-of-conduct>
     *
     * **Parameters:**
     *
     * * `key: &str`
     */
    pub async fn codes_of_conduct_get_conduct_code(&self, key: &str) -> Result<types::CodeOfConduct> {
        let url = format!("/codes_of_conduct/{}", progenitor_support::encode_path(&key.to_string()),);

        self.get(&url).await
    }

    /**
     * Get emojis.
     *
     * This function performs a `GET` to the `/emojis` endpoint.
     *
     * Lists all the emojis available to use on GitHub.
     *
     * FROM: <https://docs.github.com/rest/reference/emojis#get-emojis>
     */
    pub async fn emojis_get(&self) -> Result<types::Data> {
        let url = "/emojis".to_string();
        self.get(&url).await
    }

    /**
     * Get GitHub Actions permissions for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions` endpoint.
     *
     * Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-github-actions-permissions-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_get_github_actions_permissions_enterprise(&self, enterprise: &str) -> Result<types::ActionsEnterprisePermissions> {
        let url = format!(
            "/enterprises/{}/actions/permissions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set GitHub Actions permissions for an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions` endpoint.
     *
     * Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-github-actions-permissions-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_set_github_actions_permissions_enterprise(
        &self,
        enterprise: &str,
        body: &types::EnterpriseAdminSetGithubActionsPermissionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List selected organizations enabled for GitHub Actions in an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions/organizations` endpoint.
     *
     * Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-selected-organizations-enabled-for-github-actions-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn enterprise_admin_list_selected_organizations_enabled_github_actions_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetEnterpriseAdminListOrgAccessSelfHostedRunnerGroupInOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set selected organizations enabled for GitHub Actions in an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/organizations` endpoint.
     *
     * Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-selected-organizations-enabled-for-github-actions-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise(
        &self,
        enterprise: &str,
        body: &types::EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Enable a selected organization for GitHub Actions in an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/organizations/{org_id}` endpoint.
     *
     * Adds an organization to the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#enable-a-selected-organization-for-github-actions-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `org_id: i64` -- Unique identifier of an organization.
     */
    pub async fn enterprise_admin_enable_selected_organization_github_actions_enterprise(&self, enterprise: &str, org_id: i64) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Disable a selected organization for GitHub Actions in an enterprise.
     *
     * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/permissions/organizations/{org_id}` endpoint.
     *
     * Removes an organization from the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#disable-a-selected-organization-for-github-actions-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `org_id: i64` -- Unique identifier of an organization.
     */
    pub async fn enterprise_admin_disable_selected_organization_github_actions_enterprise(&self, enterprise: &str, org_id: i64) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get allowed actions for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions/selected-actions` endpoint.
     *
     * Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-allowed-actions-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_get_allowed_actions_enterprise(&self, enterprise: &str) -> Result<types::SelectedActions> {
        let url = format!(
            "/enterprises/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set allowed actions for an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/selected-actions` endpoint.
     *
     * Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-allowed-actions-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_set_allowed_actions_enterprise(&self, enterprise: &str, body: &types::SelectedActions) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List self-hosted runner groups for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups` endpoint.
     *
     * Lists all self-hosted runner groups for an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runner-groups-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn enterprise_admin_list_self_hosted_runner_groups_for_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetEnterpriseAdminListSelfHostedRunnerGroupsOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Create a self-hosted runner group for an enterprise.
     *
     * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runner-groups` endpoint.
     *
     * Creates a new self-hosted runner group for an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-self-hosted-runner-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_create_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        body: &types::EnterpriseAdminCreateSelfHostedRunnerGroupRequest,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a self-hosted runner group for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * Gets a specific self-hosted runner group for an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-a-self-hosted-runner-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn enterprise_admin_get_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a self-hosted runner group from an enterprise.
     *
     * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * Deletes a self-hosted runner group for an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-self-hosted-runner-group-from-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn enterprise_admin_delete_self_hosted_runner_group_from_enterprise(&self, enterprise: &str, runner_group_id: i64) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a self-hosted runner group for an enterprise.
     *
     * This function performs a `PATCH` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-a-self-hosted-runner-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn enterprise_admin_update_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::EnterpriseAdminUpdateSelfHostedRunnerGroupRequest,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List organization access to a self-hosted runner group in an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations` endpoint.
     *
     * Lists the organizations with access to a self-hosted runner group.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-organization-access-to-a-self-hosted-runner-group-in-a-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn enterprise_admin_list_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetEnterpriseAdminListOrgAccessSelfHostedRunnerGroupInOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set organization access for a self-hosted runner group in an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations` endpoint.
     *
     * Replaces the list of organizations that have access to a self-hosted runner configured in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::EnterpriseAdminSetOrgAccessSelfHostedRunnerGroupInRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add organization access to a self-hosted runner group in an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}` endpoint.
     *
     * Adds an organization to the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#add-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `org_id: i64` -- Unique identifier of an organization.
     */
    pub async fn enterprise_admin_add_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove organization access to a self-hosted runner group in an enterprise.
     *
     * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}` endpoint.
     *
     * Removes an organization from the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#remove-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `org_id: i64` -- Unique identifier of an organization.
     */
    pub async fn enterprise_admin_remove_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List self-hosted runners in a group for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners` endpoint.
     *
     * Lists the self-hosted runners that are in a specific enterprise group.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runners-in-a-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn enterprise_admin_list_self_hosted_runners_in_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelfHostedRunnersInGroupOrgOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set self-hosted runners in a group for an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners` endpoint.
     *
     * Replaces the list of self-hosted runners that are part of an enterprise runner group.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-self-hosted-runners-in-a-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn enterprise_admin_set_self_hosted_runners_in_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::ActionsSetSelfHostedRunnersInGroupOrgRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add a self-hosted runner to a group for an enterprise.
     *
     * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
     *
     * Adds a self-hosted runner to a runner group configured in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise`
     * scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#add-a-self-hosted-runner-to-a-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn enterprise_admin_add_self_hosted_runner_to_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove a self-hosted runner from a group for an enterprise.
     *
     * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
     *
     * Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned to the default group.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#remove-a-self-hosted-runner-from-a-group-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn enterprise_admin_remove_self_hosted_runner_from_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List self-hosted runners for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners` endpoint.
     *
     * Lists all self-hosted runners configured for an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runners-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn enterprise_admin_list_self_hosted_runners_for_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetEnterpriseAdminListSelfHostedRunnersOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List runner applications for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners/downloads` endpoint.
     *
     * Lists binaries for the runner application that you can download and run.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-runner-applications-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_list_runner_applications_for_enterprise(&self, enterprise: &str) -> Result<Vec<types::RunnerApplication>> {
        let url = format!(
            "/enterprises/{}/actions/runners/downloads",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a registration token for an enterprise.
     *
     * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runners/registration-token` endpoint.
     *
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * #### Example using registration token
     *
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-a-registration-token-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_create_registration_token_for_enterprise(&self, enterprise: &str) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/enterprises/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Create a remove token for an enterprise.
     *
     * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runners/remove-token` endpoint.
     *
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * #### Example using remove token
     *
     * To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
     * endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-a-remove-token-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_create_remove_token_for_enterprise(&self, enterprise: &str) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/enterprises/{}/actions/runners/remove-token",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get a self-hosted runner for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners/{runner_id}` endpoint.
     *
     * Gets a specific self-hosted runner configured in an enterprise.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-a-self-hosted-runner-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn enterprise_admin_get_self_hosted_runner_for_enterprise(&self, enterprise: &str, runner_id: i64) -> Result<types::Runner> {
        let url = format!(
            "/enterprises/{}/actions/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a self-hosted runner from an enterprise.
     *
     * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runners/{runner_id}` endpoint.
     *
     * Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-self-hosted-runner-from-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn enterprise_admin_delete_self_hosted_runner_from_enterprise(&self, enterprise: &str, runner_id: i64) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get the audit log for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/audit-log` endpoint.
     *
     * Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and you must use an access token with the `admin:enterprise` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-the-audit-log-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `phrase: &str` -- A search phrase. For more information, see [Searching the audit log](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization#searching-the-audit-log).
     * * `include: crate::types::AuditLogInclude` -- The event types to include:
     *   
     *   - `web` - returns web (non-Git) events
     *   - `git` - returns Git events
     *   - `all` - returns both web and Git events
     *   
     *   The default is `web`.
     * * `after: &str` -- A cursor, as given in the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events after this cursor.
     * * `before: &str` -- A cursor, as given in the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events before this cursor.
     * * `order: crate::types::AuditLogOrder` -- The order of audit log events. To list newest events first, specify `desc`. To list oldest events first, specify `asc`.
     *   
     *   The default is `desc`.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn enterprise_admin_get_audit_log(
        &self,
        enterprise: &str,
        phrase: &str,
        include: crate::types::AuditLogInclude,
        after: &str,
        before: &str,
        order: crate::types::AuditLogOrder,
        page: i64,
        per_page: i64,
    ) -> Result<Vec<types::AuditLogEvent>> {
        let url = format!(
            "/enterprises/{}/audit-log?after={}&before={}&include={}&order={}&page={}&per_page={}&phrase={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            after.to_string(),
            before.to_string(),
            include,
            order,
            format!("{}", page),
            format!("{}", per_page),
            phrase.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get GitHub Actions billing for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/actions` endpoint.
     *
     * Gets the summary of the free and paid GitHub Actions minutes used.
     *
     * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * The authenticated user must be an enterprise admin.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn billing_get_github_actions_billing_ghe(&self, enterprise: &str) -> Result<types::ActionsBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get GitHub Packages billing for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/packages` endpoint.
     *
     * Gets the free and paid storage used for GitHub Packages in gigabytes.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * The authenticated user must be an enterprise admin.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn billing_get_github_packages_billing_ghe(&self, enterprise: &str) -> Result<types::PackagesBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/packages",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get shared storage billing for an enterprise.
     *
     * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/shared-storage` endpoint.
     *
     * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * The authenticated user must be an enterprise admin.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn billing_get_shared_storage_billing_ghe(&self, enterprise: &str) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List public events.
     *
     * This function performs a `GET` to the `/events` endpoint.
     *
     * We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-public-events>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_public_events(&self, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!("/events?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Get feeds.
     *
     * This function performs a `GET` to the `/feeds` endpoint.
     *
     * GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:
     *
     * *   **Timeline**: The GitHub global public timeline
     * *   **User**: The public timeline for any user, using [URI template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia)
     * *   **Current user public**: The public timeline for the authenticated user
     * *   **Current user**: The private timeline for the authenticated user
     * *   **Current user actor**: The private timeline for activity created by the authenticated user
     * *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
     * *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.
     *
     * **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#get-feeds>
     */
    pub async fn activity_get_feeds(&self) -> Result<types::Feed> {
        let url = "/feeds".to_string();
        self.get(&url).await
    }

    /**
     * List gists for the authenticated user.
     *
     * This function performs a `GET` to the `/gists` endpoint.
     *
     * Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-gists-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list(&self, since: DateTime<Utc>, per_page: i64, page: i64) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a gist.
     *
     * This function performs a `POST` to the `/gists` endpoint.
     *
     * Allows you to add a new gist with one or more files.
     *
     * **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
     *
     * FROM: <https://docs.github.com/rest/reference/gists#create-a-gist>
     */
    pub async fn gists_create(&self, body: &types::GistsCreateRequest) -> Result<types::GistSimple> {
        let url = "/gists".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List public gists.
     *
     * This function performs a `GET` to the `/gists/public` endpoint.
     *
     * List public gists sorted by most recently updated to least recently updated.
     *
     * Note: With [pagination](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-public-gists>
     *
     * **Parameters:**
     *
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_public(&self, since: DateTime<Utc>, per_page: i64, page: i64) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists/public?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List starred gists.
     *
     * This function performs a `GET` to the `/gists/starred` endpoint.
     *
     * List the authenticated user's starred gists:
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-starred-gists>
     *
     * **Parameters:**
     *
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_starred(&self, since: DateTime<Utc>, per_page: i64, page: i64) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists/starred?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a gist.
     *
     * This function performs a `GET` to the `/gists/{gist_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_get(&self, gist_id: &str) -> Result<types::GistSimple> {
        let url = format!("/gists/{}", progenitor_support::encode_path(&gist_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a gist.
     *
     * This function performs a `DELETE` to the `/gists/{gist_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#delete-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_delete(&self, gist_id: &str) -> Result<()> {
        let url = format!("/gists/{}", progenitor_support::encode_path(&gist_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update a gist.
     *
     * This function performs a `PATCH` to the `/gists/{gist_id}` endpoint.
     *
     * Allows you to update or delete a gist file and rename gist files. Files from the previous version of the gist that aren't explicitly changed during an edit are unchanged.
     *
     * FROM: <https://docs.github.com/rest/reference/gists/#update-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_update(&self, gist_id: &str, body: &types::GistsUpdateRequest) -> Result<types::GistSimple> {
        let url = format!("/gists/{}", progenitor_support::encode_path(&gist_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List gist comments.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/comments` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-gist-comments>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_comments(&self, gist_id: &str, per_page: i64, page: i64) -> Result<Vec<types::GistComment>> {
        let url = format!(
            "/gists/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a gist comment.
     *
     * This function performs a `POST` to the `/gists/{gist_id}/comments` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#create-a-gist-comment>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_create_comment(&self, gist_id: &str, body: &types::GistsCreateCommentRequest) -> Result<types::GistComment> {
        let url = format!("/gists/{}/comments", progenitor_support::encode_path(&gist_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a gist comment.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist-comment>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn gists_get_comment(&self, gist_id: &str, comment_id: i64) -> Result<types::GistComment> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a gist comment.
     *
     * This function performs a `DELETE` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#delete-a-gist-comment>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn gists_delete_comment(&self, gist_id: &str, comment_id: i64) -> Result<()> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a gist comment.
     *
     * This function performs a `PATCH` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#update-a-gist-comment>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn gists_update_comment(&self, gist_id: &str, comment_id: i64, body: &types::GistsCreateCommentRequest) -> Result<types::GistComment> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List gist commits.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/commits` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-gist-commits>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_commits(&self, gist_id: &str, per_page: i64, page: i64) -> Result<Vec<types::GistCommit>> {
        let url = format!(
            "/gists/{}/commits?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List gist forks.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/forks` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-gist-forks>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_forks(&self, gist_id: &str, per_page: i64, page: i64) -> Result<Vec<types::GistSimple>> {
        let url = format!(
            "/gists/{}/forks?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Fork a gist.
     *
     * This function performs a `POST` to the `/gists/{gist_id}/forks` endpoint.
     *
     * **Note**: This was previously `/gists/:gist_id/fork`.
     *
     * FROM: <https://docs.github.com/rest/reference/gists#fork-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_fork(&self, gist_id: &str) -> Result<types::BaseGist> {
        let url = format!("/gists/{}/forks", progenitor_support::encode_path(&gist_id.to_string()),);

        self.post(&url, None).await
    }

    /**
     * Check if a gist is starred.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/star` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#check-if-a-gist-is-starred>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_check_is_starred(&self, gist_id: &str) -> Result<()> {
        let url = format!("/gists/{}/star", progenitor_support::encode_path(&gist_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Star a gist.
     *
     * This function performs a `PUT` to the `/gists/{gist_id}/star` endpoint.
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/gists#star-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_star(&self, gist_id: &str) -> Result<()> {
        let url = format!("/gists/{}/star", progenitor_support::encode_path(&gist_id.to_string()),);

        self.put(&url, None).await
    }

    /**
     * Unstar a gist.
     *
     * This function performs a `DELETE` to the `/gists/{gist_id}/star` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#unstar-a-gist>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     */
    pub async fn gists_unstar(&self, gist_id: &str) -> Result<()> {
        let url = format!("/gists/{}/star", progenitor_support::encode_path(&gist_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Get a gist revision.
     *
     * This function performs a `GET` to the `/gists/{gist_id}/{sha}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist-revision>
     *
     * **Parameters:**
     *
     * * `gist_id: &str` -- gist_id parameter.
     * * `sha: &str`
     */
    pub async fn gists_get_revision(&self, gist_id: &str, sha: &str) -> Result<types::GistSimple> {
        let url = format!(
            "/gists/{}/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&sha.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get all gitignore templates.
     *
     * This function performs a `GET` to the `/gitignore/templates` endpoint.
     *
     * List all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
     *
     * FROM: <https://docs.github.com/rest/reference/gitignore#get-all-gitignore-templates>
     */
    pub async fn gitignore_get_all_templates(&self) -> Result<Vec<String>> {
        let url = "/gitignore/templates".to_string();
        self.get_all_pages(&url).await
    }

    /**
     * Get a gitignore template.
     *
     * This function performs a `GET` to the `/gitignore/templates/{name}` endpoint.
     *
     * The API also allows fetching the source of a single template.
     * Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw contents.
     *
     * FROM: <https://docs.github.com/rest/reference/gitignore#get-a-gitignore-template>
     *
     * **Parameters:**
     *
     * * `name: &str`
     */
    pub async fn gitignore_get_template(&self, name: &str) -> Result<types::GitignoreTemplate> {
        let url = format!("/gitignore/templates/{}", progenitor_support::encode_path(&name.to_string()),);

        self.get(&url).await
    }

    /**
     * List repositories accessible to the app installation.
     *
     * This function performs a `GET` to the `/installation/repositories` endpoint.
     *
     * List repositories that an app installation can access.
     *
     * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-repositories-accessible-to-the-app-installation>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_repos_accessible_to_installation(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetAppsListInstallationReposOkResponse> {
        let url = format!(
            "/installation/repositories?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Revoke an installation access token.
     *
     * This function performs a `DELETE` to the `/installation/token` endpoint.
     *
     * Revokes the installation token you're using to authenticate as an installation and access this endpoint.
     *
     * Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)" endpoint.
     *
     * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#revoke-an-installation-access-token>
     */
    pub async fn apps_revoke_installation_access_token(&self) -> Result<()> {
        let url = "/installation/token".to_string();
        self.delete(&url, None).await
    }

    /**
     * List issues assigned to the authenticated user.
     *
     * This function performs a `GET` to the `/issues` endpoint.
     *
     * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
     * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
     * necessarily assigned to you.
     *
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-issues-assigned-to-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `filter: crate::types::IssuesListFilter` -- Indicates which sorts of issues to return. Can be one of:  
     *  \* `assigned`: Issues assigned to you  
     *  \* `created`: Issues created by you  
     *  \* `mentioned`: Issues mentioning you  
     *  \* `subscribed`: Issues you're subscribed to updates for  
     *  \* `all`: All issues the authenticated user can see, regardless of participation or creation.
     * * `state: crate::types::IssuesListState` -- Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
     * * `labels: &str` -- A list of comma separated label names. Example: `bug,ui,@high`.
     * * `sort: crate::types::IssuesListSort` -- What to sort results by. Can be either `created`, `updated`, `comments`.
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `collab: bool`
     * * `orgs: bool`
     * * `owned: bool`
     * * `pulls: bool`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list(
        &self,
        filter: crate::types::IssuesListFilter,
        state: crate::types::IssuesListState,
        labels: &str,
        sort: crate::types::IssuesListSort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        collab: bool,
        orgs: bool,
        owned: bool,
        pulls: bool,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!(
            "/issues?collab={}&direction={}&filter={}&labels={}&orgs={}&owned={}&page={}&per_page={}&pulls={}&since={}&sort={}&state={}",
            format!("{}", collab),
            direction,
            filter,
            labels.to_string(),
            format!("{}", orgs),
            format!("{}", owned),
            format!("{}", page),
            format!("{}", per_page),
            format!("{}", pulls),
            since.to_rfc3339(),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get all commonly used licenses.
     *
     * This function performs a `GET` to the `/licenses` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/licenses#get-all-commonly-used-licenses>
     *
     * **Parameters:**
     *
     * * `featured: bool`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn licenses_get_all_commonly_used(&self, featured: bool, per_page: i64, page: i64) -> Result<Vec<types::License>> {
        let url = format!(
            "/licenses?featured={}&page={}&per_page={}",
            format!("{}", featured),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a license.
     *
     * This function performs a `GET` to the `/licenses/{license}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/licenses#get-a-license>
     *
     * **Parameters:**
     *
     * * `license: &str`
     */
    pub async fn licenses_get(&self, license: &str) -> Result<types::License> {
        let url = format!("/licenses/{}", progenitor_support::encode_path(&license.to_string()),);

        self.get(&url).await
    }

    /**
     * Render a Markdown document.
     *
     * This function performs a `POST` to the `/markdown` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/markdown#render-a-markdown-document>
     */
    pub async fn markdown_render(&self, body: &types::MarkdownRenderRequest) -> Result<String> {
        let url = "/markdown".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Render a Markdown document in raw mode.
     *
     * This function performs a `POST` to the `/markdown/raw` endpoint.
     *
     * You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain format like a README.md file. Markdown content must be 400 KB or less.
     *
     * FROM: <https://docs.github.com/rest/reference/markdown#render-a-markdown-document-in-raw-mode>
     */
    pub async fn markdown_render_raw<T: Into<reqwest::Body>>(&self, body: T) -> Result<String> {
        let url = "/markdown/raw".to_string();
        self.post(&url, Some(body.into())).await
    }

    /**
     * Get a subscription plan for an account.
     *
     * This function performs a `GET` to the `/marketplace_listing/accounts/{account_id}` endpoint.
     *
     * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-a-subscription-plan-for-an-account>
     *
     * **Parameters:**
     *
     * * `account_id: i64` -- account_id parameter.
     */
    pub async fn apps_get_subscription_plan_for_account(&self, account_id: i64) -> Result<types::MarketplacePurchase> {
        let url = format!(
            "/marketplace_listing/accounts/{}",
            progenitor_support::encode_path(&account_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List plans.
     *
     * This function performs a `GET` to the `/marketplace_listing/plans` endpoint.
     *
     * Lists all plans that are part of your GitHub Marketplace listing.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-plans>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_plans(&self, per_page: i64, page: i64) -> Result<Vec<types::MarketplaceListingPlan>> {
        let url = format!(
            "/marketplace_listing/plans?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List accounts for a plan.
     *
     * This function performs a `GET` to the `/marketplace_listing/plans/{plan_id}/accounts` endpoint.
     *
     * Returns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-accounts-for-a-plan>
     *
     * **Parameters:**
     *
     * * `plan_id: i64` -- plan_id parameter.
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- To return the oldest accounts first, set to `asc`. Can be one of `asc` or `desc`. Ignored without the `sort` parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_accounts_for_plan(
        &self,
        plan_id: i64,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplacePurchase>> {
        let url = format!(
            "/marketplace_listing/plans/{}/accounts?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&plan_id.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a subscription plan for an account (stubbed).
     *
     * This function performs a `GET` to the `/marketplace_listing/stubbed/accounts/{account_id}` endpoint.
     *
     * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-a-subscription-plan-for-an-account-stubbed>
     *
     * **Parameters:**
     *
     * * `account_id: i64` -- account_id parameter.
     */
    pub async fn apps_get_subscription_plan_for_account_stubbed(&self, account_id: i64) -> Result<types::MarketplacePurchase> {
        let url = format!(
            "/marketplace_listing/stubbed/accounts/{}",
            progenitor_support::encode_path(&account_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List plans (stubbed).
     *
     * This function performs a `GET` to the `/marketplace_listing/stubbed/plans` endpoint.
     *
     * Lists all plans that are part of your GitHub Marketplace listing.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-plans-stubbed>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_plans_stubbed(&self, per_page: i64, page: i64) -> Result<Vec<types::MarketplaceListingPlan>> {
        let url = format!(
            "/marketplace_listing/stubbed/plans?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List accounts for a plan (stubbed).
     *
     * This function performs a `GET` to the `/marketplace_listing/stubbed/plans/{plan_id}/accounts` endpoint.
     *
     * Returns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
     *
     * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-accounts-for-a-plan-stubbed>
     *
     * **Parameters:**
     *
     * * `plan_id: i64` -- plan_id parameter.
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- To return the oldest accounts first, set to `asc`. Can be one of `asc` or `desc`. Ignored without the `sort` parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_accounts_for_plan_stubbed(
        &self,
        plan_id: i64,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplacePurchase>> {
        let url = format!(
            "/marketplace_listing/stubbed/plans/{}/accounts?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&plan_id.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get GitHub meta information.
     *
     * This function performs a `GET` to the `/meta` endpoint.
     *
     * Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://help.github.com/articles/about-github-s-ip-addresses/)."
     *
     * **Note:** The IP addresses shown in the documentation's response are only example values. You must always query the API directly to get the latest list of IP addresses.
     *
     * FROM: <https://docs.github.com/rest/reference/meta#get-github-meta-information>
     */
    pub async fn meta_get(&self) -> Result<types::ApiOverview> {
        let url = "/meta".to_string();
        self.get(&url).await
    }

    /**
     * List public events for a network of repositories.
     *
     * This function performs a `GET` to the `/networks/{owner}/{repo}/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-for-a-network-of-repositories>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_public_events_for_repo_network(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/networks/{}/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List notifications for the authenticated user.
     *
     * This function performs a `GET` to the `/notifications` endpoint.
     *
     * List all notifications for the current user, sorted by most recently updated.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `all: bool` -- If `true`, show notifications marked as read.
     * * `participating: bool` -- If `true`, only shows notifications in which the user is directly participating or mentioned.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `before: DateTime<Utc>` -- Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_notifications_for_authenticated_user(
        &self,
        all: bool,
        participating: bool,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Thread>> {
        let url = format!(
            "/notifications?all={}&before={}&page={}&participating={}&per_page={}&since={}",
            format!("{}", all),
            before.to_rfc3339(),
            format!("{}", page),
            format!("{}", participating),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Mark notifications as read.
     *
     * This function performs a `PUT` to the `/notifications` endpoint.
     *
     * Marks all notifications as "read" removes it from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#mark-notifications-as-read>
     */
    pub async fn activity_mark_notifications_as_read(
        &self,
        body: &types::ActivityMarkNotificationsAsReadRequest,
    ) -> Result<types::PostReposCreateDeploymentAcceptedResponse> {
        let url = "/notifications".to_string();
        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a thread.
     *
     * This function performs a `GET` to the `/notifications/threads/{thread_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#get-a-thread>
     *
     * **Parameters:**
     *
     * * `thread_id: i64` -- thread_id parameter.
     */
    pub async fn activity_get_thread(&self, thread_id: i64) -> Result<types::Thread> {
        let url = format!("/notifications/threads/{}", progenitor_support::encode_path(&thread_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Mark a thread as read.
     *
     * This function performs a `PATCH` to the `/notifications/threads/{thread_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#mark-a-thread-as-read>
     *
     * **Parameters:**
     *
     * * `thread_id: i64` -- thread_id parameter.
     */
    pub async fn activity_mark_thread_as_read(&self, thread_id: i64) -> Result<()> {
        let url = format!("/notifications/threads/{}", progenitor_support::encode_path(&thread_id.to_string()),);

        self.patch(&url, None).await
    }

    /**
     * Get a thread subscription for the authenticated user.
     *
     * This function performs a `GET` to the `/notifications/threads/{thread_id}/subscription` endpoint.
     *
     * This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
     *
     * Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#get-a-thread-subscription-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `thread_id: i64` -- thread_id parameter.
     */
    pub async fn activity_get_thread_subscription_for_authenticated_user(&self, thread_id: i64) -> Result<types::ThreadSubscription> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set a thread subscription.
     *
     * This function performs a `PUT` to the `/notifications/threads/{thread_id}/subscription` endpoint.
     *
     * If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
     *
     * You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
     *
     * Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#set-a-thread-subscription>
     *
     * **Parameters:**
     *
     * * `thread_id: i64` -- thread_id parameter.
     */
    pub async fn activity_set_thread_subscription(
        &self,
        thread_id: i64,
        body: &types::ActivitySetThreadSubscriptionRequest,
    ) -> Result<types::ThreadSubscription> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a thread subscription.
     *
     * This function performs a `DELETE` to the `/notifications/threads/{thread_id}/subscription` endpoint.
     *
     * Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#delete-a-thread-subscription>
     *
     * **Parameters:**
     *
     * * `thread_id: i64` -- thread_id parameter.
     */
    pub async fn activity_delete_thread_subscription(&self, thread_id: i64) -> Result<()> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get Octocat.
     *
     * This function performs a `GET` to the `/octocat` endpoint.
     *
     * Get the octocat as ASCII art
     *
     * FROM: <https://docs.github.com/rest/reference/meta#get-octocat>
     *
     * **Parameters:**
     *
     * * `s: &str` -- The words to show in Octocat's speech bubble.
     */
    pub async fn meta_get_octocat(&self, s: &str) -> Result<String> {
        let url = format!("/octocat?s={}", s.to_string(),);

        self.get(&url).await
    }

    /**
     * List organizations.
     *
     * This function performs a `GET` to the `/organizations` endpoint.
     *
     * Lists all organizations, in the order that they were created on GitHub.
     *
     * **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of organizations.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations>
     *
     * **Parameters:**
     *
     * * `since: i64` -- An organization ID. Only return organizations with an ID greater than this ID.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn orgs_list(&self, since: i64, per_page: i64) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!("/organizations?per_page={}&since={}", format!("{}", per_page), format!("{}", since),);

        self.get_all_pages(&url).await
    }

    /**
     * Get an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}` endpoint.
     *
     * To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://help.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
     *
     * GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_get(&self, org: &str) -> Result<types::OrganizationFull> {
        let url = format!("/orgs/{}", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Update an organization.
     *
     * This function performs a `PATCH` to the `/orgs/{org}` endpoint.
     *
     * **Parameter Deprecation Notice:** GitHub will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).
     *
     * Enables an authenticated organization owner with the `admin:org` scope to update the organization's profile and member privileges.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs/#update-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_update(&self, org: &str, body: &types::OrgsUpdateRequest) -> Result<types::OrganizationFull> {
        let url = format!("/orgs/{}", progenitor_support::encode_path(&org.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get GitHub Actions permissions for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/permissions` endpoint.
     *
     * Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-github-actions-permissions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_get_github_actions_permissions_organization(&self, org: &str) -> Result<types::ActionsOrganizationPermissions> {
        let url = format!("/orgs/{}/actions/permissions", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Set GitHub Actions permissions for an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/permissions` endpoint.
     *
     * Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
     *
     * If the organization belongs to an enterprise that has set restrictive permissions at the enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them for the organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-github-actions-permissions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_set_github_actions_permissions_organization(
        &self,
        org: &str,
        body: &types::ActionsSetGithubPermissionsOrganizationRequest,
    ) -> Result<()> {
        let url = format!("/orgs/{}/actions/permissions", progenitor_support::encode_path(&org.to_string()),);

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List selected repositories enabled for GitHub Actions in an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/permissions/repositories` endpoint.
     *
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-selected-repositories-enabled-for-github-actions-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_selected_repositories_enabled_github_actions_organization(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelectedRepositoriesEnabledGithubOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set selected repositories enabled for GitHub Actions in an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/repositories` endpoint.
     *
     * Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-selected-repositories-enabled-for-github-actions-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_set_selected_repositories_enabled_github_actions_organization(
        &self,
        org: &str,
        body: &types::ActionsSetSelectedRepositoriesEnabledGithubOrganizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Enable a selected repository for GitHub Actions in an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/repositories/{repository_id}` endpoint.
     *
     * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#enable-a-selected-repository-for-github-actions-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `repository_id: i64`
     */
    pub async fn actions_enable_selected_repository_github_actions_organization(&self, org: &str, repository_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Disable a selected repository for GitHub Actions in an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/permissions/repositories/{repository_id}` endpoint.
     *
     * Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#disable-a-selected-repository-for-github-actions-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `repository_id: i64`
     */
    pub async fn actions_disable_selected_repository_github_actions_organization(&self, org: &str, repository_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get allowed actions for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/permissions/selected-actions` endpoint.
     *
     * Gets the selected actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-allowed-actions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_get_allowed_actions_organization(&self, org: &str) -> Result<types::SelectedActions> {
        let url = format!(
            "/orgs/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set allowed actions for an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/selected-actions` endpoint.
     *
     * Sets the actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * If the organization belongs to an enterprise that has `selected` actions set at the enterprise level, then you cannot override any of the enterprise's allowed actions settings.
     *
     * To use the `patterns_allowed` setting for private repositories, the organization must belong to an enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories in the organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-allowed-actions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_set_allowed_actions_organization(&self, org: &str, body: &types::SelectedActions) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List self-hosted runner groups for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runner-groups-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_self_hosted_runner_groups_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelfHostedRunnerGroupsOrgOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runner-groups?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Create a self-hosted runner group for an organization.
     *
     * This function performs a `POST` to the `/orgs/{org}/actions/runner-groups` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Creates a new self-hosted runner group for an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-self-hosted-runner-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_create_self_hosted_runner_group_for_org(
        &self,
        org: &str,
        body: &types::ActionsCreateSelfHostedRunnerGroupOrgRequest,
    ) -> Result<types::RunnerGroupsOrg> {
        let url = format!("/orgs/{}/actions/runner-groups", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a self-hosted runner group for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Gets a specific self-hosted runner group for an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn actions_get_self_hosted_runner_group_for_org(&self, org: &str, runner_group_id: i64) -> Result<types::RunnerGroupsOrg> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a self-hosted runner group from an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Deletes a self-hosted runner group for an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-group-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn actions_delete_self_hosted_runner_group_from_org(&self, org: &str, runner_group_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a self-hosted runner group for an organization.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Updates the `name` and `visibility` of a self-hosted runner group in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#update-a-self-hosted-runner-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn actions_update_self_hosted_runner_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::ActionsUpdateSelfHostedRunnerGroupOrgRequest,
    ) -> Result<types::RunnerGroupsOrg> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List repository access to a self-hosted runner group in an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Lists the repositories with access to a self-hosted runner group configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-repository-access-to-a-self-hosted-runner-group-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn actions_list_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        page: i64,
        per_page: i64,
    ) -> Result<types::GetActionsListRepoAccessSelfHostedRunnerGroupInOrgOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set repository access for a self-hosted runner group in an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-repository-access-to-a-self-hosted-runner-group-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn actions_set_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::ActionsSetRepoAccessSelfHostedRunnerGroupInOrgRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add repository access to a self-hosted runner group in an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     *
     * Adds a repository to the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#add-repository-acess-to-a-self-hosted-runner-group-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `repository_id: i64`
     */
    pub async fn actions_add_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove repository access to a self-hosted runner group in an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     *
     * Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#remove-repository-access-to-a-self-hosted-runner-group-in-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `repository_id: i64`
     */
    pub async fn actions_remove_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List self-hosted runners in a group for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Lists self-hosted runners that are in a specific organization group.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-in-a-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_self_hosted_runners_in_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelfHostedRunnersInGroupOrgOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set self-hosted runners in a group for an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Replaces the list of self-hosted runners that are part of an organization runner group.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-self-hosted-runners-in-a-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     */
    pub async fn actions_set_self_hosted_runners_in_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::ActionsSetSelfHostedRunnersInGroupOrgRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add a self-hosted runner to a group for an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     *
     * Adds a self-hosted runner to a runner group configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#add-a-self-hosted-runner-to-a-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_add_self_hosted_runner_to_group_for_org(&self, org: &str, runner_group_id: i64, runner_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove a self-hosted runner from a group for an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
     *
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     *
     * Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#remove-a-self-hosted-runner-from-a-group-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_group_id: i64` -- Unique identifier of the self-hosted runner group.
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_remove_self_hosted_runner_from_group_for_org(&self, org: &str, runner_group_id: i64, runner_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List self-hosted runners for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runners` endpoint.
     *
     * Lists all self-hosted runners configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_self_hosted_runners_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelfHostedRunnersOrgOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List runner applications for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runners/downloads` endpoint.
     *
     * Lists binaries for the runner application that you can download and run.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-runner-applications-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_list_runner_applications_for_org(&self, org: &str) -> Result<Vec<types::RunnerApplication>> {
        let url = format!("/orgs/{}/actions/runners/downloads", progenitor_support::encode_path(&org.to_string()),);

        self.get_all_pages(&url).await
    }

    /**
     * Create a registration token for an organization.
     *
     * This function performs a `POST` to the `/orgs/{org}/actions/runners/registration-token` endpoint.
     *
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * #### Example using registration token
     *
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/octo-org --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-registration-token-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_create_registration_token_for_org(&self, org: &str) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/orgs/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Create a remove token for an organization.
     *
     * This function performs a `POST` to the `/orgs/{org}/actions/runners/remove-token` endpoint.
     *
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * #### Example using remove token
     *
     * To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
     * endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-remove-token-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_create_remove_token_for_org(&self, org: &str) -> Result<types::AuthenticationToken> {
        let url = format!("/orgs/{}/actions/runners/remove-token", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, None).await
    }

    /**
     * Get a self-hosted runner for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/runners/{runner_id}` endpoint.
     *
     * Gets a specific self-hosted runner configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_get_self_hosted_runner_for_org(&self, org: &str, runner_id: i64) -> Result<types::Runner> {
        let url = format!(
            "/orgs/{}/actions/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a self-hosted runner from an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/runners/{runner_id}` endpoint.
     *
     * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_delete_self_hosted_runner_from_org(&self, org: &str, runner_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List organization secrets.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/secrets` endpoint.
     *
     * Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-organization-secrets>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_org_secrets(&self, org: &str, per_page: i64, page: i64) -> Result<types::GetActionsListOrgSecretsOkResponse> {
        let url = format!(
            "/orgs/{}/actions/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get an organization public key.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/secrets/public-key` endpoint.
     *
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-an-organization-public-key>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn actions_get_org_public_key(&self, org: &str) -> Result<types::ActionsPublicKey> {
        let url = format!("/orgs/{}/actions/secrets/public-key", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Get an organization secret.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
     *
     * Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_get_org_secret(&self, org: &str, secret_name: &str) -> Result<types::OrganizationActionsSecret> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update an organization secret.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
     *
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to
     * use this endpoint.
     *
     * #### Example encrypting a secret using Node.js
     *
     * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
     *
     * ```
     * const sodium = require('tweetsodium');
     *
     * const key = "base64-encoded-public-key";
     * const value = "plain-text-secret";
     *
     * // Convert the message and key to Uint8Array's (Buffer implements that interface)
     * const messageBytes = Buffer.from(value);
     * const keyBytes = Buffer.from(key, 'base64');
     *
     * // Encrypt using LibSodium.
     * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
     *
     * // Base64 the encrypted secret
     * const encrypted = Buffer.from(encryptedBytes).toString('base64');
     *
     * console.log(encrypted);
     * ```
     *
     *
     * #### Example encrypting a secret using Python
     *
     * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
     *
     * ```
     * from base64 import b64encode
     * from nacl import encoding, public
     *
     * def encrypt(public_key: str, secret_value: str) -> str:
     *   """Encrypt a Unicode string using the public key."""
     *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
     *   sealed_box = public.SealedBox(public_key)
     *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
     *   return b64encode(encrypted).decode("utf-8")
     * ```
     *
     * #### Example encrypting a secret using C#
     *
     * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
     *
     * ```
     * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
     * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
     *
     * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     *
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
     * ```
     *
     * #### Example encrypting a secret using Ruby
     *
     * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
     *
     * ```ruby
     * require "rbnacl"
     * require "base64"
     *
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
     * public_key = RbNaCl::PublicKey.new(key)
     *
     * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret")
     *
     * # Print the base64 encoded secret
     * puts Base64.strict_encode64(encrypted_secret)
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_create_or_update_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        body: &types::ActionsCreateUpdateOrgSecretRequest,
    ) -> Result<types::EmptyObject> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an organization secret.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
     *
     * Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_delete_org_secret(&self, org: &str, secret_name: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List selected repositories for an organization secret.
     *
     * This function performs a `GET` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories` endpoint.
     *
     * Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-selected-repositories-for-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn actions_list_selected_repos_for_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        page: i64,
        per_page: i64,
    ) -> Result<types::GetActionsListSelectedReposOrgSecretOkResponse> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Set selected repositories for an organization secret.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories` endpoint.
     *
     * Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-selected-repositories-for-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_set_selected_repos_for_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        body: &types::ActionsSetSelectedReposOrgSecretRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add selected repository to an organization secret.
     *
     * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}` endpoint.
     *
     * Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#add-selected-repository-to-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     * * `repository_id: i64`
     */
    pub async fn actions_add_selected_repo_to_org_secret(&self, org: &str, secret_name: &str, repository_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove selected repository from an organization secret.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}` endpoint.
     *
     * Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `secret_name: &str` -- secret_name parameter.
     * * `repository_id: i64`
     */
    pub async fn actions_remove_selected_repo_from_org_secret(&self, org: &str, secret_name: &str, repository_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get the audit log for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/audit-log` endpoint.
     *
     * Gets the audit log for an organization. For more information, see "[Reviewing the audit log for your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
     *
     * To use this endpoint, you must be an organization owner, and you must use an access token with the `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-audit-log>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `phrase: &str` -- A search phrase. For more information, see [Searching the audit log](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization#searching-the-audit-log).
     * * `include: crate::types::AuditLogInclude` -- The event types to include:
     *   
     *   - `web` - returns web (non-Git) events
     *   - `git` - returns Git events
     *   - `all` - returns both web and Git events
     *   
     *   The default is `web`.
     * * `after: &str` -- A cursor, as given in the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events after this cursor.
     * * `before: &str` -- A cursor, as given in the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events before this cursor.
     * * `order: crate::types::AuditLogOrder` -- The order of audit log events. To list newest events first, specify `desc`. To list oldest events first, specify `asc`.
     *   
     *   The default is `desc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_get_audit_log(
        &self,
        org: &str,
        phrase: &str,
        include: crate::types::AuditLogInclude,
        after: &str,
        before: &str,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::AuditLogEvent>> {
        let url = format!(
            "/orgs/{}/audit-log?after={}&before={}&include={}&order={}&page={}&per_page={}&phrase={}",
            progenitor_support::encode_path(&org.to_string()),
            after.to_string(),
            before.to_string(),
            include,
            order,
            format!("{}", page),
            format!("{}", per_page),
            phrase.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List users blocked by an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/blocks` endpoint.
     *
     * List the users blocked by an organization.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-users-blocked-by-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_list_blocked_users(&self, org: &str) -> Result<Vec<types::User>> {
        let url = format!("/orgs/{}/blocks", progenitor_support::encode_path(&org.to_string()),);

        self.get_all_pages(&url).await
    }

    /**
     * Check if a user is blocked by an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#check-if-a-user-is-blocked-by-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_check_blocked_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Block a user from an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#block-a-user-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_block_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Unblock a user from an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#unblock-a-user-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_unblock_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List SAML SSO authorizations for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/credential-authorizations` endpoint.
     *
     * Listing and deleting credential authorizations is available to organizations with GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products).
     *
     * An authenticated organization owner with the `read:org` scope can list all credential authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either personal access tokens or SSH keys that organization members have authorized for the organization. For more information, see [About authentication with SAML single sign-on](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on).
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-saml-sso-authorizations-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_list_saml_sso_authorizations(&self, org: &str) -> Result<Vec<types::CredentialAuthorization>> {
        let url = format!("/orgs/{}/credential-authorizations", progenitor_support::encode_path(&org.to_string()),);

        self.get_all_pages(&url).await
    }

    /**
     * Remove a SAML SSO authorization for an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/credential-authorizations/{credential_id}` endpoint.
     *
     * Listing and deleting credential authorizations is available to organizations with GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products).
     *
     * An authenticated organization owner with the `admin:org` scope can remove a credential authorization for an organization that uses SAML SSO. Once you remove someone's credential authorization, they will need to create a new personal access token or SSH key and authorize it for the organization they want to access.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#remove-a-saml-sso-authorization-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `credential_id: i64`
     */
    pub async fn orgs_remove_saml_sso_authorization(&self, org: &str, credential_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/credential-authorizations/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&credential_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List public organization events.
     *
     * This function performs a `GET` to the `/orgs/{org}/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-public-organization-events>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_public_org_events(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/orgs/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List failed organization invitations.
     *
     * This function performs a `GET` to the `/orgs/{org}/failed_invitations` endpoint.
     *
     * The return hash contains `failed_at` and `failed_reason` fields which represent the time at which the invitation failed and the reason for the failure.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-failed-organization-invitations>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_failed_invitations(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/failed_invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organization webhooks.
     *
     * This function performs a `GET` to the `/orgs/{org}/hooks` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-webhooks>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_webhooks(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::OrgHook>> {
        let url = format!(
            "/orgs/{}/hooks?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an organization webhook.
     *
     * This function performs a `POST` to the `/orgs/{org}/hooks` endpoint.
     *
     * Here's how you can create a hook that posts payloads in JSON format:
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#create-an-organization-webhook>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_create_webhook(&self, org: &str, body: &types::OrgsCreateWebhookRequest) -> Result<types::OrgHook> {
        let url = format!("/orgs/{}/hooks", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get an organization webhook.
     *
     * This function performs a `GET` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
     *
     * Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)."
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization-webhook>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_get_webhook(&self, org: &str, hook_id: i64) -> Result<types::OrgHook> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete an organization webhook.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#delete-an-organization-webhook>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_delete_webhook(&self, org: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an organization webhook.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
     *
     * Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)."
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#update-an-organization-webhook>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_update_webhook(&self, org: &str, hook_id: i64, body: &types::OrgsUpdateWebhookRequest) -> Result<types::OrgHook> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a webhook configuration for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/hooks/{hook_id}/config` endpoint.
     *
     * Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/reference/orgs#get-an-organization-webhook)."
     *
     * Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:read` permission.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-a-webhook-configuration-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_get_webhook_config_for_org(&self, org: &str, hook_id: i64) -> Result<types::WebhookConfig> {
        let url = format!(
            "/orgs/{}/hooks/{}/config",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a webhook configuration for an organization.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/hooks/{hook_id}/config` endpoint.
     *
     * Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/reference/orgs#update-an-organization-webhook)."
     *
     * Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:write` permission.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#update-a-webhook-configuration-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_update_webhook_config_for_org(
        &self,
        org: &str,
        hook_id: i64,
        body: &types::AppsUpdateWebhookConfigAppRequest,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/orgs/{}/hooks/{}/config",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Ping an organization webhook.
     *
     * This function performs a `POST` to the `/orgs/{org}/hooks/{hook_id}/pings` endpoint.
     *
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#ping-an-organization-webhook>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `hook_id: i64`
     */
    pub async fn orgs_ping_webhook(&self, org: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/hooks/{}/pings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get an organization installation for the authenticated app.
     *
     * This function performs a `GET` to the `/orgs/{org}/installation` endpoint.
     *
     * Enables an authenticated GitHub App to find the organization's installation information.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-an-organization-installation-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn apps_get_org_installation(&self, org: &str) -> Result<types::Installation> {
        let url = format!("/orgs/{}/installation", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * List app installations for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/installations` endpoint.
     *
     * Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed on repositories in the organization. You must be an organization owner with `admin:read` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-app-installations-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_app_installations(&self, org: &str, per_page: i64, page: i64) -> Result<types::GetAppsListInstallationsOkResponse> {
        let url = format!(
            "/orgs/{}/installations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get interaction restrictions for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/interaction-limits` endpoint.
     *
     * Shows which type of GitHub user can interact with this organization and when the restriction expires. If there is no restrictions, you will see an empty response.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn interactions_get_restrictions_for_org(&self, org: &str) -> Result<types::InteractionLimitResponse> {
        let url = format!("/orgs/{}/interaction-limits", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Set interaction restrictions for an organization.
     *
     * This function performs a `PUT` to the `/orgs/{org}/interaction-limits` endpoint.
     *
     * Temporarily restricts interactions to a certain type of GitHub user in any public repository in the given organization. You must be an organization owner to set these restrictions. Setting the interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories owned by the organization.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn interactions_set_restrictions_for_org(&self, org: &str, body: &types::InteractionLimit) -> Result<types::InteractionLimitResponse> {
        let url = format!("/orgs/{}/interaction-limits", progenitor_support::encode_path(&org.to_string()),);

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove interaction restrictions for an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/interaction-limits` endpoint.
     *
     * Removes all interaction restrictions from public repositories in the given organization. You must be an organization owner to remove restrictions.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn interactions_remove_restrictions_for_org(&self, org: &str) -> Result<()> {
        let url = format!("/orgs/{}/interaction-limits", progenitor_support::encode_path(&org.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * List pending organization invitations.
     *
     * This function performs a `GET` to the `/orgs/{org}/invitations` endpoint.
     *
     * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-pending-organization-invitations>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_pending_invitations(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an organization invitation.
     *
     * This function performs a `POST` to the `/orgs/{org}/invitations` endpoint.
     *
     * Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#create-an-organization-invitation>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_create_invitation(&self, org: &str, body: &types::OrgsCreateInvitationRequest) -> Result<types::OrganizationInvitation> {
        let url = format!("/orgs/{}/invitations", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Cancel an organization invitation.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/invitations/{invitation_id}` endpoint.
     *
     * Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#cancel-an-organization-invitation>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `invitation_id: i64` -- invitation_id parameter.
     */
    pub async fn orgs_cancel_invitation(&self, org: &str, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/invitations/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List organization invitation teams.
     *
     * This function performs a `GET` to the `/orgs/{org}/invitations/{invitation_id}/teams` endpoint.
     *
     * List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-invitation-teams>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `invitation_id: i64` -- invitation_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_invitation_teams(&self, org: &str, invitation_id: i64, per_page: i64, page: i64) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/invitations/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organization issues assigned to the authenticated user.
     *
     * This function performs a `GET` to the `/orgs/{org}/issues` endpoint.
     *
     * List issues in an organization assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-organization-issues-assigned-to-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `filter: crate::types::IssuesListFilter` -- Indicates which sorts of issues to return. Can be one of:  
     *  \* `assigned`: Issues assigned to you  
     *  \* `created`: Issues created by you  
     *  \* `mentioned`: Issues mentioning you  
     *  \* `subscribed`: Issues you're subscribed to updates for  
     *  \* `all`: All issues the authenticated user can see, regardless of participation or creation.
     * * `state: crate::types::IssuesListState` -- Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
     * * `labels: &str` -- A list of comma separated label names. Example: `bug,ui,@high`.
     * * `sort: crate::types::IssuesListSort` -- What to sort results by. Can be either `created`, `updated`, `comments`.
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_for_org(
        &self,
        org: &str,
        filter: crate::types::IssuesListFilter,
        state: crate::types::IssuesListState,
        labels: &str,
        sort: crate::types::IssuesListSort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!(
            "/orgs/{}/issues?direction={}&filter={}&labels={}&page={}&per_page={}&since={}&sort={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
            direction,
            filter,
            labels.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organization members.
     *
     * This function performs a `GET` to the `/orgs/{org}/members` endpoint.
     *
     * List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-members>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `filter: crate::types::OrgsListMembersFilter` -- Filter members returned in the list. Can be one of:  
     *  \* `2fa_disabled` - Members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled. Available for organization owners.  
     *  \* `all` - All members the authenticated user can see.
     * * `role: crate::types::OrgsListMembersRole` -- Filter members returned by their role. Can be one of:  
     *  \* `all` - All members of the organization, regardless of role.  
     *  \* `admin` - Organization owners.  
     *  \* `member` - Non-owner organization members.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_members(
        &self,
        org: &str,
        filter: crate::types::OrgsListMembersFilter,
        role: crate::types::OrgsListMembersRole,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/orgs/{}/members?filter={}&page={}&per_page={}&role={}",
            progenitor_support::encode_path(&org.to_string()),
            filter,
            format!("{}", page),
            format!("{}", per_page),
            role,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check organization membership for a user.
     *
     * This function performs a `GET` to the `/orgs/{org}/members/{username}` endpoint.
     *
     * Check if a user is, publicly or privately, a member of the organization.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#check-organization-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_check_membership_for_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Remove an organization member.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/members/{username}` endpoint.
     *
     * Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#remove-an-organization-member>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_remove_member(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get organization membership for a user.
     *
     * This function performs a `GET` to the `/orgs/{org}/memberships/{username}` endpoint.
     *
     * In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_get_membership_for_user(&self, org: &str, username: &str) -> Result<types::OrgMembership> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set organization membership for a user.
     *
     * This function performs a `PUT` to the `/orgs/{org}/memberships/{username}` endpoint.
     *
     * Only authenticated organization owners can add a member to the organization or update the member's role.
     *
     * *   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.
     *     
     * *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.
     *
     * **Rate limits**
     *
     * To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#set-organization-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_set_membership_for_user(
        &self,
        org: &str,
        username: &str,
        body: &types::OrgsSetMembershipUserRequest,
    ) -> Result<types::OrgMembership> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove organization membership for a user.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/memberships/{username}` endpoint.
     *
     * In order to remove a user's membership with an organization, the authenticated user must be an organization owner.
     *
     * If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#remove-organization-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_remove_membership_for_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List organization migrations.
     *
     * This function performs a `GET` to the `/orgs/{org}/migrations` endpoint.
     *
     * Lists the most recent migrations.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#list-organization-migrations>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `exclude: &[String]` -- Exclude attributes from the API response to improve performance.
     */
    pub async fn migrations_list_for_org(&self, org: &str, per_page: i64, page: i64, exclude: &[String]) -> Result<Vec<types::Migration>> {
        let url = format!(
            "/orgs/{}/migrations?exclude={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            exclude.join(" "),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Start an organization migration.
     *
     * This function performs a `POST` to the `/orgs/{org}/migrations` endpoint.
     *
     * Initiates the generation of a migration archive.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#start-an-organization-migration>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn migrations_start_for_org(&self, org: &str, body: &types::MigrationsStartOrgRequest) -> Result<types::Migration> {
        let url = format!("/orgs/{}/migrations", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get an organization migration status.
     *
     * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}` endpoint.
     *
     * Fetches the status of a migration.
     *
     * The `state` of a migration can be one of the following values:
     *
     * *   `pending`, which means the migration hasn't started yet.
     * *   `exporting`, which means the migration is in progress.
     * *   `exported`, which means the migration finished successfully.
     * *   `failed`, which means the migration failed.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#get-an-organization-migration-status>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `migration_id: i64` -- migration_id parameter.
     * * `exclude: &[String]` -- Exclude attributes from the API response to improve performance.
     */
    pub async fn migrations_get_status_for_org(&self, org: &str, migration_id: i64, exclude: &[String]) -> Result<types::Migration> {
        let url = format!(
            "/orgs/{}/migrations/{}?exclude={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            exclude.join(" "),
        );

        self.get(&url).await
    }

    /**
     * Download an organization migration archive.
     *
     * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}/archive` endpoint.
     *
     * Fetches the URL to a migration archive.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#download-an-organization-migration-archive>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `migration_id: i64` -- migration_id parameter.
     */
    pub async fn migrations_download_archive_for_org(&self, org: &str, migration_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/archive",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete an organization migration archive.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/migrations/{migration_id}/archive` endpoint.
     *
     * Deletes a previous migration archive. Migration archives are automatically deleted after seven days.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#delete-an-organization-migration-archive>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `migration_id: i64` -- migration_id parameter.
     */
    pub async fn migrations_delete_archive_for_org(&self, org: &str, migration_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/archive",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Unlock an organization repository.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock` endpoint.
     *
     * Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration is complete and you no longer need the source data.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#unlock-an-organization-repository>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `migration_id: i64` -- migration_id parameter.
     * * `repo_name: &str` -- repo_name parameter.
     */
    pub async fn migrations_unlock_repo_for_org(&self, org: &str, migration_id: i64, repo_name: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/repos/{}/lock",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            progenitor_support::encode_path(&repo_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repositories in an organization migration.
     *
     * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}/repositories` endpoint.
     *
     * List all the repositories for this organization migration.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#list-repositories-in-an-organization-migration>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `migration_id: i64` -- migration_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn migrations_list_repos_for_org(
        &self,
        org: &str,
        migration_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/migrations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List outside collaborators for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/outside_collaborators` endpoint.
     *
     * List all users who are outside collaborators of an organization.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-outside-collaborators-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `filter: crate::types::OrgsListMembersFilter` -- Filter the list of outside collaborators. Can be one of:  
     *  \* `2fa_disabled`: Outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled.  
     *  \* `all`: All outside collaborators.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_outside_collaborators(
        &self,
        org: &str,
        filter: crate::types::OrgsListMembersFilter,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/orgs/{}/outside_collaborators?filter={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            filter,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Convert an organization member to outside collaborator.
     *
     * This function performs a `PUT` to the `/orgs/{org}/outside_collaborators/{username}` endpoint.
     *
     * When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://help.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#convert-an-organization-member-to-outside-collaborator>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_convert_member_to_outside_collaborator(&self, org: &str, username: &str) -> Result<types::Data> {
        let url = format!(
            "/orgs/{}/outside_collaborators/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove outside collaborator from an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/outside_collaborators/{username}` endpoint.
     *
     * Removing a user from this list will remove them from all the organization's repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#remove-outside-collaborator-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_remove_outside_collaborator(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/outside_collaborators/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get a package for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}` endpoint.
     *
     * Gets a specific package in an organization.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     */
    pub async fn packages_get_package_for_organization(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/orgs/{}/packages/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a package for an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/packages/{package_type}/{package_name}` endpoint.
     *
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.
     *
     * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope. In addition:
     * - If `package_type` is not `container`, your token must also include the `repo` scope.
     * - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     */
    pub async fn packages_delete_package_for_org(&self, package_type: crate::types::PackageType, package_name: &str, org: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Restore a package for an organization.
     *
     * This function performs a `POST` to the `/orgs/{org}/packages/{package_type}/{package_name}/restore` endpoint.
     *
     * Restores an entire package in an organization.
     *
     * You can restore a deleted package under the following conditions:
     *   - The package was deleted within the last 30 days.
     *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
     *
     * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scope. In addition:
     * - If `package_type` is not `container`, your token must also include the `repo` scope.
     * - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     * * `token: &str` -- package token.
     */
    pub async fn packages_restore_package_for_org(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
        token: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/restore?token={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            token.to_string(),
        );

        self.post(&url, None).await
    }

    /**
     * Get all package versions for a package owned by an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions` endpoint.
     *
     * Returns all package versions for a package owned by an organization.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `state: crate::types::PackagesGetAllPackageVersionsOwnedByState` -- The state of the package, either active or deleted.
     */
    pub async fn packages_get_all_package_versions_for_package_owned_by_org(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
        page: i64,
        per_page: i64,
        state: crate::types::PackagesGetAllPackageVersionsOwnedByState,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a package version for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
     *
     * Gets a specific package version in an organization.
     *
     * You must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_get_package_version_for_organization(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete package version for an organization.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
     *
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.
     *
     * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope. In addition:
     * - If `package_type` is not `container`, your token must also include the `repo` scope.
     * - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_delete_package_version_for_org(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Restore package version for an organization.
     *
     * This function performs a `POST` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore` endpoint.
     *
     * Restores a specific package version in an organization.
     *
     * You can restore a deleted package under the following conditions:
     *   - The package was deleted within the last 30 days.
     *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
     *
     * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scope. In addition:
     * - If `package_type` is not `container`, your token must also include the `repo` scope.
     * - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `org: &str`
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_restore_package_version_for_org(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}/restore",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * List organization projects.
     *
     * This function performs a `GET` to the `/orgs/{org}/projects` endpoint.
     *
     * Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-organization-projects>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `state: crate::types::IssuesListState` -- Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_for_org(
        &self,
        org: &str,
        state: crate::types::IssuesListState,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/orgs/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an organization project.
     *
     * This function performs a `POST` to the `/orgs/{org}/projects` endpoint.
     *
     * Creates an organization project board. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#create-an-organization-project>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn projects_create_for_org(&self, org: &str, body: &types::ProjectsCreateOrgRequest) -> Result<types::Project> {
        let url = format!("/orgs/{}/projects", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List public organization members.
     *
     * This function performs a `GET` to the `/orgs/{org}/public_members` endpoint.
     *
     * Members of an organization can choose to have their membership publicized or not.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-public-organization-members>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_public_members(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/orgs/{}/public_members?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check public organization membership for a user.
     *
     * This function performs a `GET` to the `/orgs/{org}/public_members/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#check-public-organization-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_check_public_membership_for_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set public organization membership for the authenticated user.
     *
     * This function performs a `PUT` to the `/orgs/{org}/public_members/{username}` endpoint.
     *
     * The user can publicize their own membership. (A user cannot publicize the membership for another user.)
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#set-public-organization-membership-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_set_public_membership_for_authenticated_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove public organization membership for the authenticated user.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/public_members/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#remove-public-organization-membership-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `username: &str`
     */
    pub async fn orgs_remove_public_membership_for_authenticated_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List organization repositories.
     *
     * This function performs a `GET` to the `/orgs/{org}/repos` endpoint.
     *
     * Lists repositories for the specified organization.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-organization-repositories>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `type_: crate::types::ReposListOrgType` -- Specifies the types of repositories you want returned. Can be one of `all`, `public`, `private`, `forks`, `sources`, `member`, `internal`. Note: For GitHub AE, can be one of `all`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be `internal`. However, the `internal` value is not yet supported when a GitHub App calls this API with an installation access token.
     * * `sort: crate::types::ReposListSort` -- Can be one of `created`, `updated`, `pushed`, `full_name`.
     * * `direction: crate::types::Direction` -- Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise `desc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_for_org(
        &self,
        org: &str,
        type_: crate::types::ReposListOrgType,
        sort: crate::types::ReposListSort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/repos?direction={}&page={}&per_page={}&sort={}&type={}",
            progenitor_support::encode_path(&org.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
            type_,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an organization repository.
     *
     * This function performs a `POST` to the `/orgs/{org}/repos` endpoint.
     *
     * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-an-organization-repository>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn repos_create_in_org(&self, org: &str, body: &types::ReposCreateInOrgRequest) -> Result<types::Repository> {
        let url = format!("/orgs/{}/repos", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get GitHub Actions billing for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/settings/billing/actions` endpoint.
     *
     * Gets the summary of the free and paid GitHub Actions minutes used.
     *
     * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * Access tokens must have the `repo` or `admin:org` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn billing_get_github_actions_billing_org(&self, org: &str) -> Result<types::ActionsBillingUsage> {
        let url = format!("/orgs/{}/settings/billing/actions", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Get GitHub Packages billing for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/settings/billing/packages` endpoint.
     *
     * Gets the free and paid storage used for GitHub Packages in gigabytes.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * Access tokens must have the `repo` or `admin:org` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn billing_get_github_packages_billing_org(&self, org: &str) -> Result<types::PackagesBillingUsage> {
        let url = format!("/orgs/{}/settings/billing/packages", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Get shared storage billing for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/settings/billing/shared-storage` endpoint.
     *
     * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * Access tokens must have the `repo` or `admin:org` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn billing_get_shared_storage_billing_org(&self, org: &str) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/orgs/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List IdP groups for an organization.
     *
     * This function performs a `GET` to the `/orgs/{org}/team-sync/groups` endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * List IdP groups available in an organization. You can limit your page results using the `per_page` parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89)."
     *
     * The `per_page` parameter provides pagination for a list of IdP groups the authenticated user can access in an organization. For example, if the user `octocat` wants to see two groups per page in `octo-org` via cURL, it would look like this:
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: &str` -- Page token.
     */
    pub async fn teams_list_idp_groups_for_org(&self, org: &str, per_page: i64, page: &str) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/team-sync/groups?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            page.to_string(),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List teams.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams` endpoint.
     *
     * Lists all teams in an organization that are visible to the authenticated user.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-teams>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list(&self, org: &str, per_page: i64, page: i64) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a team.
     *
     * This function performs a `POST` to the `/orgs/{org}/teams` endpoint.
     *
     * To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://help.github.com/en/articles/setting-team-creation-permissions-in-your-organization)."
     *
     * When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn teams_create(&self, org: &str, body: &types::TeamsCreateRequest) -> Result<types::TeamFull> {
        let url = format!("/orgs/{}/teams", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a team by name.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}` endpoint.
     *
     * Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-a-team-by-name>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_get_by_name(&self, org: &str, team_slug: &str) -> Result<types::TeamFull> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a team.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}` endpoint.
     *
     * To delete a team, the authenticated user must be an organization owner or team maintainer.
     *
     * If you are an organization owner, deleting a parent team will delete all of its child teams as well.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#delete-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_delete_in_org(&self, org: &str, team_slug: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a team.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}` endpoint.
     *
     * To edit a team, the authenticated user must either be an organization owner or a team maintainer.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#update-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_update_in_org(&self, org: &str, team_slug: &str, body: &types::TeamsUpdateInOrgRequest) -> Result<types::TeamFull> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List discussions.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions` endpoint.
     *
     * List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-discussions>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `pinned: &str` -- Pinned discussions only filter.
     */
    pub async fn teams_list_discussions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
        pinned: &str,
    ) -> Result<Vec<types::TeamDiscussion>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions?direction={}&page={}&per_page={}&pinned={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            pinned.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a discussion.
     *
     * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions` endpoint.
     *
     * Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_create_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        body: &types::TeamsCreateDiscussionInOrgRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a discussion.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
     *
     * Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     */
    pub async fn teams_get_discussion_in_org(&self, org: &str, team_slug: &str, discussion_number: i64) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a discussion.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
     *
     * Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     */
    pub async fn teams_delete_discussion_in_org(&self, org: &str, team_slug: &str, discussion_number: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a discussion.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
     *
     * Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     */
    pub async fn teams_update_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::TeamsUpdateDiscussionInOrgRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List discussion comments.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments` endpoint.
     *
     * List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-discussion-comments>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_discussion_comments_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussionComment>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a discussion comment.
     *
     * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments` endpoint.
     *
     * Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     */
    pub async fn teams_create_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::TeamsCreateDiscussionCommentInOrgRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a discussion comment.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_get_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a discussion comment.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_delete_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a discussion comment.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_update_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        body: &types::TeamsCreateDiscussionCommentInOrgRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for a team discussion comment.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
     *
     * List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_team_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a team discussion comment.
     *
     * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
     *
     * Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn reactions_create_for_team_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        body: &types::ReactionsCreateTeamDiscussionCommentInOrgRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete team discussion comment reaction.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
     *
     * Delete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-team-discussion-comment-reaction>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `comment_number: i64`
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_team_discussion_comment(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List reactions for a team discussion.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions` endpoint.
     *
     * List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_team_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a team discussion.
     *
     * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions` endpoint.
     *
     * Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     */
    pub async fn reactions_create_for_team_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::ReactionsCreateTeamDiscussionInOrgRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete team discussion reaction.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
     *
     * Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-team-discussion-reaction>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `discussion_number: i64`
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_team_discussion(&self, org: &str, team_slug: &str, discussion_number: i64, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List pending team invitations.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/invitations` endpoint.
     *
     * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/invitations`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-pending-team-invitations>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_pending_invitations_in_org(
        &self,
        org: &str,
        team_slug: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/teams/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List team members.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/members` endpoint.
     *
     * Team members will include the members of child teams.
     *
     * To list members in a team, the team must be visible to the authenticated user.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-team-members>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `role: crate::types::TeamsListMembersInOrgRole` -- Filters members returned by their role in the team. Can be one of:  
     *  \* `member` - normal members of the team.  
     *  \* `maintainer` - team maintainers.  
     *  \* `all` - all members of the team.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_members_in_org(
        &self,
        org: &str,
        team_slug: &str,
        role: crate::types::TeamsListMembersInOrgRole,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/orgs/{}/teams/{}/members?page={}&per_page={}&role={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            role,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get team membership for a user.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
     *
     * Team members will include the members of child teams.
     *
     * To get a user's membership with a team, the team must be visible to the authenticated user.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.
     *
     * **Note:**
     * The response contains the `state` of the membership and the member's `role`.
     *
     * The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `username: &str`
     */
    pub async fn teams_get_membership_for_user_in_org(&self, org: &str, team_slug: &str, username: &str) -> Result<types::TeamMembership> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team membership for a user.
     *
     * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.
     *
     * If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `username: &str`
     */
    pub async fn teams_add_or_update_membership_for_user_in_org(
        &self,
        org: &str,
        team_slug: &str,
        username: &str,
        body: &types::TeamsAddUpdateMembershipUserInOrgRequest,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove team membership for a user.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `username: &str`
     */
    pub async fn teams_remove_membership_for_user_in_org(&self, org: &str, team_slug: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List team projects.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/projects` endpoint.
     *
     * Lists the organization projects for a team.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-team-projects>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_projects_in_org(&self, org: &str, team_slug: &str, per_page: i64, page: i64) -> Result<Vec<types::TeamProject>> {
        let url = format!(
            "/orgs/{}/teams/{}/projects?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check team permissions for a project.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
     *
     * Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `project_id: i64`
     */
    pub async fn teams_check_permissions_for_project_in_org(&self, org: &str, team_slug: &str, project_id: i64) -> Result<types::TeamProject> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team project permissions.
     *
     * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
     *
     * Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `project_id: i64`
     */
    pub async fn teams_add_or_update_project_permissions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        project_id: i64,
        body: &types::TeamsAddUpdateProjectPermissionsInOrgRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove a project from a team.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
     *
     * Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. This endpoint removes the project from the team, but does not delete the project.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `project_id: i64`
     */
    pub async fn teams_remove_project_in_org(&self, org: &str, team_slug: &str, project_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List team repositories.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/repos` endpoint.
     *
     * Lists a team's repositories visible to the authenticated user.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-team-repositories>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_repos_in_org(&self, org: &str, team_slug: &str, per_page: i64, page: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/teams/{}/repos?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check team permissions for a repository.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
     *
     * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
     *
     * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_check_permissions_for_repo_in_org(
        &self,
        org: &str,
        team_slug: &str,
        owner: &str,
        repo: &str,
    ) -> Result<types::TeamRepository> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team repository permissions.
     *
     * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
     *
     * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
     *
     * For more information about the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-repository-permissions>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_add_or_update_repo_permissions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        owner: &str,
        repo: &str,
        body: &types::TeamsAddUpdateRepoPermissionsInOrgRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove a repository from a team.
     *
     * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
     *
     * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-repository-from-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_remove_repo_in_org(&self, org: &str, team_slug: &str, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List IdP groups for a team.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/team-sync/group-mappings` endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * List IdP groups connected to a team on GitHub.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_list_idp_groups_in_org(&self, org: &str, team_slug: &str) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update IdP group connections.
     *
     * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/team-sync/group-mappings` endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     */
    pub async fn teams_create_or_update_idp_group_connections_in_org(
        &self,
        org: &str,
        team_slug: &str,
        body: &types::TeamsCreateUpdateIdpGroupConnectionsInOrgRequest,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List child teams.
     *
     * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/teams` endpoint.
     *
     * Lists the child teams of the team specified by `{team_slug}`.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-child-teams>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `team_slug: &str` -- team_slug parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_child_in_org(&self, org: &str, team_slug: &str, per_page: i64, page: i64) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/teams/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a project card.
     *
     * This function performs a `GET` to the `/projects/columns/cards/{card_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#get-a-project-card>
     *
     * **Parameters:**
     *
     * * `card_id: i64` -- card_id parameter.
     */
    pub async fn projects_get_card(&self, card_id: i64) -> Result<types::ProjectCard> {
        let url = format!("/projects/columns/cards/{}", progenitor_support::encode_path(&card_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a project card.
     *
     * This function performs a `DELETE` to the `/projects/columns/cards/{card_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project-card>
     *
     * **Parameters:**
     *
     * * `card_id: i64` -- card_id parameter.
     */
    pub async fn projects_delete_card(&self, card_id: i64) -> Result<()> {
        let url = format!("/projects/columns/cards/{}", progenitor_support::encode_path(&card_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update an existing project card.
     *
     * This function performs a `PATCH` to the `/projects/columns/cards/{card_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#update-a-project-card>
     *
     * **Parameters:**
     *
     * * `card_id: i64` -- card_id parameter.
     */
    pub async fn projects_update_card(&self, card_id: i64, body: &types::ProjectsUpdateCardRequest) -> Result<types::ProjectCard> {
        let url = format!("/projects/columns/cards/{}", progenitor_support::encode_path(&card_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Move a project card.
     *
     * This function performs a `POST` to the `/projects/columns/cards/{card_id}/moves` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#move-a-project-card>
     *
     * **Parameters:**
     *
     * * `card_id: i64` -- card_id parameter.
     */
    pub async fn projects_move_card(&self, card_id: i64, body: &types::ProjectsMoveCardRequest) -> Result<types::Data> {
        let url = format!("/projects/columns/cards/{}/moves", progenitor_support::encode_path(&card_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a project column.
     *
     * This function performs a `GET` to the `/projects/columns/{column_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#get-a-project-column>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     */
    pub async fn projects_get_column(&self, column_id: i64) -> Result<types::ProjectColumn> {
        let url = format!("/projects/columns/{}", progenitor_support::encode_path(&column_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a project column.
     *
     * This function performs a `DELETE` to the `/projects/columns/{column_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project-column>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     */
    pub async fn projects_delete_column(&self, column_id: i64) -> Result<()> {
        let url = format!("/projects/columns/{}", progenitor_support::encode_path(&column_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update an existing project column.
     *
     * This function performs a `PATCH` to the `/projects/columns/{column_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#update-a-project-column>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     */
    pub async fn projects_update_column(&self, column_id: i64, body: &types::ProjectsUpdateColumnRequest) -> Result<types::ProjectColumn> {
        let url = format!("/projects/columns/{}", progenitor_support::encode_path(&column_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List project cards.
     *
     * This function performs a `GET` to the `/projects/columns/{column_id}/cards` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-project-cards>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     * * `archived_state: crate::types::ProjectsListCardsArchivedState` -- Filters the project cards that are returned by the card's state. Can be one of `all`,`archived`, or `not_archived`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_cards(
        &self,
        column_id: i64,
        archived_state: crate::types::ProjectsListCardsArchivedState,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ProjectCard>> {
        let url = format!(
            "/projects/columns/{}/cards?archived_state={}&page={}&per_page={}",
            progenitor_support::encode_path(&column_id.to_string()),
            archived_state,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a project card.
     *
     * This function performs a `POST` to the `/projects/columns/{column_id}/cards` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#create-a-project-card>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     */
    pub async fn projects_create_card(&self, column_id: i64, body: &types::ProjectsCreateCardRequest) -> Result<types::ProjectCard> {
        let url = format!("/projects/columns/{}/cards", progenitor_support::encode_path(&column_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Move a project column.
     *
     * This function performs a `POST` to the `/projects/columns/{column_id}/moves` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#move-a-project-column>
     *
     * **Parameters:**
     *
     * * `column_id: i64` -- column_id parameter.
     */
    pub async fn projects_move_column(&self, column_id: i64, body: &types::ProjectsMoveColumnRequest) -> Result<types::Data> {
        let url = format!("/projects/columns/{}/moves", progenitor_support::encode_path(&column_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a project.
     *
     * This function performs a `GET` to the `/projects/{project_id}` endpoint.
     *
     * Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#get-a-project>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     */
    pub async fn projects_get(&self, project_id: i64) -> Result<types::Project> {
        let url = format!("/projects/{}", progenitor_support::encode_path(&project_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a project.
     *
     * This function performs a `DELETE` to the `/projects/{project_id}` endpoint.
     *
     * Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     */
    pub async fn projects_delete(&self, project_id: i64) -> Result<()> {
        let url = format!("/projects/{}", progenitor_support::encode_path(&project_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update a project.
     *
     * This function performs a `PATCH` to the `/projects/{project_id}` endpoint.
     *
     * Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#update-a-project>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     */
    pub async fn projects_update(&self, project_id: i64, body: &types::ProjectsUpdateRequest) -> Result<types::Project> {
        let url = format!("/projects/{}", progenitor_support::encode_path(&project_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List project collaborators.
     *
     * This function performs a `GET` to the `/projects/{project_id}/collaborators` endpoint.
     *
     * Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-project-collaborators>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     * * `affiliation: crate::types::ProjectsListCollaboratorsAffiliation` -- Filters the collaborators by their affiliation. Can be one of:  
     *  \* `outside`: Outside collaborators of a project that are not a member of the project's organization.  
     *  \* `direct`: Collaborators with permissions to a project, regardless of organization membership status.  
     *  \* `all`: All collaborators the authenticated user can see.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_collaborators(
        &self,
        project_id: i64,
        affiliation: crate::types::ProjectsListCollaboratorsAffiliation,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/projects/{}/collaborators?affiliation={}&page={}&per_page={}",
            progenitor_support::encode_path(&project_id.to_string()),
            affiliation,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Add project collaborator.
     *
     * This function performs a `PUT` to the `/projects/{project_id}/collaborators/{username}` endpoint.
     *
     * Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#add-project-collaborator>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     * * `username: &str`
     */
    pub async fn projects_add_collaborator(&self, project_id: i64, username: &str, body: &types::ProjectsAddCollaboratorRequest) -> Result<()> {
        let url = format!(
            "/projects/{}/collaborators/{}",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove user as a collaborator.
     *
     * This function performs a `DELETE` to the `/projects/{project_id}/collaborators/{username}` endpoint.
     *
     * Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#remove-project-collaborator>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     * * `username: &str`
     */
    pub async fn projects_remove_collaborator(&self, project_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/projects/{}/collaborators/{}",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get project permission for a user.
     *
     * This function performs a `GET` to the `/projects/{project_id}/collaborators/{username}/permission` endpoint.
     *
     * Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#get-project-permission-for-a-user>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     * * `username: &str`
     */
    pub async fn projects_get_permission_for_user(&self, project_id: i64, username: &str) -> Result<types::RepositoryCollaboratorPermission> {
        let url = format!(
            "/projects/{}/collaborators/{}/permission",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List project columns.
     *
     * This function performs a `GET` to the `/projects/{project_id}/columns` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-project-columns>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_columns(&self, project_id: i64, per_page: i64, page: i64) -> Result<Vec<types::ProjectColumn>> {
        let url = format!(
            "/projects/{}/columns?page={}&per_page={}",
            progenitor_support::encode_path(&project_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a project column.
     *
     * This function performs a `POST` to the `/projects/{project_id}/columns` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#create-a-project-column>
     *
     * **Parameters:**
     *
     * * `project_id: i64`
     */
    pub async fn projects_create_column(&self, project_id: i64, body: &types::ProjectsUpdateColumnRequest) -> Result<types::ProjectColumn> {
        let url = format!("/projects/{}/columns", progenitor_support::encode_path(&project_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get rate limit status for the authenticated user.
     *
     * This function performs a `GET` to the `/rate_limit` endpoint.
     *
     * **Note:** Accessing this endpoint does not count against your REST API rate limit.
     *
     * **Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
     *
     * FROM: <https://docs.github.com/rest/reference/rate-limit#get-rate-limit-status-for-the-authenticated-user>
     */
    pub async fn rate_limit_get(&self) -> Result<types::RateLimitOverview> {
        let url = "/rate_limit".to_string();
        self.get(&url).await
    }

    /**
     * Delete a reaction (Legacy).
     *
     * This function performs a `DELETE` to the `/reactions/{reaction_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions API. We recommend migrating your existing code to use the new delete reactions endpoints. For more information, see this [blog post](https://developer.github.com/changes/2020-02-26-new-delete-reactions-endpoints/).
     *
     * OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy>
     *
     * **Parameters:**
     *
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_legacy(&self, reaction_id: i64) -> Result<()> {
        let url = format!("/reactions/{}", progenitor_support::encode_path(&reaction_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Get a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}` endpoint.
     *
     * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
     *
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get(&self, owner: &str, repo: &str) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a repository.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}` endpoint.
     *
     * Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
     *
     * If an organization owner has configured the organization to prevent members from deleting organization-owned
     * repositories, you will get a `403 Forbidden` response.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_delete(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a repository.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}` endpoint.
     *
     * **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos/#update-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_update(&self, owner: &str, repo: &str, body: &types::ReposUpdateRequest) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List artifacts for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts` endpoint.
     *
     * Lists all artifacts for a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-artifacts-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_artifacts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListArtifactsRepoOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get an artifact.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}` endpoint.
     *
     * Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-an-artifact>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `artifact_id: i64` -- artifact_id parameter.
     */
    pub async fn actions_get_artifact(&self, owner: &str, repo: &str, artifact_id: i64) -> Result<types::Artifact> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete an artifact.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}` endpoint.
     *
     * Deletes an artifact for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-an-artifact>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `artifact_id: i64` -- artifact_id parameter.
     */
    pub async fn actions_delete_artifact(&self, owner: &str, repo: &str, artifact_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Download an artifact.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}` endpoint.
     *
     * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
     * the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone with read access to
     * the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#download-an-artifact>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `artifact_id: i64` -- artifact_id parameter.
     * * `archive_format: &str`
     */
    pub async fn actions_download_artifact(&self, owner: &str, repo: &str, artifact_id: i64, archive_format: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
            progenitor_support::encode_path(&archive_format.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get a job for a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/jobs/{job_id}` endpoint.
     *
     * Gets a specific job in a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-job-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `job_id: i64` -- job_id parameter.
     */
    pub async fn actions_get_job_for_workflow_run(&self, owner: &str, repo: &str, job_id: i64) -> Result<types::Job> {
        let url = format!(
            "/repos/{}/{}/actions/jobs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&job_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Download job logs for a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/jobs/{job_id}/logs` endpoint.
     *
     * Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
     * for `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must
     * have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#download-job-logs-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `job_id: i64` -- job_id parameter.
     */
    pub async fn actions_download_job_logs_for_workflow_run(&self, owner: &str, repo: &str, job_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/jobs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&job_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get GitHub Actions permissions for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/permissions` endpoint.
     *
     * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions allowed to run in the repository.
     *
     * You must authenticate using an access token with the `repo` scope to use this
     * endpoint. GitHub Apps must have the `administration` repository permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-github-actions-permissions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_get_github_actions_permissions_repository(&self, owner: &str, repo: &str) -> Result<types::ActionsRepositoryPermissions> {
        let url = format!(
            "/repos/{}/{}/actions/permissions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set GitHub Actions permissions for a repository.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/permissions` endpoint.
     *
     * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the repository.
     *
     * If the repository belongs to an organization or enterprise that has set restrictive permissions at the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you cannot override them for the repository.
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-github-actions-permissions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_set_github_actions_permissions_repository(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ActionsSetGithubPermissionsRepositoryRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/permissions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get allowed actions for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/permissions/selected-actions` endpoint.
     *
     * Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-allowed-actions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_get_allowed_actions_repository(&self, owner: &str, repo: &str) -> Result<types::SelectedActions> {
        let url = format!(
            "/repos/{}/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set allowed actions for a repository.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/permissions/selected-actions` endpoint.
     *
     * Sets the actions that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
     *
     * If the repository belongs to an organization or enterprise that has `selected` actions set at the organization or enterprise levels, then you cannot override any of the allowed actions settings.
     *
     * To use the `patterns_allowed` setting for private repositories, the repository must belong to an enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories.
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#set-allowed-actions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_set_allowed_actions_repository(&self, owner: &str, repo: &str, body: &types::SelectedActions) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List self-hosted runners for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners` endpoint.
     *
     * Lists all self-hosted runners configured in a repository. You must authenticate using an access token with the `repo` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_self_hosted_runners_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListSelfHostedRunnersOrgOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List runner applications for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners/downloads` endpoint.
     *
     * Lists binaries for the runner application that you can download and run.
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-runner-applications-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_list_runner_applications_for_repo(&self, owner: &str, repo: &str) -> Result<Vec<types::RunnerApplication>> {
        let url = format!(
            "/repos/{}/{}/actions/runners/downloads",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a registration token for a repository.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runners/registration-token` endpoint.
     *
     * Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     *
     * #### Example using registration token
     *  
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-registration-token-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_create_registration_token_for_repo(&self, owner: &str, repo: &str) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/repos/{}/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Create a remove token for a repository.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runners/remove-token` endpoint.
     *
     * Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     *
     * #### Example using remove token
     *  
     * To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-remove-token-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_create_remove_token_for_repo(&self, owner: &str, repo: &str) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/repos/{}/{}/actions/runners/remove-token",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get a self-hosted runner for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners/{runner_id}` endpoint.
     *
     * Gets a specific self-hosted runner configured in a repository.
     *
     * You must authenticate using an access token with the `repo` scope to use this
     * endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_get_self_hosted_runner_for_repo(&self, owner: &str, repo: &str, runner_id: i64) -> Result<types::Runner> {
        let url = format!(
            "/repos/{}/{}/actions/runners/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a self-hosted runner from a repository.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runners/{runner_id}` endpoint.
     *
     * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
     *
     * You must authenticate using an access token with the `repo`
     * scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-from-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `runner_id: i64` -- Unique identifier of the self-hosted runner.
     */
    pub async fn actions_delete_self_hosted_runner_from_repo(&self, owner: &str, repo: &str, runner_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runners/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List workflow runs for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs` endpoint.
     *
     * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-runs-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `actor: &str` -- Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
     * * `branch: &str` -- Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
     * * `event: &str` -- Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).".
     * * `status: crate::types::WorkflowRunStatus` -- Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run).".
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_workflow_runs_for_repo(
        &self,
        owner: &str,
        repo: &str,
        actor: &str,
        branch: &str,
        event: &str,
        status: crate::types::WorkflowRunStatus,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListWorkflowRunsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs?actor={}&branch={}&event={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            actor.to_string(),
            branch.to_string(),
            event.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            status,
        );

        self.get(&url).await
    }

    /**
     * Get a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}` endpoint.
     *
     * Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_get_workflow_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<types::WorkflowRun> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a workflow run.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runs/{run_id}` endpoint.
     *
     * Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
     * private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
     * this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_delete_workflow_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get the review history for a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/approvals` endpoint.
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-the-review-history-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_get_reviews_for_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<Vec<types::EnvironmentApprovals>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/approvals",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Approve a workflow run for a fork pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/approve` endpoint.
     *
     * **Note:** This endpoint is currently in beta and is subject to change.
     *
     * Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#approve-a-workflow-run-for-a-fork-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_approve_workflow_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<types::EmptyObject> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/approve",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * List workflow run artifacts.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts` endpoint.
     *
     * Lists artifacts for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-run-artifacts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_workflow_run_artifacts(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListArtifactsRepoOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/artifacts?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Cancel a workflow run.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/cancel` endpoint.
     *
     * Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#cancel-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_cancel_workflow_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<types::Data> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/cancel",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * List jobs for a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/jobs` endpoint.
     *
     * Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-jobs-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     * * `filter: crate::types::ActionsListJobsWorkflowRunFilter` -- Filters jobs by their `completed_at` timestamp. Can be one of:  
     *  \* `latest`: Returns jobs from the most recent execution of the workflow run.  
     *  \* `all`: Returns all jobs for a workflow run, including from old executions of the workflow run.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_jobs_for_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        filter: crate::types::ActionsListJobsWorkflowRunFilter,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListJobsWorkflowRunOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/jobs?filter={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
            filter,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Download workflow run logs.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/logs` endpoint.
     *
     * Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
     * `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can use
     * this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have
     * the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#download-workflow-run-logs>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_download_workflow_run_logs(&self, owner: &str, repo: &str, run_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete workflow run logs.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/logs` endpoint.
     *
     * Deletes all logs for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-workflow-run-logs>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_delete_workflow_run_logs(&self, owner: &str, repo: &str, run_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get pending deployments for a workflow run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments` endpoint.
     *
     * Get all deployment environments for a workflow run that are waiting for protection rules to pass.
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-pending-deployments-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_get_pending_deployments_for_run(&self, owner: &str, repo: &str, run_id: i64) -> Result<Vec<types::PendingDeployment>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/pending_deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Review pending deployments for a workflow run.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments` endpoint.
     *
     * Approve or reject pending deployments that are waiting on approval by a required reviewer.
     *
     * Anyone with read access to the repository contents and deployments can use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#review-pending-deployments-for-a-workflow-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_review_pending_deployments_for_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        body: &types::ActionsReviewPendingDeploymentsRunRequest,
    ) -> Result<Vec<types::Deployment>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/pending_deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Re-run a workflow.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/rerun` endpoint.
     *
     * Re-runs your workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#re-run-a-workflow>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_re_run_workflow(&self, owner: &str, repo: &str, run_id: i64) -> Result<types::Data> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/rerun",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get workflow run usage.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/timing` endpoint.
     *
     * Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-workflow-run-usage>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `run_id: i64` -- The id of the workflow run.
     */
    pub async fn actions_get_workflow_run_usage(&self, owner: &str, repo: &str, run_id: i64) -> Result<types::WorkflowRunUsage> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/timing",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List repository secrets.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets` endpoint.
     *
     * Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-repository-secrets>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_repo_secrets(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListRepoSecretsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get a repository public key.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets/public-key` endpoint.
     *
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-repository-public-key>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn actions_get_repo_public_key(&self, owner: &str, repo: &str) -> Result<types::ActionsPublicKey> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/public-key",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get a repository secret.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
     *
     * Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-repository-secret>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_get_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<types::ActionsSecret> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update a repository secret.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
     *
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
     * this endpoint.
     *
     * #### Example encrypting a secret using Node.js
     *
     * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
     *
     * ```
     * const sodium = require('tweetsodium');
     *
     * const key = "base64-encoded-public-key";
     * const value = "plain-text-secret";
     *
     * // Convert the message and key to Uint8Array's (Buffer implements that interface)
     * const messageBytes = Buffer.from(value);
     * const keyBytes = Buffer.from(key, 'base64');
     *
     * // Encrypt using LibSodium.
     * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
     *
     * // Base64 the encrypted secret
     * const encrypted = Buffer.from(encryptedBytes).toString('base64');
     *
     * console.log(encrypted);
     * ```
     *
     *
     * #### Example encrypting a secret using Python
     *
     * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
     *
     * ```
     * from base64 import b64encode
     * from nacl import encoding, public
     *
     * def encrypt(public_key: str, secret_value: str) -> str:
     *   """Encrypt a Unicode string using the public key."""
     *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
     *   sealed_box = public.SealedBox(public_key)
     *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
     *   return b64encode(encrypted).decode("utf-8")
     * ```
     *
     * #### Example encrypting a secret using C#
     *
     * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
     *
     * ```
     * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
     * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
     *
     * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     *
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
     * ```
     *
     * #### Example encrypting a secret using Ruby
     *
     * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
     *
     * ```ruby
     * require "rbnacl"
     * require "base64"
     *
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
     * public_key = RbNaCl::PublicKey.new(key)
     *
     * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret")
     *
     * # Print the base64 encoded secret
     * puts Base64.strict_encode64(encrypted_secret)
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-a-repository-secret>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_create_or_update_repo_secret(
        &self,
        owner: &str,
        repo: &str,
        secret_name: &str,
        body: &types::ActionsCreateUpdateRepoSecretRequest,
    ) -> Result<types::Data> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a repository secret.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
     *
     * Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-a-repository-secret>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_delete_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repository workflows.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows` endpoint.
     *
     * Lists the workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-repository-workflows>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_repo_workflows(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListRepoWorkflowsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/workflows?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get a workflow.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}` endpoint.
     *
     * Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-a-workflow>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     */
    pub async fn actions_get_workflow(&self, owner: &str, repo: &str, workflow_id: &str) -> Result<types::Workflow> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Disable a workflow.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable` endpoint.
     *
     * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#disable-a-workflow>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     */
    pub async fn actions_disable_workflow(&self, owner: &str, repo: &str, workflow_id: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/disable",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Create a workflow dispatch event.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches` endpoint.
     *
     * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see "[Creating a personal access token for the command line](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line)."
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-a-workflow-dispatch-event>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     */
    pub async fn actions_create_workflow_dispatch(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
        body: &types::ActionsCreateWorkflowDispatchRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/dispatches",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Enable a workflow.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable` endpoint.
     *
     * Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#enable-a-workflow>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     */
    pub async fn actions_enable_workflow(&self, owner: &str, repo: &str, workflow_id: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/enable",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * List workflow runs.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs` endpoint.
     *
     * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-runs>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     * * `actor: &str` -- Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
     * * `branch: &str` -- Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
     * * `event: &str` -- Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).".
     * * `status: crate::types::WorkflowRunStatus` -- Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run).".
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_workflow_runs(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
        actor: &str,
        branch: &str,
        event: &str,
        status: crate::types::WorkflowRunStatus,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListWorkflowRunsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/runs?actor={}&branch={}&event={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
            actor.to_string(),
            branch.to_string(),
            event.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            status,
        );

        self.get(&url).await
    }

    /**
     * Get workflow usage.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing` endpoint.
     *
     * Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-workflow-usage>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `workflow_id: &str` -- The ID of the workflow. You can also pass the workflow file name as a string.
     */
    pub async fn actions_get_workflow_usage(&self, owner: &str, repo: &str, workflow_id: &str) -> Result<types::WorkflowUsage> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/timing",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List assignees.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/assignees` endpoint.
     *
     * Lists the [available assignees](https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-assignees>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_assignees(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/assignees?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check if a user can be assigned.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/assignees/{assignee}` endpoint.
     *
     * Checks if a user has permission to be assigned to an issue in this repository.
     *
     * If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
     *
     * Otherwise a `404` status code is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#check-if-a-user-can-be-assigned>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `assignee: &str`
     */
    pub async fn issues_check_user_can_be_assigned(&self, owner: &str, repo: &str, assignee: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/assignees/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&assignee.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Enable automated security fixes.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/automated-security-fixes` endpoint.
     *
     * Enables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://help.github.com/en/articles/configuring-automated-security-fixes)".
     *
     * FROM: <https://docs.github.com/rest/reference/repos#enable-automated-security-fixes>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_enable_automated_security_fixes(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/automated-security-fixes",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Disable automated security fixes.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/automated-security-fixes` endpoint.
     *
     * Disables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://help.github.com/en/articles/configuring-automated-security-fixes)".
     *
     * FROM: <https://docs.github.com/rest/reference/repos#disable-automated-security-fixes>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_disable_automated_security_fixes(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/automated-security-fixes",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List branches.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-branches>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `protected: bool` -- Setting to `true` returns only protected branches. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_branches(&self, owner: &str, repo: &str, protected: bool, per_page: i64, page: i64) -> Result<Vec<types::ShortBranch>> {
        let url = format!(
            "/repos/{}/{}/branches?page={}&per_page={}&protected={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            format!("{}", protected),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a branch.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_branch(&self, owner: &str, repo: &str, branch: &str) -> Result<types::BranchWithProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get branch protection.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_branch_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<types::BranchProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update branch protection.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Protecting a branch requires admin or owner permissions to the repository.
     *
     * **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
     *
     * **Note**: The list of users, apps, and teams in total is limited to 100 items.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_update_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposUpdateBranchProtectionRequest,
    ) -> Result<types::ProtectedBranch> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete branch protection.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_delete_branch_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get admin branch protection.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-admin-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_admin_branch_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set admin branch protection.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#set-admin-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_set_admin_branch_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Delete admin branch protection.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-admin-branch-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_delete_admin_branch_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get pull request review protection.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-pull-request-review-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_pull_request_review_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchPullRequestReview> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete pull request review protection.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-pull-request-review-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_delete_pull_request_review_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update pull request review protection.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
     *
     * **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-pull-request-review-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_update_pull_request_review_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposUpdatePullRequestReviewProtection,
    ) -> Result<types::ProtectedBranchPullRequestReview> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get commit signature protection.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://help.github.com/articles/signing-commits-with-gpg) in GitHub Help.
     *
     * **Note**: You must enable branch protection to require signed commits.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-commit-signature-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_commit_signature_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create commit signature protection.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-commit-signature-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_create_commit_signature_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Delete commit signature protection.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-commit-signature-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_delete_commit_signature_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get status checks protection.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-status-checks-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_status_checks_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<types::StatusCheckPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Remove status check protection.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-status-check-protection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_remove_status_check_protection(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update status check protection.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-status-check-potection>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_update_status_check_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposUpdateStatusCheckProtectionRequest,
    ) -> Result<types::StatusCheckPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get all status check contexts.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-all-status-check-contexts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_all_status_check_contexts(&self, owner: &str, repo: &str, branch: &str) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Set status check contexts.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#set-status-check-contexts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_set_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add status check contexts.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#add-status-check-contexts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_add_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove status check contexts.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-status-check-contexts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_remove_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get access restrictions.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists who has access to this protected branch.
     *
     * **Note**: Users, apps, and teams `restrictions` are only available for organization-owned repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_access_restrictions(&self, owner: &str, repo: &str, branch: &str) -> Result<types::BranchRestrictionPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete access restrictions.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Disables the ability to restrict who can push to this branch.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_delete_access_restrictions(&self, owner: &str, repo: &str, branch: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get apps with access to the protected branch.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-apps-with-access-to-the-protected-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_apps_with_access_to_protected_branch(&self, owner: &str, repo: &str, branch: &str) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Set app access restrictions.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
     *
     * | Type    | Description                                                                                                                                                |
     * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#set-app-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_set_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add app access restrictions.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified apps push access for this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
     *
     * | Type    | Description                                                                                                                                                |
     * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#add-app-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_add_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove app access restrictions.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
     *
     * | Type    | Description                                                                                                                                                |
     * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-app-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_remove_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get teams with access to the protected branch.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the teams who have push access to this branch. The list includes child teams.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-teams-with-access-to-the-protected-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_teams_with_access_to_protected_branch(&self, owner: &str, repo: &str, branch: &str) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Set team access restrictions.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
     *
     * | Type    | Description                                                                                                                                |
     * | ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#set-team-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_set_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add team access restrictions.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified teams push access for this branch. You can also give push access to child teams.
     *
     * | Type    | Description                                                                                                                                |
     * | ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#add-team-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_add_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove team access restrictions.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of a team to push to this branch. You can also remove push access for child teams.
     *
     * | Type    | Description                                                                                                                                         |
     * | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-team-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_remove_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get users with access to the protected branch.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists the people who have push access to this branch.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-users-with-access-to-the-protected-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_get_users_with_access_to_protected_branch(&self, owner: &str, repo: &str, branch: &str) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Set user access restrictions.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
     *
     * | Type    | Description                                                                                                                   |
     * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#set-user-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_set_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add user access restrictions.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Grants the specified people push access for this branch.
     *
     * | Type    | Description                                                                                                                   |
     * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#add-user-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_add_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove user access restrictions.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Removes the ability of a user to push to this branch.
     *
     * | Type    | Description                                                                                                                                   |
     * | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-user-access-restrictions>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_remove_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposAddUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Rename a branch.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/rename` endpoint.
     *
     * Renames a branch in a repository.
     *
     * **Note:** Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
     *
     * The permissions required to use this endpoint depends on whether you are renaming the default branch.
     *
     * To rename a non-default branch:
     *
     * * Users must have push access.
     * * GitHub Apps must have the `contents:write` repository permission.
     *
     * To rename the default branch:
     *
     * * Users must have admin or owner permissions.
     * * GitHub Apps must have the `administration:write` repository permission.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#rename-a-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `branch: &str` -- The name of the branch.
     */
    pub async fn repos_rename_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::ReposRenameBranchRequest,
    ) -> Result<types::BranchWithProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}/rename",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a check run.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/check-runs` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
     *
     * Creates a new check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to create check runs.
     *
     * In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#create-a-check-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn checks_create(&self, owner: &str, repo: &str, body: &types::ChecksCreateRequest) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a check run.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
     *
     * Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#get-a-check-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_run_id: i64` -- check_run_id parameter.
     */
    pub async fn checks_get(&self, owner: &str, repo: &str, check_run_id: i64) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a check run.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
     *
     * Updates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#update-a-check-run>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_run_id: i64` -- check_run_id parameter.
     */
    pub async fn checks_update(&self, owner: &str, repo: &str, check_run_id: i64, body: &types::ChecksUpdateRequest) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List check run annotations.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations` endpoint.
     *
     * Lists annotations for a check run using the annotation `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get annotations for a check run in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#list-check-run-annotations>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_run_id: i64` -- check_run_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn checks_list_annotations(
        &self,
        owner: &str,
        repo: &str,
        check_run_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::CheckAnnotation>> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}/annotations?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a check suite.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/check-suites` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#create-a-check-suite>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn checks_create_suite(&self, owner: &str, repo: &str, body: &types::ChecksCreateSuiteRequest) -> Result<types::CheckSuite> {
        let url = format!(
            "/repos/{}/{}/check-suites",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Update repository preferences for check suites.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/check-suites/preferences` endpoint.
     *
     * Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn checks_set_suites_preferences(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ChecksSetSuitesPreferencesRequest,
    ) -> Result<types::CheckSuitePreference> {
        let url = format!(
            "/repos/{}/{}/check-suites/preferences",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a check suite.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#get-a-check-suite>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_suite_id: i64` -- check_suite_id parameter.
     */
    pub async fn checks_get_suite(&self, owner: &str, repo: &str, check_suite_id: i64) -> Result<types::CheckSuite> {
        let url = format!(
            "/repos/{}/{}/check-suites/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List check runs in a check suite.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
     *
     * Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#list-check-runs-in-a-check-suite>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_suite_id: i64` -- check_suite_id parameter.
     * * `check_name: &str` -- Returns check runs with the specified `name`.
     * * `status: crate::types::JobStatus` -- Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or `completed`.
     * * `filter: crate::types::ActionsListJobsWorkflowRunFilter` -- Filters check runs by their `completed_at` timestamp. Can be one of `latest` (returning the most recent check runs) or `all`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn checks_list_for_suite(
        &self,
        owner: &str,
        repo: &str,
        check_suite_id: i64,
        check_name: &str,
        status: crate::types::JobStatus,
        filter: crate::types::ActionsListJobsWorkflowRunFilter,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetChecksListRefOkResponse> {
        let url = format!(
            "/repos/{}/{}/check-suites/{}/check-runs?check_name={}&filter={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
            check_name.to_string(),
            filter,
            format!("{}", page),
            format!("{}", per_page),
            status,
        );

        self.get(&url).await
    }

    /**
     * Rerequest a check suite.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest` endpoint.
     *
     * Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
     *
     * To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#rerequest-a-check-suite>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `check_suite_id: i64` -- check_suite_id parameter.
     */
    pub async fn checks_rerequest_suite(&self, owner: &str, repo: &str, check_suite_id: i64) -> Result<types::Data> {
        let url = format!(
            "/repos/{}/{}/check-suites/{}/rerequest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * List code scanning alerts for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts` endpoint.
     *
     * Lists all open code scanning alerts for the default branch (usually `main`
     * or `master`). You must use an access token with the `security_events` scope to use
     * this endpoint. GitHub Apps must have the `security_events` read permission to use
     * this endpoint.
     *
     * The response includes a `most_recent_instance` object.
     * This provides details of the most recent instance of this alert
     * for the default branch or for the specified Git reference
     * (if you used `ref` in the request).
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#list-code-scanning-alerts-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `tool_name: &str` -- The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
     * * `tool_guid: &str` -- The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `ref_: &str` -- The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
     * * `state: types::CodeScanningAlertState` -- Set to `open`, `fixed`, or `dismissed` to list code scanning alerts in a specific state.
     */
    pub async fn code_scanning_list_alerts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        tool_name: &str,
        tool_guid: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
        state: types::CodeScanningAlertState,
    ) -> Result<Vec<types::CodeScanningAlertItems>> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts?page={}&per_page={}&ref={}&state={}&tool_guid={}&tool_name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
            state,
            tool_guid.to_string(),
            tool_name.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a code scanning alert.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}` endpoint.
     *
     * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * **Deprecation notice**:
     * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#get-a-code-scanning-alert>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `alert_number: i64` -- The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
     */
    pub async fn code_scanning_get_alert(&self, owner: &str, repo: &str, alert_number: i64) -> Result<types::CodeScanningAlert> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a code scanning alert.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}` endpoint.
     *
     * Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#update-a-code-scanning-alert>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `alert_number: i64` -- The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
     */
    pub async fn code_scanning_update_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: i64,
        body: &types::CodeScanningUpdateAlertRequest,
    ) -> Result<types::CodeScanningAlert> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List instances of a code scanning alert.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances` endpoint.
     *
     * Lists all instances of the specified code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#list-instances-of-a-code-scanning-alert>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `alert_number: i64` -- The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `ref_: &str` -- The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
     */
    pub async fn code_scanning_list_alert_instances(
        &self,
        owner: &str,
        repo: &str,
        alert_number: i64,
        page: i64,
        per_page: i64,
        ref_: &str,
    ) -> Result<Vec<types::CodeScanningAlertInstance>> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}/instances?page={}&per_page={}&ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
        );

        self.get_all_pages(&url).await
    }

    /**
     * List code scanning analyses for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/analyses` endpoint.
     *
     * Lists the details of all code scanning analyses for a repository,
     * starting with the most recent.
     * The response is paginated and you can use the `page` and `per_page` parameters
     * to list the analyses you're interested in.
     * By default 30 analyses are listed per page.
     *
     * The `rules_count` field in the response give the number of rules
     * that were run in the analysis.
     * For very old analyses this data is not available,
     * and `0` is returned in this field.
     *
     * You must use an access token with the `security_events` scope to use this endpoint.
     * GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * **Deprecation notice**:
     * The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#list-code-scanning-analyses-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `tool_name: &str` -- The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
     * * `tool_guid: &str` -- The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `ref_: &str` -- The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
     * * `sarif_id: &str` -- Filter analyses belonging to the same SARIF upload.
     */
    pub async fn code_scanning_list_recent_analyses(
        &self,
        owner: &str,
        repo: &str,
        tool_name: &str,
        tool_guid: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
        sarif_id: &str,
    ) -> Result<Vec<types::CodeScanningAnalysis>> {
        let url = format!(
            "/repos/{}/{}/code-scanning/analyses?page={}&per_page={}&ref={}&sarif_id={}&tool_guid={}&tool_name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
            sarif_id.to_string(),
            tool_guid.to_string(),
            tool_name.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a code scanning analysis for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}` endpoint.
     *
     * Gets a specified code scanning analysis for a repository.
     * You must use an access token with the `security_events` scope to use this endpoint.
     * GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * The default JSON response contains fields that describe the analysis.
     * This includes the Git reference and commit SHA to which the analysis relates,
     * the datetime of the analysis, the name of the code scanning tool,
     * and the number of alerts.
     *
     * The `rules_count` field in the default response give the number of rules
     * that were run in the analysis.
     * For very old analyses this data is not available,
     * and `0` is returned in this field.
     *
     * If you use the Accept header `application/sarif+json`,
     * the response contains the analysis data that was uploaded.
     * This is formatted as
     * [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
     *
     * **Deprecation notice**:
     * The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `analysis_id: i64` -- The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.
     */
    pub async fn code_scanning_get_analysis(&self, owner: &str, repo: &str, analysis_id: i64) -> Result<types::CodeScanningAnalysis> {
        let url = format!(
            "/repos/{}/{}/code-scanning/analyses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&analysis_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a code scanning analysis from a repository.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}` endpoint.
     *
     * Deletes a specified code scanning analysis from a repository. For
     * private repositories, you must use an access token with the `repo` scope. For public repositories,
     * you must use an access token with `public_repo` and `repo:security_events` scopes.
     * GitHub Apps must have the `security_events` write permission to use this endpoint.
     *
     * You can delete one analysis at a time.
     * To delete a series of analyses, start with the most recent analysis and work backwards.
     * Conceptually, the process is similar to the undo function in a text editor.
     *
     * When you list the analyses for a repository,
     * one or more will be identified as deletable in the response:
     *
     * ```
     * "deletable": true
     * ```
     *
     * An analysis is deletable when it's the most recent in a set of analyses.
     * Typically, a repository will have multiple sets of analyses
     * for each enabled code scanning tool,
     * where a set is determined by a unique combination of analysis values:
     *
     * * `ref`
     * * `tool`
     * * `analysis_key`
     * * `environment`
     *
     * If you attempt to delete an analysis that is not the most recent in a set,
     * you'll get a 400 response with the message:
     *
     * ```
     * Analysis specified is not deletable.
     * ```
     *
     * The response from a successful `DELETE` operation provides you with
     * two alternative URLs for deleting the next analysis in the set
     * (see the example default response below).
     * Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
     * in the set. This is a useful option if you want to preserve at least one analysis
     * for the specified tool in your repository.
     * Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
     * When you delete the last analysis in a set the value of `next_analysis_url` and `confirm_delete_url`
     * in the 200 response is `null`.
     *
     * As an example of the deletion process,
     * let's imagine that you added a workflow that configured a particular code scanning tool
     * to analyze the code in a repository. This tool has added 15 analyses:
     * 10 on the default branch, and another 5 on a topic branch.
     * You therefore have two separate sets of analyses for this tool.
     * You've now decided that you want to remove all of the analyses for the tool.
     * To do this you must make 15 separate deletion requests.
     * To start, you must find the deletable analysis for one of the sets,
     * step through deleting the analyses in that set,
     * and then repeat the process for the second set.
     * The procedure therefore consists of a nested loop:
     *
     * **Outer loop**:
     * * List the analyses for the repository, filtered by tool.
     * * Parse this list to find a deletable analysis. If found:
     *
     *   **Inner loop**:
     *   * Delete the identified analysis.
     *   * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.
     *
     * The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#delete-a-code-scanning-analysis-from-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `analysis_id: i64` -- The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.
     * * `confirm_delete: &str` -- Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`.
     */
    pub async fn code_scanning_delete_analysis(
        &self,
        owner: &str,
        repo: &str,
        analysis_id: i64,
        confirm_delete: &str,
    ) -> Result<types::CodeScanningAnalysisDeletion> {
        let url = format!(
            "/repos/{}/{}/code-scanning/analyses/{}?confirm_delete={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&analysis_id.to_string()),
            confirm_delete.to_string(),
        );

        self.delete(&url, None).await
    }

    /**
     * Upload an analysis as SARIF data.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/code-scanning/sarifs` endpoint.
     *
     * Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
     *
     * There are two places where you can upload code scanning results.
     *  - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
     *  - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
     *
     * You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:
     *
     * ```
     * gzip -c analysis-data.sarif | base64 -w0
     * ```
     *
     * SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool generates too many results, you should update the analysis configuration to run only the most important rules or queries.
     *
     * The `202 Accepted`, response includes an `id` value.
     * You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}` endpoint.
     * For more information, see "[Get information about a SARIF upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload)."
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#upload-a-sarif-file>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn code_scanning_upload_sarif(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CodeScanningUploadSarifRequest,
    ) -> Result<types::CodeScanningSarifsReceipt> {
        let url = format!(
            "/repos/{}/{}/code-scanning/sarifs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get information about a SARIF upload.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}` endpoint.
     *
     * Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/code-scanning#list-recent-code-scanning-analyses-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sarif_id: &str` -- The SARIF ID obtained after uploading.
     */
    pub async fn code_scanning_get_sarif(&self, owner: &str, repo: &str, sarif_id: &str) -> Result<types::CodeScanningSarifsStatus> {
        let url = format!(
            "/repos/{}/{}/code-scanning/sarifs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&sarif_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List repository collaborators.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators` endpoint.
     *
     * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
     *
     * Team members will include the members of child teams.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-collaborators>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `affiliation: crate::types::ProjectsListCollaboratorsAffiliation` -- Filter collaborators returned by their affiliation. Can be one of:  
     *  \* `outside`: All outside collaborators of an organization-owned repository.  
     *  \* `direct`: All collaborators with permissions to an organization-owned repository, regardless of organization membership status.  
     *  \* `all`: All collaborators the authenticated user can see.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_collaborators(
        &self,
        owner: &str,
        repo: &str,
        affiliation: crate::types::ProjectsListCollaboratorsAffiliation,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Collaborator>> {
        let url = format!(
            "/repos/{}/{}/collaborators?affiliation={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            affiliation,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check if a user is a repository collaborator.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
     *
     * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
     *
     * Team members will include the members of child teams.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#check-if-a-user-is-a-repository-collaborator>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `username: &str`
     */
    pub async fn repos_check_collaborator(&self, owner: &str, repo: &str, username: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add a repository collaborator.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * For more information the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/rest/reference/repos#invitations).
     *
     * **Rate limits**
     *
     * To prevent abuse, you are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#add-a-repository-collaborator>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `username: &str`
     */
    pub async fn repos_add_collaborator(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
        body: &types::ReposAddCollaboratorRequest,
    ) -> Result<types::RepositoryInvitation> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove a repository collaborator.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#remove-a-repository-collaborator>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `username: &str`
     */
    pub async fn repos_remove_collaborator(&self, owner: &str, repo: &str, username: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get repository permissions for a user.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators/{username}/permission` endpoint.
     *
     * Checks the repository permission of a collaborator. The possible repository permissions are `admin`, `write`, `read`, and `none`.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-repository-permissions-for-a-user>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `username: &str`
     */
    pub async fn repos_get_collaborator_permission_level(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
    ) -> Result<types::RepositoryCollaboratorPermission> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}/permission",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List commit comments for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/comments` endpoint.
     *
     * Commit Comments use [these custom media types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more about the use of media types in the API [here](https://docs.github.com/rest/overview/media-types/).
     *
     * Comments are ordered by ascending ID.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-commit-comments-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_commit_comments_for_repo(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::CommitComment>> {
        let url = format!(
            "/repos/{}/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a commit comment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn repos_get_commit_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a commit comment.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn repos_delete_commit_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a commit comment.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn repos_update_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::ReposUpdateCommitCommentRequest,
    ) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for a commit comment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions` endpoint.
     *
     * List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a commit comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions` endpoint.
     *
     * Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn reactions_create_for_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::ReactionsCreateCommitCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a commit comment reaction.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
     *
     * Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-a-commit-comment-reaction>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_commit_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List commits.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits` endpoint.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-commits>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sha: &str` -- SHA or branch to start listing commits from. Default: the repositorys default branch (usually `master`).
     * * `path: &str` -- Only commits containing this file path will be returned.
     * * `author: &str` -- GitHub login or email address by which to filter by commit author.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `until: DateTime<Utc>` -- Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_commits(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        path: &str,
        author: &str,
        since: DateTime<Utc>,
        until: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Tree>> {
        let url = format!(
            "/repos/{}/{}/commits?author={}&page={}&path={}&per_page={}&sha={}&since={}&until={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            author.to_string(),
            format!("{}", page),
            path.to_string(),
            format!("{}", per_page),
            sha.to_string(),
            since.to_rfc3339(),
            until.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List branches for HEAD commit.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head` endpoint.
     *
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-branches-for-head-commit>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `commit_sha: &str` -- commit_sha parameter.
     */
    pub async fn repos_list_branches_for_head_commit(&self, owner: &str, repo: &str, commit_sha: &str) -> Result<Vec<types::BranchShort>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/branches-where-head",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List commit comments.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/comments` endpoint.
     *
     * Use the `:commit_sha` to specify the commit that will have its comments listed.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-commit-comments>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `commit_sha: &str` -- commit_sha parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_comments_for_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::CommitComment>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a commit comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/commits/{commit_sha}/comments` endpoint.
     *
     * Create a comment for a commit using its `:commit_sha`.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-commit-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `commit_sha: &str` -- commit_sha parameter.
     */
    pub async fn repos_create_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        body: &types::ReposCreateCommitCommentRequest,
    ) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/commits/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List pull requests associated with a commit.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/pulls` endpoint.
     *
     * Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-pull-requests-associated-with-a-commit>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `commit_sha: &str` -- commit_sha parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_pull_requests_associated_with_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestSimple>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/pulls?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a commit.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}` endpoint.
     *
     * Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
     *
     * **Note:** If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
     *
     * You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property.
     *
     * To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-commit>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `ref_: &str` -- ref parameter.
     */
    pub async fn repos_get_commit(&self, owner: &str, repo: &str, page: i64, per_page: i64, ref_: &str) -> Result<types::Tree> {
        let url = format!(
            "/repos/{}/{}/commits/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List check runs for a Git reference.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/check-runs` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
     *
     * Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#list-check-runs-for-a-git-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     * * `check_name: &str` -- Returns check runs with the specified `name`.
     * * `status: crate::types::JobStatus` -- Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or `completed`.
     * * `filter: crate::types::ActionsListJobsWorkflowRunFilter` -- Filters check runs by their `completed_at` timestamp. Can be one of `latest` (returning the most recent check runs) or `all`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `app_id: i64`
     */
    pub async fn checks_list_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        check_name: &str,
        status: crate::types::JobStatus,
        filter: crate::types::ActionsListJobsWorkflowRunFilter,
        per_page: i64,
        page: i64,
        app_id: i64,
    ) -> Result<types::GetChecksListRefOkResponse> {
        let url = format!(
            "/repos/{}/{}/commits/{}/check-runs?app_id={}&check_name={}&filter={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", app_id),
            check_name.to_string(),
            filter,
            format!("{}", page),
            format!("{}", per_page),
            status,
        );

        self.get(&url).await
    }

    /**
     * List check suites for a Git reference.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/check-suites` endpoint.
     *
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/checks#list-check-suites-for-a-git-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     * * `app_id: i64` -- Filters check suites by GitHub App `id`.
     * * `check_name: &str` -- Returns check runs with the specified `name`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn checks_list_suites_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        app_id: i64,
        check_name: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetChecksListSuitesRefOkResponse> {
        let url = format!(
            "/repos/{}/{}/commits/{}/check-suites?app_id={}&check_name={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", app_id),
            check_name.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get the combined status for a specific reference.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/status` endpoint.
     *
     * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
     *
     * The most recent status for each context is returned, up to 100. This field [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there are over 100 contexts.
     *
     * Additionally, a combined `state` is returned. The `state` is one of:
     *
     * *   **failure** if any of the contexts report as `error` or `failure`
     * *   **pending** if there are no statuses or a context is `pending`
     * *   **success** if the latest status for all contexts is `success`
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-combined-status-for-a-specific-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_get_combined_status_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::CombinedCommitStatus> {
        let url = format!(
            "/repos/{}/{}/commits/{}/status?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * List commit statuses for a reference.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/statuses` endpoint.
     *
     * Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
     *
     * This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-commit-statuses-for-a-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_commit_statuses_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Status>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/statuses?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the code of conduct for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/community/code_of_conduct` endpoint.
     *
     * Returns the contents of the repository's code of conduct file, if one is detected.
     *
     * A code of conduct is detected if there is a file named `CODE_OF_CONDUCT` in the root directory of the repository. GitHub detects which code of conduct it is using fuzzy matching.
     *
     * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-the-code-of-conduct-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn codes_of_conduct_get_for_repo(&self, owner: &str, repo: &str) -> Result<types::CodeOfConduct> {
        let url = format!(
            "/repos/{}/{}/community/code_of_conduct",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get community profile metrics.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/community/profile` endpoint.
     *
     * This endpoint will return all community profile metrics, including an
     * overall health score, repository description, the presence of documentation, detected
     * code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
     * README, and CONTRIBUTING files.
     *
     * The `health_percentage` score is defined as a percentage of how many of
     * these four documents are present: README, CONTRIBUTING, LICENSE, and
     * CODE_OF_CONDUCT. For example, if all four documents are present, then
     * the `health_percentage` is `100`. If only one is present, then the
     * `health_percentage` is `25`.
     *
     * `content_reports_enabled` is only returned for organization-owned repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-community-profile-metrics>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_community_profile_metrics(&self, owner: &str, repo: &str) -> Result<types::CommunityProfile> {
        let url = format!(
            "/repos/{}/{}/community/profile",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Compare two commits.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/compare/{basehead}` endpoint.
     *
     * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
     *
     * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
     *
     * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
     *
     * **Working with large comparisons**
     *
     * To process a response with a large number of commits, you can use (`per_page` or `page`) to paginate the results. When using paging, the list of changed files is only returned with page 1, but includes all changed files for the entire comparison. For more information on working with pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
     *
     * When calling this API without any paging parameters (`per_page` or `page`), the returned list is limited to 250 commits and the last commit in the list is the most recent of the entire comparison. When a paging parameter is specified, the first commit in the returned list of each page is the earliest.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/repos#compare-two-commits>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `basehead: &str` -- The base branch and head branch to compare. This parameter expects the format `{base}...{head}`.
     */
    pub async fn repos_compare_commits(&self, owner: &str, repo: &str, page: i64, per_page: i64, basehead: &str) -> Result<types::CommitComparison> {
        let url = format!(
            "/repos/{}/{}/compare/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&basehead.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Create a content attachment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments` endpoint.
     *
     * Creates an attachment under a content reference URL in the body or comment of an issue or pull request. Use the `id` and `repository` `full_name` of the content reference from the [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to create an attachment.
     *
     * The app must create a content attachment within six hours of the content reference URL being posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)" for details about content attachments.
     *
     * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#create-a-content-attachment>
     *
     * **Parameters:**
     *
     * * `owner: &str` -- The owner of the repository. Determined from the `repository` `full_name` of the `content_reference` event.
     * * `repo: &str` -- The name of the repository. Determined from the `repository` `full_name` of the `content_reference` event.
     * * `content_reference_id: i64` -- The `id` of the `content_reference` event.
     */
    pub async fn apps_create_content_attachment(
        &self,
        owner: &str,
        repo: &str,
        content_reference_id: i64,
        body: &types::AppsCreateContentAttachmentRequest,
    ) -> Result<types::ContentReferenceAttachment> {
        let url = format!(
            "/repos/{}/{}/content_references/{}/attachments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&content_reference_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get repository content.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
     *
     * Gets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit
     * `:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories.
     *
     * Files and symlinks support [a custom media type](https://docs.github.com/rest/reference/repos#custom-media-types) for
     * retrieving the raw content or rendered HTML (when supported). All content types support [a custom media
     * type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent
     * object format.
     *
     * **Note**:
     * *   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/reference/git#trees).
     * *   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
     * API](https://docs.github.com/rest/reference/git#get-a-tree).
     * *   This API supports files up to 1 megabyte in size.
     *
     * #### If the content is a directory
     * The response will be an array of objects, one object for each item in the directory.
     * When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value
     * _should_ be "submodule". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).
     * In the next major version of the API, the type will be returned as "submodule".
     *
     * #### If the content is a symlink
     * If the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the
     * API responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object
     * describing the symlink itself.
     *
     * #### If the content is a submodule
     * The `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific
     * commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out
     * the submodule at that specific commit.
     *
     * If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the
     * github.com URLs (`html_url` and `_links["html"]`) will have null values.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-repository-content>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `path: &str` -- path parameter.
     * * `ref_: &str` -- The name of the commit/branch/tag. Default: the repositorys default branch (usually `master`).
     */
    pub async fn repos_get_content(&self, owner: &str, repo: &str, path: &str, ref_: &str) -> Result<Vec<types::Entries>> {
        let url = format!(
            "/repos/{}/{}/contents/{}?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
            ref_,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create or update file contents.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
     *
     * Creates a new file or replaces an existing file in a repository.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-or-update-file-contents>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `path: &str` -- path parameter.
     */
    pub async fn repos_create_or_update_file_contents(
        &self,
        owner: &str,
        repo: &str,
        path: &str,
        body: &types::ReposCreateUpdateFileContentsRequest,
    ) -> Result<types::FileCommit> {
        let url = format!(
            "/repos/{}/{}/contents/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a file.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
     *
     * Deletes a file in a repository.
     *
     * You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
     *
     * The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
     *
     * You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-file>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `path: &str` -- path parameter.
     */
    pub async fn repos_delete_file(&self, owner: &str, repo: &str, path: &str, body: &types::ReposDeleteFileRequest) -> Result<types::FileCommit> {
        let url = format!(
            "/repos/{}/{}/contents/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List repository contributors.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/contributors` endpoint.
     *
     * Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API v3 caches contributor data to improve performance.
     *
     * GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-contributors>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `anon: &str` -- Set to `1` or `true` to include anonymous contributors in results.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_contributors(&self, owner: &str, repo: &str, anon: &str, per_page: i64, page: i64) -> Result<Vec<types::Contributor>> {
        let url = format!(
            "/repos/{}/{}/contributors?anon={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            anon.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List deployments.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments` endpoint.
     *
     * Simple filtering of deployments is available via query parameters:
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-deployments>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sha: &str` -- The SHA recorded at creation time.
     * * `ref_: &str` -- The name of the ref. This can be a branch, tag, or SHA.
     * * `task: &str` -- The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
     * * `environment: &str` -- The name of the environment that was deployed to (e.g., `staging` or `production`).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_deployments(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        ref_: &str,
        task: &str,
        environment: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Deployment>> {
        let url = format!(
            "/repos/{}/{}/deployments?environment={}&page={}&per_page={}&ref={}&sha={}&task={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            environment.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
            sha.to_string(),
            task.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a deployment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/deployments` endpoint.
     *
     * Deployments offer a few configurable parameters with certain defaults.
     *
     * The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
     * before we merge a pull request.
     *
     * The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
     * multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
     * makes it easier to track which environments have requested deployments. The default environment is `production`.
     *
     * The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
     * the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
     * the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
     * return a failure response.
     *
     * By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every submitted context must be in a `success`
     * state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
     * specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
     * not require any contexts or create any commit statuses, the deployment will always succeed.
     *
     * The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
     * field that will be passed on when a deployment event is dispatched.
     *
     * The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
     * be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
     * application with debugging enabled.
     *
     * Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
     *
     * #### Merged branch response
     * You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
     * a deployment. This auto-merge happens when:
     * *   Auto-merge option is enabled in the repository
     * *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
     * *   There are no merge conflicts
     *
     * If there are no new commits in the base branch, a new request to create a deployment should give a successful
     * response.
     *
     * #### Merge conflict response
     * This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
     * be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
     *
     * #### Failed commit status checks
     * This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
     * status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-deployment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_deployment(&self, owner: &str, repo: &str, body: &types::ReposCreateDeploymentRequest) -> Result<types::Deployment> {
        let url = format!(
            "/repos/{}/{}/deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a deployment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-deployment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `deployment_id: i64` -- deployment_id parameter.
     */
    pub async fn repos_get_deployment(&self, owner: &str, repo: &str, deployment_id: i64) -> Result<types::Deployment> {
        let url = format!(
            "/repos/{}/{}/deployments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a deployment.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/deployments/{deployment_id}` endpoint.
     *
     * To ensure there can always be an active deployment, you can only delete an _inactive_ deployment. Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
     *
     * To set a deployment as inactive, you must:
     *
     * *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
     * *   Mark the active deployment as inactive by adding any non-successful deployment status.
     *
     * For more information, see "[Create a deployment](https://docs.github.com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/reference/repos#create-a-deployment-status)."
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-deployment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `deployment_id: i64` -- deployment_id parameter.
     */
    pub async fn repos_delete_deployment(&self, owner: &str, repo: &str, deployment_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/deployments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List deployment statuses.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses` endpoint.
     *
     * Users with pull access can view deployment statuses for a deployment:
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-deployment-statuses>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `deployment_id: i64` -- deployment_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_deployment_statuses(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::DeploymentStatus>> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a deployment status.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses` endpoint.
     *
     * Users with `push` access can create deployment statuses for a given deployment.
     *
     * GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-deployment-status>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `deployment_id: i64` -- deployment_id parameter.
     */
    pub async fn repos_create_deployment_status(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
        body: &types::ReposCreateDeploymentStatusRequest,
    ) -> Result<types::DeploymentStatus> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a deployment status.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}` endpoint.
     *
     * Users with pull access can view a deployment status for a deployment:
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-deployment-status>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `deployment_id: i64` -- deployment_id parameter.
     * * `status_id: i64`
     */
    pub async fn repos_get_deployment_status(&self, owner: &str, repo: &str, deployment_id: i64, status_id: i64) -> Result<types::DeploymentStatus> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
            progenitor_support::encode_path(&status_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create a repository dispatch event.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/dispatches` endpoint.
     *
     * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
     *
     * The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
     *
     * This endpoint requires write access to the repository by providing either:
     *
     *   - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access token for the command line](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help documentation.
     *   - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
     *
     * This input example shows how you can use the `client_payload` as a test to debug your workflow.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-dispatch-event>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_dispatch_event(&self, owner: &str, repo: &str, body: &types::ReposCreateDispatchEventRequest) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/dispatches",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get all environments.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/environments` endpoint.
     *
     * Get all environments for a repository.
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-all-environments>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_all_environments(&self, owner: &str, repo: &str) -> Result<types::GetReposAllEnvironmentsOkResponse> {
        let url = format!(
            "/repos/{}/{}/environments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get an environment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-an-environment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `environment_name: &str` -- The name of the environment.
     */
    pub async fn repos_get_environment(&self, owner: &str, repo: &str, environment_name: &str) -> Result<types::Environment> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update an environment.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
     *
     * Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
     *
     * **Note:** Although you can use this operation to specify that only branches that match specified name patterns can deploy to this environment, you must use the UI to set the name patterns. For more information, see "[Environments](/actions/reference/environments#deployment-branches)."
     *
     * **Note:** To create or update secrets for an environment, see "[Secrets](/rest/reference/actions#secrets)."
     *
     * You must authenticate using an access token with the repo scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-or-update-an-environment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `environment_name: &str` -- The name of the environment.
     */
    pub async fn repos_create_or_update_environment(
        &self,
        owner: &str,
        repo: &str,
        environment_name: &str,
        body: &types::ReposCreateUpdateEnvironmentRequest,
    ) -> Result<types::Environment> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an environment.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
     *
     * You must authenticate using an access token with the repo scope to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-an-environment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `environment_name: &str` -- The name of the environment.
     */
    pub async fn repos_delete_an_environment(&self, owner: &str, repo: &str, environment_name: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repository events.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repository-events>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_repo_events(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/repos/{}/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List forks.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/forks` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-forks>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sort: crate::types::ReposListForksSort` -- The sort order. Can be either `newest`, `oldest`, or `stargazers`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_forks(
        &self,
        owner: &str,
        repo: &str,
        sort: crate::types::ReposListForksSort,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/repos/{}/{}/forks?page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a fork.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/forks` endpoint.
     *
     * Create a fork for the authenticated user.
     *
     * **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact) or [GitHub Premium Support](https://premium.githubsupport.com).
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-fork>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_fork(&self, owner: &str, repo: &str, body: &types::ReposCreateForkRequest) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}/forks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a blob.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/git/blobs` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/git#create-a-blob>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn git_create_blob(&self, owner: &str, repo: &str, body: &types::GitCreateBlobRequest) -> Result<types::ShortBlob> {
        let url = format!(
            "/repos/{}/{}/git/blobs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a blob.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/blobs/{file_sha}` endpoint.
     *
     * The `content` in the response will always be Base64 encoded.
     *
     * _Note_: This API supports blobs up to 100 megabytes in size.
     *
     * FROM: <https://docs.github.com/rest/reference/git#get-a-blob>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `file_sha: &str`
     */
    pub async fn git_get_blob(&self, owner: &str, repo: &str, file_sha: &str) -> Result<types::Blob> {
        let url = format!(
            "/repos/{}/{}/git/blobs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&file_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create a commit.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/git/commits` endpoint.
     *
     * Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/git#create-a-commit>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn git_create_commit(&self, owner: &str, repo: &str, body: &types::GitCreateCommitRequest) -> Result<types::GitCommit> {
        let url = format!(
            "/repos/{}/{}/git/commits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a commit.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/commits/{commit_sha}` endpoint.
     *
     * Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/git#get-a-commit>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `commit_sha: &str` -- commit_sha parameter.
     */
    pub async fn git_get_commit(&self, owner: &str, repo: &str, commit_sha: &str) -> Result<types::GitCommit> {
        let url = format!(
            "/repos/{}/{}/git/commits/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List matching references.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/matching-refs/{ref}` endpoint.
     *
     * Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.
     *
     * When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.
     *
     * **Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     *
     * If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
     *
     * FROM: <https://docs.github.com/rest/reference/git#list-matching-references>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn git_list_matching_refs(&self, owner: &str, repo: &str, ref_: &str, per_page: i64, page: i64) -> Result<Vec<types::GitRef>> {
        let url = format!(
            "/repos/{}/{}/git/matching-refs/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a reference.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/ref/{ref}` endpoint.
     *
     * Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.
     *
     * **Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     *
     * FROM: <https://docs.github.com/rest/reference/git#get-a-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     */
    pub async fn git_get_ref(&self, owner: &str, repo: &str, ref_: &str) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/ref/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create a reference.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/git/refs` endpoint.
     *
     * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
     *
     * FROM: <https://docs.github.com/rest/reference/git#create-a-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn git_create_ref(&self, owner: &str, repo: &str, body: &types::GitCreateRefRequest) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/refs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a reference.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/git/refs/{ref}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/git#delete-a-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     */
    pub async fn git_delete_ref(&self, owner: &str, repo: &str, ref_: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/git/refs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a reference.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/git/refs/{ref}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/git#update-a-reference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- ref parameter.
     */
    pub async fn git_update_ref(&self, owner: &str, repo: &str, ref_: &str, body: &types::GitUpdateRefRequest) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/refs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a tag object.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/git/tags` endpoint.
     *
     * Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/git#create-a-tag-object>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn git_create_tag(&self, owner: &str, repo: &str, body: &types::GitCreateTagRequest) -> Result<types::GitTag> {
        let url = format!(
            "/repos/{}/{}/git/tags",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a tag.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/tags/{tag_sha}` endpoint.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     *
     * FROM: <https://docs.github.com/rest/reference/git#get-a-tag>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `tag_sha: &str`
     */
    pub async fn git_get_tag(&self, owner: &str, repo: &str, tag_sha: &str) -> Result<types::GitTag> {
        let url = format!(
            "/repos/{}/{}/git/tags/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tag_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create a tree.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/git/trees` endpoint.
     *
     * The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.
     *
     * If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a reference](https://docs.github.com/rest/reference/git#update-a-reference)."
     *
     * FROM: <https://docs.github.com/rest/reference/git#create-a-tree>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn git_create_tree(&self, owner: &str, repo: &str, body: &types::GitCreateTreeRequestData) -> Result<types::GitTree> {
        let url = format!(
            "/repos/{}/{}/git/trees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a tree.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/git/trees/{tree_sha}` endpoint.
     *
     * Returns a single tree using the SHA1 value for that tree.
     *
     * If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.
     *
     * FROM: <https://docs.github.com/rest/reference/git#get-a-tree>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `tree_sha: &str`
     * * `recursive: &str` -- Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.
     */
    pub async fn git_get_tree(&self, owner: &str, repo: &str, tree_sha: &str, recursive: &str) -> Result<types::GitTree> {
        let url = format!(
            "/repos/{}/{}/git/trees/{}?recursive={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tree_sha.to_string()),
            recursive.to_string(),
        );

        self.get(&url).await
    }

    /**
     * List repository webhooks.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-webhooks>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_webhooks(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Hook>> {
        let url = format!(
            "/repos/{}/{}/hooks?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a repository webhook.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks` endpoint.
     *
     * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
     * share the same `config` as long as those webhooks do not have any `events` that overlap.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_webhook(&self, owner: &str, repo: &str, body: &types::ReposCreateWebhookRequest) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a repository webhook.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
     *
     * Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)."
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_get_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a repository webhook.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_delete_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a repository webhook.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
     *
     * Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)."
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_update_webhook(&self, owner: &str, repo: &str, hook_id: i64, body: &types::ReposUpdateWebhookRequest) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a webhook configuration for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks/{hook_id}/config` endpoint.
     *
     * Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/reference/orgs#get-a-repository-webhook)."
     *
     * Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read` permission.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-webhook-configuration-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_get_webhook_config_for_repo(&self, owner: &str, repo: &str, hook_id: i64) -> Result<types::WebhookConfig> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/config",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a webhook configuration for a repository.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/hooks/{hook_id}/config` endpoint.
     *
     * Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/reference/orgs#update-a-repository-webhook)."
     *
     * Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write` permission.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-webhook-configuration-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_update_webhook_config_for_repo(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
        body: &types::AppsUpdateWebhookConfigAppRequest,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/config",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Ping a repository webhook.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks/{hook_id}/pings` endpoint.
     *
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#ping-a-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_ping_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/pings",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Test the push repository webhook.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks/{hook_id}/tests` endpoint.
     *
     * This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
     *
     * **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`
     *
     * FROM: <https://docs.github.com/rest/reference/repos#test-the-push-repository-webhook>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `hook_id: i64`
     */
    pub async fn repos_test_push_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/tests",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get an import status.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/import` endpoint.
     *
     * View the progress of an import.
     *
     * **Import status**
     *
     * This section includes details about the possible values of the `status` field of the Import Progress response.
     *
     * An import that does not have errors will progress through these steps:
     *
     * *   `detecting` - the "detection" step of the import is in progress because the request did not include a `vcs` parameter. The import is identifying the type of source control present at the URL.
     * *   `importing` - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include `commit_count` (the total number of raw commits that will be imported) and `percent` (0 - 100, the current progress through the import).
     * *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.
     * *   `pushing` - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include `push_percent`, which is the percent value reported by `git push` when it is "Writing objects".
     * *   `complete` - the import is complete, and the repository is ready on GitHub.
     *
     * If there are problems, you will see one of these in the `status` field:
     *
     * *   `auth_failed` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
     * *   `error` - the import encountered an error. The import progress response will include the `failed_step` and an error message. Contact [GitHub Support](https://support.github.com/contact) or [GitHub Premium Support](https://premium.githubsupport.com) for more information.
     * *   `detection_needs_auth` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
     * *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import) and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct URL.
     * *   `detection_found_multiple` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a `project_choices` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
     *
     * **The project_choices field**
     *
     * When multiple projects are found at the provided URL, the response hash will include a `project_choices` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.
     *
     * **Git LFS related fields**
     *
     * This section includes details about Git LFS related fields that may be present in the Import Progress response.
     *
     * *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
     * *   `has_large_files` - the boolean value describing whether files larger than 100MB were found during the `importing` step.
     * *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the originating repository.
     * *   `large_files_count` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a "Get Large Files" request.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#get-an-import-status>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_get_import_status(&self, owner: &str, repo: &str) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Start an import.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/import` endpoint.
     *
     * Start a source import to a GitHub repository using GitHub Importer.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#start-an-import>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_start_import(&self, owner: &str, repo: &str, body: &types::MigrationsStartImportRequest) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Cancel an import.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/import` endpoint.
     *
     * Stop an import for a repository.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#cancel-an-import>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_cancel_import(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an import.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import` endpoint.
     *
     * An import can be updated with credentials or a project choice by passing in the appropriate parameters in this API
     * request. If no parameters are provided, the import will be restarted.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#update-an-import>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_update_import(&self, owner: &str, repo: &str, body: &types::MigrationsUpdateImportRequest) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get commit authors.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/import/authors` endpoint.
     *
     * Each type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username `hubot` into something like `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
     *
     * This endpoint and the [Map a commit author](https://docs.github.com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git author information.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#get-commit-authors>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `since: i64` -- A user ID. Only return users with an ID greater than this ID.
     */
    pub async fn migrations_get_commit_authors(&self, owner: &str, repo: &str, since: i64) -> Result<Vec<types::PorterAuthor>> {
        let url = format!(
            "/repos/{}/{}/import/authors?since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", since),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Map a commit author.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import/authors/{author_id}` endpoint.
     *
     * Update an author's identity for the import. Your application can continue updating authors any time before you push new commits to the repository.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#map-a-commit-author>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `author_id: i64`
     */
    pub async fn migrations_map_commit_author(
        &self,
        owner: &str,
        repo: &str,
        author_id: i64,
        body: &types::MigrationsMapCommitAuthorRequest,
    ) -> Result<types::PorterAuthor> {
        let url = format!(
            "/repos/{}/{}/import/authors/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&author_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get large files.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/import/large_files` endpoint.
     *
     * List files larger than 100MB found during the import
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#get-large-files>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_get_large_files(&self, owner: &str, repo: &str) -> Result<Vec<types::PorterLargeFile>> {
        let url = format!(
            "/repos/{}/{}/import/large_files",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Update Git LFS preference.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import/lfs` endpoint.
     *
     * You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about our LFS feature and working with large files [on our help site](https://help.github.com/articles/versioning-large-files/).
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#update-git-lfs-preference>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn migrations_set_lfs_preference(
        &self,
        owner: &str,
        repo: &str,
        body: &types::MigrationsSetLfsPreferenceRequest,
    ) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import/lfs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a repository installation for the authenticated app.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/installation` endpoint.
     *
     * Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-a-repository-installation-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn apps_get_repo_installation(&self, owner: &str, repo: &str) -> Result<types::Installation> {
        let url = format!(
            "/repos/{}/{}/installation",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get interaction restrictions for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
     *
     * Shows which type of GitHub user can interact with this repository and when the restriction expires. If there are no restrictions, you will see an empty response.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn interactions_get_restrictions_for_repo(&self, owner: &str, repo: &str) -> Result<types::InteractionLimitResponse> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set interaction restrictions for a repository.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
     *
     * Temporarily restricts interactions to a certain type of GitHub user within the given repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn interactions_set_restrictions_for_repo(
        &self,
        owner: &str,
        repo: &str,
        body: &types::InteractionLimit,
    ) -> Result<types::InteractionLimitResponse> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove interaction restrictions for a repository.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
     *
     * Removes all interaction restrictions from the given repository. You must have owner or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn interactions_remove_restrictions_for_repo(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repository invitations.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/invitations` endpoint.
     *
     * When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-invitations>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_invitations(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::RepositoryInvitation>> {
        let url = format!(
            "/repos/{}/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Delete a repository invitation.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/invitations/{invitation_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository-invitation>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `invitation_id: i64` -- invitation_id parameter.
     */
    pub async fn repos_delete_invitation(&self, owner: &str, repo: &str, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/invitations/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a repository invitation.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/invitations/{invitation_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-repository-invitation>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `invitation_id: i64` -- invitation_id parameter.
     */
    pub async fn repos_update_invitation(
        &self,
        owner: &str,
        repo: &str,
        invitation_id: i64,
        body: &types::ReposUpdateInvitationRequest,
    ) -> Result<types::RepositoryInvitation> {
        let url = format!(
            "/repos/{}/{}/invitations/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List repository issues.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues` endpoint.
     *
     * List issues in a repository.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-repository-issues>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `milestone: &str` -- If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
     * * `state: crate::types::IssuesListState` -- Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
     * * `assignee: &str` -- Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
     * * `creator: &str` -- The user that created the issue.
     * * `mentioned: &str` -- A user that's mentioned in the issue.
     * * `labels: &str` -- A list of comma separated label names. Example: `bug,ui,@high`.
     * * `sort: crate::types::IssuesListSort` -- What to sort results by. Can be either `created`, `updated`, `comments`.
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_for_repo(
        &self,
        owner: &str,
        repo: &str,
        milestone: &str,
        state: crate::types::IssuesListState,
        assignee: &str,
        creator: &str,
        mentioned: &str,
        labels: &str,
        sort: crate::types::IssuesListSort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueSimple>> {
        let url = format!(
            "/repos/{}/{}/issues?assignee={}&creator={}&direction={}&labels={}&mentioned={}&milestone={}&page={}&per_page={}&since={}&sort={}&\
             state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            assignee.to_string(),
            creator.to_string(),
            direction,
            labels.to_string(),
            mentioned.to_string(),
            milestone.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an issue.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues` endpoint.
     *
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#create-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn issues_create(&self, owner: &str, repo: &str, body: &types::IssuesCreateRequest) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List issue comments for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments` endpoint.
     *
     * By default, Issue Comments are ordered by ascending ID.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-issue-comments-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- Either `asc` or `desc`. Ignored without the `sort` parameter.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_comments_for_repo(
        &self,
        owner: &str,
        repo: &str,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueComment>> {
        let url = format!(
            "/repos/{}/{}/issues/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get an issue comment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn issues_get_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete an issue comment.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#delete-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn issues_delete_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an issue comment.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#update-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn issues_update_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::IssuesUpdateCommentRequest,
    ) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for an issue comment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions` endpoint.
     *
     * List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_issue_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for an issue comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions` endpoint.
     *
     * Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn reactions_create_for_issue_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::ReactionsCreateIssueCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an issue comment reaction.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
     *
     * Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-an-issue-comment-reaction>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_issue_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List issue events for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-issue-events-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_events_for_repo(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::IssueEvent>> {
        let url = format!(
            "/repos/{}/{}/issues/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get an issue event.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/events/{event_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue-event>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `event_id: i64`
     */
    pub async fn issues_get_event(&self, owner: &str, repo: &str, event_id: i64) -> Result<types::IssueEvent> {
        let url = format!(
            "/repos/{}/{}/issues/events/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&event_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get an issue.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}` endpoint.
     *
     * The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
     * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
     * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
     * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
     * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
     * to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_get(&self, owner: &str, repo: &str, issue_number: i64) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update an issue.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/issues/{issue_number}` endpoint.
     *
     * Issue owners and users with push access can edit an issue.
     *
     * FROM: <https://docs.github.com/rest/reference/issues/#update-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_update(&self, owner: &str, repo: &str, issue_number: i64, body: &types::IssuesUpdateRequest) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add assignees to an issue.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/assignees` endpoint.
     *
     * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#add-assignees-to-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_add_assignees(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::IssuesAddAssigneesRequest,
    ) -> Result<types::IssueSimple> {
        let url = format!(
            "/repos/{}/{}/issues/{}/assignees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove assignees from an issue.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/assignees` endpoint.
     *
     * Removes one or more assignees from an issue.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#remove-assignees-from-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_remove_assignees(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::IssuesRemoveAssigneesRequest,
    ) -> Result<types::IssueSimple> {
        let url = format!(
            "/repos/{}/{}/issues/{}/assignees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List issue comments.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/comments` endpoint.
     *
     * Issue Comments are ordered by ascending ID.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-issue-comments>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_comments(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueComment>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/comments?page={}&per_page={}&since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create an issue comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/comments` endpoint.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#create-an-issue-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_create_comment(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::IssuesUpdateCommentRequest,
    ) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List issue events.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-issue-events>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_events(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueEventFor>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List labels for an issue.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_labels_on_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Set labels for an issue.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
     *
     * Removes any previous labels and sets the new labels for an issue.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#set-labels-for-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_set_labels(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::IssuesAddLabelsRequest,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Add labels to an issue.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#add-labels-to-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_add_labels(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::IssuesAddLabelsRequest,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove all labels from an issue.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#remove-all-labels-from-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_remove_all_labels(&self, owner: &str, repo: &str, issue_number: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Remove a label from an issue.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}` endpoint.
     *
     * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#remove-a-label-from-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `name: &str`
     */
    pub async fn issues_remove_label(&self, owner: &str, repo: &str, issue_number: i64, name: &str) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Lock an issue.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/issues/{issue_number}/lock` endpoint.
     *
     * Users with push access can lock an issue or pull request's conversation.
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/issues#lock-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_lock(&self, owner: &str, repo: &str, issue_number: i64, body: &types::IssuesLockRequest) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/lock",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Unlock an issue.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/lock` endpoint.
     *
     * Users with push access can unlock an issue's conversation.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#unlock-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn issues_unlock(&self, owner: &str, repo: &str, issue_number: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/lock",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List reactions for an issue.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions` endpoint.
     *
     * List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for an issue.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions` endpoint.
     *
     * Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     */
    pub async fn reactions_create_for_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::ReactionsCreateIssueRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an issue reaction.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
     *
     * Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-an-issue-reaction>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_issue(&self, owner: &str, repo: &str, issue_number: i64, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List timeline events for an issue.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/timeline` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-timeline-events-for-an-issue>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `issue_number: i64` -- issue_number parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_events_for_timeline(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TimelineIssueEvents>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/timeline?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List deploy keys.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/keys` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-deploy-keys>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_deploy_keys(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::DeployKey>> {
        let url = format!(
            "/repos/{}/{}/keys?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a deploy key.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/keys` endpoint.
     *
     * You can create a read-only deploy key.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-deploy-key>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_deploy_key(&self, owner: &str, repo: &str, body: &types::ReposCreateDeployKeyRequest) -> Result<types::DeployKey> {
        let url = format!(
            "/repos/{}/{}/keys",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a deploy key.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/keys/{key_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-deploy-key>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `key_id: i64` -- key_id parameter.
     */
    pub async fn repos_get_deploy_key(&self, owner: &str, repo: &str, key_id: i64) -> Result<types::DeployKey> {
        let url = format!(
            "/repos/{}/{}/keys/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a deploy key.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/keys/{key_id}` endpoint.
     *
     * Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-deploy-key>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `key_id: i64` -- key_id parameter.
     */
    pub async fn repos_delete_deploy_key(&self, owner: &str, repo: &str, key_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/keys/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List labels for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_labels_for_repo(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a label.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#create-a-label>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn issues_create_label(&self, owner: &str, repo: &str, body: &types::IssuesCreateLabelRequest) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a label.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#get-a-label>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `name: &str`
     */
    pub async fn issues_get_label(&self, owner: &str, repo: &str, name: &str) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a label.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#delete-a-label>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `name: &str`
     */
    pub async fn issues_delete_label(&self, owner: &str, repo: &str, name: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a label.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#update-a-label>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `name: &str`
     */
    pub async fn issues_update_label(&self, owner: &str, repo: &str, name: &str, body: &types::IssuesUpdateLabelRequest) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List repository languages.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/languages` endpoint.
     *
     * Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-languages>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_list_languages(&self, owner: &str, repo: &str) -> Result<types::Language> {
        let url = format!(
            "/repos/{}/{}/languages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get the license for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/license` endpoint.
     *
     * This method returns the contents of the repository's license file, if one is detected.
     *
     * Similar to [Get repository content](https://docs.github.com/rest/reference/repos#get-repository-content), this method also supports [custom media types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.
     *
     * FROM: <https://docs.github.com/rest/reference/licenses/#get-the-license-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn licenses_get_for_repo(&self, owner: &str, repo: &str) -> Result<types::LicenseContent> {
        let url = format!(
            "/repos/{}/{}/license",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Merge a branch.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/merges` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#merge-a-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_merge(&self, owner: &str, repo: &str, body: &types::ReposMergeRequest) -> Result<types::Tree> {
        let url = format!(
            "/repos/{}/{}/merges",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List milestones.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-milestones>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `state: crate::types::IssuesListState` -- The state of the milestone. Either `open`, `closed`, or `all`.
     * * `sort: crate::types::IssuesListMilestonesSort` -- What to sort results by. Either `due_on` or `completeness`.
     * * `direction: crate::types::Direction` -- The direction of the sort. Either `asc` or `desc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_milestones(
        &self,
        owner: &str,
        repo: &str,
        state: crate::types::IssuesListState,
        sort: crate::types::IssuesListMilestonesSort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Milestone>> {
        let url = format!(
            "/repos/{}/{}/milestones?direction={}&page={}&per_page={}&sort={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a milestone.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/milestones` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#create-a-milestone>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn issues_create_milestone(&self, owner: &str, repo: &str, body: &types::IssuesCreateMilestoneRequest) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a milestone.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#get-a-milestone>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `milestone_number: i64` -- milestone_number parameter.
     */
    pub async fn issues_get_milestone(&self, owner: &str, repo: &str, milestone_number: i64) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a milestone.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#delete-a-milestone>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `milestone_number: i64` -- milestone_number parameter.
     */
    pub async fn issues_delete_milestone(&self, owner: &str, repo: &str, milestone_number: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a milestone.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#update-a-milestone>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `milestone_number: i64` -- milestone_number parameter.
     */
    pub async fn issues_update_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
        body: &types::IssuesUpdateMilestoneRequest,
    ) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List labels for issues in a milestone.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones/{milestone_number}/labels` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-issues-in-a-milestone>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `milestone_number: i64` -- milestone_number parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_labels_for_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/milestones/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List repository notifications for the authenticated user.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/notifications` endpoint.
     *
     * List all notifications for the current user.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `all: bool` -- If `true`, show notifications marked as read.
     * * `participating: bool` -- If `true`, only shows notifications in which the user is directly participating or mentioned.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `before: DateTime<Utc>` -- Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_repo_notifications_for_authenticated_user(
        &self,
        owner: &str,
        repo: &str,
        all: bool,
        participating: bool,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Thread>> {
        let url = format!(
            "/repos/{}/{}/notifications?all={}&before={}&page={}&participating={}&per_page={}&since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", all),
            before.to_rfc3339(),
            format!("{}", page),
            format!("{}", participating),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Mark repository notifications as read.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/notifications` endpoint.
     *
     * Marks all notifications in a repository as "read" removes them from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#mark-repository-notifications-as-read>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_mark_repo_notifications_as_read(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ActivityMarkRepoNotificationsAsReadRequest,
    ) -> Result<types::PutPullsUpdateBranchAcceptedResponse> {
        let url = format!(
            "/repos/{}/{}/notifications",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a GitHub Pages site.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pages` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-github-pages-site>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_pages(&self, owner: &str, repo: &str) -> Result<types::Page> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update information about a GitHub Pages site.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/pages` endpoint.
     *
     * Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-information-about-a-github-pages-site>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_update_information_about_pages_site(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ReposUpdateInformationAboutPagesSiteRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a GitHub Pages site.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pages` endpoint.
     *
     * Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-github-pages-site>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_pages_site(&self, owner: &str, repo: &str, body: &types::ReposCreatePagesSiteRequest) -> Result<types::Page> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a GitHub Pages site.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pages` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-github-pages-site>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_delete_pages_site(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List GitHub Pages builds.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-github-pages-builds>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_pages_builds(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::PageBuild>> {
        let url = format!(
            "/repos/{}/{}/pages/builds?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Request a GitHub Pages build.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pages/builds` endpoint.
     *
     * You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
     *
     * Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#request-a-github-pages-build>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_request_pages_build(&self, owner: &str, repo: &str) -> Result<types::PageBuildStatus> {
        let url = format!(
            "/repos/{}/{}/pages/builds",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Get latest Pages build.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds/latest` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-latest-pages-build>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_latest_pages_build(&self, owner: &str, repo: &str) -> Result<types::PageBuild> {
        let url = format!(
            "/repos/{}/{}/pages/builds/latest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get GitHub Pages build.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds/{build_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-github-pages-build>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `build_id: i64`
     */
    pub async fn repos_get_pages_build(&self, owner: &str, repo: &str, build_id: i64) -> Result<types::PageBuild> {
        let url = format!(
            "/repos/{}/{}/pages/builds/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&build_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get a DNS health check for GitHub Pages.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/health` endpoint.
     *
     * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
     *
     * The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
     *
     * Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and `administration:write` permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-dns-health-check-for-github-pages>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_pages_health_check(&self, owner: &str, repo: &str) -> Result<types::PagesHealthCheck> {
        let url = format!(
            "/repos/{}/{}/pages/health",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List repository projects.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/projects` endpoint.
     *
     * Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-repository-projects>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `state: crate::types::IssuesListState` -- Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_for_repo(
        &self,
        owner: &str,
        repo: &str,
        state: crate::types::IssuesListState,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/repos/{}/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a repository project.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/projects` endpoint.
     *
     * Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
     *
     * FROM: <https://docs.github.com/rest/reference/projects#create-a-repository-project>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn projects_create_for_repo(&self, owner: &str, repo: &str, body: &types::ProjectsCreateOrgRequest) -> Result<types::Project> {
        let url = format!(
            "/repos/{}/{}/projects",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List pull requests.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls` endpoint.
     *
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-pull-requests>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `state: crate::types::IssuesListState` -- Either `open`, `closed`, or `all` to filter by state.
     * * `head: &str` -- Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.
     * * `base: &str` -- Filter pulls by base branch name. Example: `gh-pages`.
     * * `sort: crate::types::PullsListSort` -- What to sort results by. Can be either `created`, `updated`, `popularity` (comment count) or `long-running` (age, filtering by pulls updated in the last month).
     * * `direction: crate::types::Direction` -- The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list(
        &self,
        owner: &str,
        repo: &str,
        state: crate::types::IssuesListState,
        head: &str,
        base: &str,
        sort: crate::types::PullsListSort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestSimple>> {
        let url = format!(
            "/repos/{}/{}/pulls?base={}&direction={}&head={}&page={}&per_page={}&sort={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            base.to_string(),
            direction,
            head.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls` endpoint.
     *
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
     *
     * You can create a new pull request.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#create-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn pulls_create(&self, owner: &str, repo: &str, body: &types::PullsCreateRequest) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List review comments in a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments` endpoint.
     *
     * Lists review comments for all pull requests in a repository. By default, review comments are in ascending order by ID.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-review-comments-in-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sort: crate::types::PullsListReviewCommentsRepoSort`
     * * `direction: crate::types::Direction` -- Can be either `asc` or `desc`. Ignored without `sort` parameter.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_review_comments_for_repo(
        &self,
        owner: &str,
        repo: &str,
        sort: crate::types::PullsListReviewCommentsRepoSort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a review comment for a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
     *
     * Provides details for a review comment.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#get-a-review-comment-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn pulls_get_review_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a review comment for a pull request.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
     *
     * Deletes a review comment.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#delete-a-review-comment-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn pulls_delete_review_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a review comment for a pull request.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
     *
     * Enables you to edit a review comment.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#update-a-review-comment-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn pulls_update_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::PullsUpdateReviewCommentRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for a pull request review comment.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions` endpoint.
     *
     * List the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-pull-request-review-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_pull_request_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a pull request review comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions` endpoint.
     *
     * Create a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-pull-request-review-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn reactions_create_for_pull_request_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::ReactionsCreatePullRequestReviewComment,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a pull request comment reaction.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}` endpoint.
     *
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
     *
     * Delete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions#delete-a-pull-request-comment-reaction>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `comment_id: i64` -- comment_id parameter.
     * * `reaction_id: i64`
     */
    pub async fn reactions_delete_for_pull_request_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}` endpoint.
     *
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Lists details of a pull request by providing its number.
     *
     * When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     *
     * The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.
     *
     * The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:
     *
     * *   If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
     * *   If merged via a [squash](https://help.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
     * *   If [rebased](https://help.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.
     *
     * Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#get-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_get(&self, owner: &str, repo: &str, pull_number: i64) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a pull request.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/pulls/{pull_number}` endpoint.
     *
     * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls/#update-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_update(&self, owner: &str, repo: &str, pull_number: i64, body: &types::PullsUpdateRequest) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List review comments on a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments` endpoint.
     *
     * Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-review-comments-on-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- Can be either `asc` or `desc`. Ignored without `sort` parameter.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_review_comments(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a review comment for a pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments` endpoint.
     *
     *
     * Creates a review comment in the pull request diff. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than one line in the pull request diff.
     *
     * You can still create a review comment using the `position` parameter. When you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information, see the [`comfort-fade` preview notice](https://docs.github.com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
     *
     * **Note:** The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#create-a-review-comment-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_create_review_comment(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsCreateReviewCommentRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Create a reply for a review comment.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies` endpoint.
     *
     * Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#create-a-reply-for-a-review-comment>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `comment_id: i64` -- comment_id parameter.
     */
    pub async fn pulls_create_reply_for_review_comment(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        comment_id: i64,
        body: &types::PullsCreateReplyReviewCommentRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments/{}/replies",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List commits on a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/commits` endpoint.
     *
     * Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/reference/repos#list-commits) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-commits-on-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_commits(&self, owner: &str, repo: &str, pull_number: i64, per_page: i64, page: i64) -> Result<Vec<types::Tree>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/commits?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List pull requests files.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/files` endpoint.
     *
     * **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-pull-requests-files>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_files(&self, owner: &str, repo: &str, pull_number: i64, per_page: i64, page: i64) -> Result<Vec<types::DiffEntry>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/files?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check if a pull request has been merged.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/merge` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#check-if-a-pull-request-has-been-merged>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_check_if_merged(&self, owner: &str, repo: &str, pull_number: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/merge",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Merge a pull request.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/merge` endpoint.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#merge-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_merge(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsMergeRequest,
    ) -> Result<types::PullRequestMergeResult> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/merge",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List requested reviewers for a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-requested-reviewers-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_requested_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Request reviewers for a pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
     *
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#request-reviewers-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_request_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsRequestReviewers,
    ) -> Result<types::PullRequestSimple> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove requested reviewers from a pull request.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#remove-requested-reviewers-from-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_remove_requested_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsRemoveRequestedReviewersRequest,
    ) -> Result<types::PullRequestSimple> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reviews for a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews` endpoint.
     *
     * The list of reviews returns in chronological order.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-reviews-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_reviews(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReview>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a review for a pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews` endpoint.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in the response.
     *
     * **Note:** To comment on a specific line in a file, you need to first determine the _position_ of that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media type](https://docs.github.com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request diff, add this media type to the `Accept` header of a call to the [single pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
     *
     * The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#create-a-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_create_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsCreateReviewRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a review for a pull request.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#get-a-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     */
    pub async fn pulls_get_review(&self, owner: &str, repo: &str, pull_number: i64, review_id: i64) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a review for a pull request.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
     *
     * Update the review summary comment with new text.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#update-a-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     */
    pub async fn pulls_update_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::PullsUpdateReviewRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a pending review for a pull request.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#delete-a-pending-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     */
    pub async fn pulls_delete_pending_review(&self, owner: &str, repo: &str, pull_number: i64, review_id: i64) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List comments for a pull request review.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments` endpoint.
     *
     * List comments for a specific pull request review.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#list-comments-for-a-pull-request-review>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn pulls_list_comments_for_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Dismiss a review for a pull request.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals` endpoint.
     *
     * **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/reference/repos#branches), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#dismiss-a-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     */
    pub async fn pulls_dismiss_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::PullsDismissReviewRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/dismissals",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Submit a review for a pull request.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#submit-a-review-for-a-pull-request>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     * * `review_id: i64` -- review_id parameter.
     */
    pub async fn pulls_submit_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::PullsSubmitReviewRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/events",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Update a pull request branch.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/update-branch` endpoint.
     *
     * Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
     *
     * FROM: <https://docs.github.com/rest/reference/pulls#update-a-pull-request-branch>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `pull_number: i64`
     */
    pub async fn pulls_update_branch(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::PullsUpdateBranchRequest,
    ) -> Result<types::PutPullsUpdateBranchAcceptedResponse> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/update-branch",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a repository README.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/readme` endpoint.
     *
     * Gets the preferred README for a repository.
     *
     * READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-readme>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str` -- The name of the commit/branch/tag. Default: the repositorys default branch (usually `master`).
     */
    pub async fn repos_get_readme(&self, owner: &str, repo: &str, ref_: &str) -> Result<types::ContentFile> {
        let url = format!(
            "/repos/{}/{}/readme?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            ref_,
        );

        self.get(&url).await
    }

    /**
     * Get a repository README for a directory.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/readme/{dir}` endpoint.
     *
     * Gets the README from a repository directory.
     *
     * READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-directory-readme>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `dir: &str` -- The alternate path to look for a README file.
     * * `ref_: &str` -- The name of the commit/branch/tag. Default: the repositorys default branch (usually `master`).
     */
    pub async fn repos_get_readme_in_directory(&self, owner: &str, repo: &str, dir: &str, ref_: &str) -> Result<types::ContentFile> {
        let url = format!(
            "/repos/{}/{}/readme/{}?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&dir.to_string()),
            ref_,
        );

        self.get(&url).await
    }

    /**
     * List releases.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases` endpoint.
     *
     * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).
     *
     * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-releases>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_releases(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Release>> {
        let url = format!(
            "/repos/{}/{}/releases?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a release.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/releases` endpoint.
     *
     * Users with push access to the repository can create a release.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_create_release(&self, owner: &str, repo: &str, body: &types::ReposCreateReleaseRequest) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a release asset.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
     *
     * To download the asset's binary content, set the `Accept` header of the request to [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will either redirect the client to the location, or stream it directly if possible. API clients should handle both a `200` or `302` response.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-release-asset>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `asset_id: i64` -- asset_id parameter.
     */
    pub async fn repos_get_release_asset(&self, owner: &str, repo: &str, asset_id: i64) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a release asset.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-release-asset>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `asset_id: i64` -- asset_id parameter.
     */
    pub async fn repos_delete_release_asset(&self, owner: &str, repo: &str, asset_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a release asset.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
     *
     * Users with push access to the repository can edit a release asset.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-release-asset>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `asset_id: i64` -- asset_id parameter.
     */
    pub async fn repos_update_release_asset(
        &self,
        owner: &str,
        repo: &str,
        asset_id: i64,
        body: &types::ReposUpdateReleaseAssetRequest,
    ) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get the latest release.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/latest` endpoint.
     *
     * View the latest published full release for the repository.
     *
     * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-latest-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_latest_release(&self, owner: &str, repo: &str) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/latest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get a release by tag name.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/tags/{tag}` endpoint.
     *
     * Get a published release with the specified tag.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-release-by-tag-name>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `tag: &str` -- tag parameter.
     */
    pub async fn repos_get_release_by_tag(&self, owner: &str, repo: &str, tag: &str) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/tags/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tag.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get a release.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
     *
     * **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia).
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-a-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     */
    pub async fn repos_get_release(&self, owner: &str, repo: &str, release_id: i64) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a release.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
     *
     * Users with push access to the repository can delete a release.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#delete-a-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     */
    pub async fn repos_delete_release(&self, owner: &str, repo: &str, release_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a release.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
     *
     * Users with push access to the repository can edit a release.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#update-a-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     */
    pub async fn repos_update_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        body: &types::ReposUpdateReleaseRequest,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List release assets.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/{release_id}/assets` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-release-assets>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_release_assets(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ReleaseAsset>> {
        let url = format!(
            "/repos/{}/{}/releases/{}/assets?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Upload a release asset.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/releases/{release_id}/assets` endpoint.
     *
     * This endpoint makes use of [a Hypermedia relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
     * the response of the [Create a release endpoint](https://docs.github.com/rest/reference/repos#create-a-release) to upload a release asset.
     *
     * You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
     *
     * Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
     *
     * `application/zip`
     *
     * GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
     * you'll still need to pass your authentication to be able to upload an asset.
     *
     * When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
     *
     * **Notes:**
     * *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List assets for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)"
     * endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact).
     * *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#upload-a-release-asset>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     * * `name: &str`
     * * `label: &str`
     */
    pub async fn repos_upload_release_asset<T: Into<reqwest::Body>>(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        name: &str,
        label: &str,
        body: T,
    ) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/{}/assets?label={}&name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
            label.to_string(),
            name.to_string(),
        );

        self.post(&url, Some(body.into())).await
    }

    /**
     * Create reaction for a release.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/releases/{release_id}/reactions` endpoint.
     *
     * Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-release>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `release_id: i64` -- release_id parameter.
     */
    pub async fn reactions_create_for_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        body: &types::ReactionsCreateReleaseRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/releases/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List secret scanning alerts for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/secret-scanning/alerts` endpoint.
     *
     * Lists all secret scanning alerts for a private repository, from newest to oldest. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
     *
     * GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/secret-scanning#list-secret-scanning-alerts-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `state: crate::types::SecretScanningAlertState` -- Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
     * * `secret_type: &str` -- A comma separated list of secret types to return. By default all secret types are returned.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn secret_scanning_list_alerts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        state: crate::types::SecretScanningAlertState,
        secret_type: &str,
        page: i64,
        per_page: i64,
    ) -> Result<Vec<types::SecretScanningAlert>> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts?page={}&per_page={}&secret_type={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            secret_type.to_string(),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a secret scanning alert.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}` endpoint.
     *
     * Gets a single secret scanning alert detected in a private repository. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
     *
     * GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/secret-scanning#get-a-secret-scanning-alert>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `alert_number: i64` -- The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
     */
    pub async fn secret_scanning_get_alert(&self, owner: &str, repo: &str, alert_number: i64) -> Result<types::SecretScanningAlert> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a secret scanning alert.
     *
     * This function performs a `PATCH` to the `/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}` endpoint.
     *
     * Updates the status of a secret scanning alert in a private repository. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
     *
     * GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/secret-scanning#update-a-secret-scanning-alert>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `alert_number: i64` -- The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.
     */
    pub async fn secret_scanning_update_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: i64,
        body: &types::SecretScanningUpdateAlertRequest,
    ) -> Result<types::SecretScanningAlert> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List stargazers.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stargazers` endpoint.
     *
     * Lists the people that have starred the repository.
     *
     * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-stargazers>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_stargazers_for_repo(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/stargazers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the weekly commit activity.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/code_frequency` endpoint.
     *
     * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-weekly-commit-activity>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_code_frequency_stats(&self, owner: &str, repo: &str) -> Result<Vec<Vec<i64>>> {
        let url = format!(
            "/repos/{}/{}/stats/code_frequency",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the last year of commit activity.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/commit_activity` endpoint.
     *
     * Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-last-year-of-commit-activity>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_commit_activity_stats(&self, owner: &str, repo: &str) -> Result<Vec<types::CommitActivity>> {
        let url = format!(
            "/repos/{}/{}/stats/commit_activity",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get all contributor commit activity.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/contributors` endpoint.
     *
     *
     * Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
     *
     * *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
     * *   `a` - Number of additions
     * *   `d` - Number of deletions
     * *   `c` - Number of commits
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-all-contributor-commit-activity>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_contributors_stats(&self, owner: &str, repo: &str) -> Result<Vec<types::ContributorActivity>> {
        let url = format!(
            "/repos/{}/{}/stats/contributors",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the weekly commit count.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/participation` endpoint.
     *
     * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
     *
     * The array order is oldest week (index 0) to most recent week.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-weekly-commit-count>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_participation_stats(&self, owner: &str, repo: &str) -> Result<types::ParticipationStats> {
        let url = format!(
            "/repos/{}/{}/stats/participation",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get the hourly commit count for each day.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/punch_card` endpoint.
     *
     * Each array contains the day number, hour number, and number of commits:
     *
     * *   `0-6`: Sunday - Saturday
     * *   `0-23`: Hour of day
     * *   Number of commits
     *
     * For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-the-hourly-commit-count-for-each-day>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_punch_card_stats(&self, owner: &str, repo: &str) -> Result<Vec<Vec<i64>>> {
        let url = format!(
            "/repos/{}/{}/stats/punch_card",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a commit status.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/statuses/{sha}` endpoint.
     *
     * Users with push access in a repository can create commit statuses for a given SHA.
     *
     * Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-commit-status>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `sha: &str`
     */
    pub async fn repos_create_commit_status(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        body: &types::ReposCreateCommitStatusRequest,
    ) -> Result<types::Status> {
        let url = format!(
            "/repos/{}/{}/statuses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&sha.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List watchers.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/subscribers` endpoint.
     *
     * Lists the people watching the specified repository.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-watchers>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_watchers_for_repo(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/repos/{}/{}/subscribers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a repository subscription.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/subscription` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#get-a-repository-subscription>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_get_repo_subscription(&self, owner: &str, repo: &str) -> Result<types::RepositorySubscription> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set a repository subscription.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/subscription` endpoint.
     *
     * If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription) completely.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#set-a-repository-subscription>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_set_repo_subscription(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ActivitySetRepoSubscriptionRequest,
    ) -> Result<types::RepositorySubscription> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a repository subscription.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/subscription` endpoint.
     *
     * This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
     *
     * FROM: <https://docs.github.com/rest/reference/activity#delete-a-repository-subscription>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_delete_repo_subscription(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repository tags.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/tags` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-tags>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_tags(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Tag>> {
        let url = format!(
            "/repos/{}/{}/tags?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Download a repository archive (tar).
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/tarball/{ref}` endpoint.
     *
     * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
     * `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
     * the `Location` header to make a second `GET` request.
     * **Note**: For private repositories, these links are temporary and expire after five minutes.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#download-a-repository-archive>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str`
     */
    pub async fn repos_download_tarball_archive(&self, owner: &str, repo: &str, ref_: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/tarball/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List repository teams.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/teams` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-teams>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_teams(&self, owner: &str, repo: &str, per_page: i64, page: i64) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get all repository topics.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/topics` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-all-repository-topics>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn repos_get_all_topics(&self, owner: &str, repo: &str, page: i64, per_page: i64) -> Result<types::Topic> {
        let url = format!(
            "/repos/{}/{}/topics?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Replace all repository topics.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/topics` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#replace-all-repository-topics>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_replace_all_topics(&self, owner: &str, repo: &str, body: &types::ReposReplaceAllTopicsRequest) -> Result<types::Topic> {
        let url = format!(
            "/repos/{}/{}/topics",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get repository clones.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/clones` endpoint.
     *
     * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-repository-clones>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per: crate::types::Per` -- Must be one of: `day`, `week`.
     */
    pub async fn repos_get_clones(&self, owner: &str, repo: &str, per: crate::types::Per) -> Result<types::CloneTraffic> {
        let url = format!(
            "/repos/{}/{}/traffic/clones?per={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            per,
        );

        self.get(&url).await
    }

    /**
     * Get top referral paths.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/popular/paths` endpoint.
     *
     * Get the top 10 popular contents over the last 14 days.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-top-referral-paths>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_top_paths(&self, owner: &str, repo: &str) -> Result<Vec<types::ContentTraffic>> {
        let url = format!(
            "/repos/{}/{}/traffic/popular/paths",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get top referral sources.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/popular/referrers` endpoint.
     *
     * Get the top 10 referrers over the last 14 days.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-top-referral-sources>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_get_top_referrers(&self, owner: &str, repo: &str) -> Result<Vec<types::ReferrerTraffic>> {
        let url = format!(
            "/repos/{}/{}/traffic/popular/referrers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get page views.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/views` endpoint.
     *
     * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#get-page-views>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `per: crate::types::Per` -- Must be one of: `day`, `week`.
     */
    pub async fn repos_get_views(&self, owner: &str, repo: &str, per: crate::types::Per) -> Result<types::ViewTraffic> {
        let url = format!(
            "/repos/{}/{}/traffic/views?per={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            per,
        );

        self.get(&url).await
    }

    /**
     * Transfer a repository.
     *
     * This function performs a `POST` to the `/repos/{owner}/{repo}/transfer` endpoint.
     *
     * A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://help.github.com/articles/about-repository-transfers/).
     *
     * FROM: <https://docs.github.com/rest/reference/repos#transfer-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_transfer(&self, owner: &str, repo: &str, body: &types::ReposTransferRequest) -> Result<types::MinimalRepository> {
        let url = format!(
            "/repos/{}/{}/transfer",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Check if vulnerability alerts are enabled for a repository.
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
     *
     * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
     *
     * FROM: <https://docs.github.com/rest/reference/repos#check-if-vulnerability-alerts-are-enabled-for-a-repository>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_check_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Enable vulnerability alerts.
     *
     * This function performs a `PUT` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
     *
     * Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
     *
     * FROM: <https://docs.github.com/rest/reference/repos#enable-vulnerability-alerts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_enable_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Disable vulnerability alerts.
     *
     * This function performs a `DELETE` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
     *
     * Disables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
     *
     * FROM: <https://docs.github.com/rest/reference/repos#disable-vulnerability-alerts>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn repos_disable_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Download a repository archive (zip).
     *
     * This function performs a `GET` to the `/repos/{owner}/{repo}/zipball/{ref}` endpoint.
     *
     * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
     * `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
     * the `Location` header to make a second `GET` request.
     * **Note**: For private repositories, these links are temporary and expire after five minutes.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#download-a-repository-archive>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     * * `ref_: &str`
     */
    pub async fn repos_download_zipball_archive(&self, owner: &str, repo: &str, ref_: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/zipball/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create a repository using a template.
     *
     * This function performs a `POST` to the `/repos/{template_owner}/{template_repo}/generate` endpoint.
     *
     * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. The authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-using-a-template>
     *
     * **Parameters:**
     *
     * * `template_owner: &str`
     * * `template_repo: &str`
     */
    pub async fn repos_create_using_template(
        &self,
        template_owner: &str,
        template_repo: &str,
        body: &types::ReposCreateUsingTemplateRequest,
    ) -> Result<types::Repository> {
        let url = format!(
            "/repos/{}/{}/generate",
            progenitor_support::encode_path(&template_owner.to_string()),
            progenitor_support::encode_path(&template_repo.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List public repositories.
     *
     * This function performs a `GET` to the `/repositories` endpoint.
     *
     * Lists all public repositories in the order that they were created.
     *
     * Note:
     * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
     * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-public-repositories>
     *
     * **Parameters:**
     *
     * * `since: i64` -- A repository ID. Only return repositories with an ID greater than this ID.
     */
    pub async fn repos_list_public(&self, since: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!("/repositories?since={}", format!("{}", since),);

        self.get_all_pages(&url).await
    }

    /**
     * List environment secrets.
     *
     * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets` endpoint.
     *
     * Lists all secrets available in an environment without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#list-environment-secrets>
     *
     * **Parameters:**
     *
     * * `repository_id: i64`
     * * `environment_name: &str` -- The name of the environment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn actions_list_environment_secrets(
        &self,
        repository_id: i64,
        environment_name: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetActionsListRepoSecretsOkResponse> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Get an environment public key.
     *
     * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/public-key` endpoint.
     *
     * Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-an-environment-public-key>
     *
     * **Parameters:**
     *
     * * `repository_id: i64`
     * * `environment_name: &str` -- The name of the environment.
     */
    pub async fn actions_get_environment_public_key(&self, repository_id: i64, environment_name: &str) -> Result<types::ActionsPublicKey> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/public-key",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get an environment secret.
     *
     * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
     *
     * Gets a single environment secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#get-an-environment-secret>
     *
     * **Parameters:**
     *
     * * `repository_id: i64`
     * * `environment_name: &str` -- The name of the environment.
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_get_environment_secret(
        &self,
        repository_id: i64,
        environment_name: &str,
        secret_name: &str,
    ) -> Result<types::ActionsSecret> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update an environment secret.
     *
     * This function performs a `PUT` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
     *
     * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
     * this endpoint.
     *
     * #### Example encrypting a secret using Node.js
     *
     * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
     *
     * ```
     * const sodium = require('tweetsodium');
     *
     * const key = "base64-encoded-public-key";
     * const value = "plain-text-secret";
     *
     * // Convert the message and key to Uint8Array's (Buffer implements that interface)
     * const messageBytes = Buffer.from(value);
     * const keyBytes = Buffer.from(key, 'base64');
     *
     * // Encrypt using LibSodium.
     * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
     *
     * // Base64 the encrypted secret
     * const encrypted = Buffer.from(encryptedBytes).toString('base64');
     *
     * console.log(encrypted);
     * ```
     *
     *
     * #### Example encrypting a secret using Python
     *
     * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
     *
     * ```
     * from base64 import b64encode
     * from nacl import encoding, public
     *
     * def encrypt(public_key: str, secret_value: str) -> str:
     *   """Encrypt a Unicode string using the public key."""
     *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
     *   sealed_box = public.SealedBox(public_key)
     *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
     *   return b64encode(encrypted).decode("utf-8")
     * ```
     *
     * #### Example encrypting a secret using C#
     *
     * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
     *
     * ```
     * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
     * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
     *
     * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     *
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
     * ```
     *
     * #### Example encrypting a secret using Ruby
     *
     * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
     *
     * ```ruby
     * require "rbnacl"
     * require "base64"
     *
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
     * public_key = RbNaCl::PublicKey.new(key)
     *
     * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret")
     *
     * # Print the base64 encoded secret
     * puts Base64.strict_encode64(encrypted_secret)
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-an-environment-secret>
     *
     * **Parameters:**
     *
     * * `repository_id: i64`
     * * `environment_name: &str` -- The name of the environment.
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_create_or_update_environment_secret(
        &self,
        repository_id: i64,
        environment_name: &str,
        secret_name: &str,
        body: &types::ActionsCreateUpdateEnvironmentSecretRequest,
    ) -> Result<types::EmptyObject> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an environment secret.
     *
     * This function performs a `DELETE` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
     *
     * Deletes a secret in an environment using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/actions#delete-an-environment-secret>
     *
     * **Parameters:**
     *
     * * `repository_id: i64`
     * * `environment_name: &str` -- The name of the environment.
     * * `secret_name: &str` -- secret_name parameter.
     */
    pub async fn actions_delete_environment_secret(&self, repository_id: i64, environment_name: &str, secret_name: &str) -> Result<()> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List provisioned SCIM groups for an enterprise.
     *
     * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Groups` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-provisioned-scim-groups-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `start_index: i64` -- Used for pagination: the index of the first result to return.
     * * `count: i64` -- Used for pagination: the number of results to return.
     * * `filter: &str` -- filter results.
     * * `excluded_attributes: &str` -- attributes to exclude.
     */
    pub async fn enterprise_admin_list_provisioned_groups_enterprise(
        &self,
        enterprise: &str,
        start_index: i64,
        count: i64,
        filter: &str,
        excluded_attributes: &str,
    ) -> Result<types::ScimGroupListEnterprise> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups?count={}&excluded_attributes={}&filter={}&start_index={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", count),
            excluded_attributes.to_string(),
            filter.to_string(),
            format!("{}", start_index),
        );

        self.get(&url).await
    }

    /**
     * Provision a SCIM enterprise group and invite users.
     *
     * This function performs a `POST` to the `/scim/v2/enterprises/{enterprise}/Groups` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Provision an enterprise group, and invite users to the group. This sends invitation emails to the email address of the invited users to join the GitHub organization that the SCIM group corresponds to.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#provision-a-scim-enterprise-group-and-invite-users>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_provision_and_invite_enterprise_group(
        &self,
        enterprise: &str,
        body: &types::EnterpriseAdminProvisionInviteGroupRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!("/scim/v2/enterprises/{}/Groups", progenitor_support::encode_path(&enterprise.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get SCIM provisioning information for an enterprise group.
     *
     * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-scim-provisioning-information-for-an-enterprise-group>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_group_id: &str` -- Identifier generated by the GitHub SCIM endpoint.
     * * `excluded_attributes: &str` -- Attributes to exclude.
     */
    pub async fn enterprise_admin_get_provisioning_information_for_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        excluded_attributes: &str,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}?excluded_attributes={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
            excluded_attributes.to_string(),
        );

        self.get(&url).await
    }

    /**
     * Set SCIM information for a provisioned enterprise group.
     *
     * This function performs a `PUT` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Replaces an existing provisioned groups information. You must provide all the information required for the group as if you were provisioning it for the first time. Any existing group information that you don't provide will be removed, including group membership. If you want to only update a specific attribute, use the [Update an attribute for a SCIM enterprise group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-scim-information-for-a-provisioned-enterprise-group>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_group_id: &str` -- Identifier generated by the GitHub SCIM endpoint.
     */
    pub async fn enterprise_admin_set_information_for_provisioned_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        body: &types::EnterpriseAdminProvisionInviteGroupRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a SCIM group from an enterprise.
     *
     * This function performs a `DELETE` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-scim-group-from-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_group_id: &str` -- Identifier generated by the GitHub SCIM endpoint.
     */
    pub async fn enterprise_admin_delete_scim_group_from_enterprise(&self, enterprise: &str, scim_group_id: &str) -> Result<()> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an attribute for a SCIM enterprise group.
     *
     * This function performs a `PATCH` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Allows you to change a provisioned groups individual attributes. To change a groups values, you must provide a specific Operations JSON format that contains at least one of the add, remove, or replace operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-an-attribute-for-a-scim-enterprise-group>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_group_id: &str` -- Identifier generated by the GitHub SCIM endpoint.
     */
    pub async fn enterprise_admin_update_attribute_for_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        body: &types::EnterpriseAdminUpdateAttributeGroupRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List SCIM provisioned identities for an enterprise.
     *
     * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Users` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
     *
     * When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise, the account's metadata is immediately removed. However, the returned list of user accounts might not always match the organization or enterprise member list you see on GitHub. This can happen in certain cases where an external identity associated with an organization will not match an organization member:
     *   - When a user with a SCIM-provisioned external identity is removed from an enterprise, the account's metadata is preserved to allow the user to re-join the organization in the future.
     *   - When inviting a user to join an organization, you can expect to see their external identity in the results before they accept the invitation, or if the invitation is cancelled (or never accepted).
     *   - When a user is invited over SCIM, an external identity is created that matches with the invitee's email address. However, this identity is only linked to a user account when the user accepts the invitation by going through SAML SSO.
     *
     * The returned list of external identities can include an entry for a `null` user. These are unlinked SAML identities that are created when a user goes through the following Single Sign-On (SSO) process but does not sign in to their GitHub account after completing SSO:
     *
     * 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
     *
     * 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is not currently signed in to their GitHub account.
     *
     * 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is created and the user is prompted to sign in to their GitHub account:
     *    - If the user signs in, their GitHub account is linked to this entry.
     *    - If the user does not sign in (or does not create a new account when prompted), they are not added to the GitHub enterprise, and the external identity `null` entry remains in place.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-scim-provisioned-identities-for-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `start_index: i64` -- Used for pagination: the index of the first result to return.
     * * `count: i64` -- Used for pagination: the number of results to return.
     * * `filter: &str` -- filter results.
     */
    pub async fn enterprise_admin_list_provisioned_identities_enterprise(
        &self,
        enterprise: &str,
        start_index: i64,
        count: i64,
        filter: &str,
    ) -> Result<types::ScimUserListEnterprise> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users?count={}&filter={}&start_index={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", count),
            filter.to_string(),
            format!("{}", start_index),
        );

        self.get(&url).await
    }

    /**
     * Provision and invite a SCIM enterprise user.
     *
     * This function performs a `POST` to the `/scim/v2/enterprises/{enterprise}/Users` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Provision enterprise membership for a user, and send organization invitation emails to the email address.
     *
     * You can optionally include the groups a user will be invited to join. If you do not provide a list of `groups`, the user is provisioned for the enterprise, but no organization invitation emails will be sent.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#provision-and-invite-a-scim-enterprise-user>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     */
    pub async fn enterprise_admin_provision_and_invite_enterprise_user(
        &self,
        enterprise: &str,
        body: &types::EnterpriseAdminProvisionInviteUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!("/scim/v2/enterprises/{}/Users", progenitor_support::encode_path(&enterprise.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get SCIM provisioning information for an enterprise user.
     *
     * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-scim-provisioning-information-for-an-enterprise-user>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn enterprise_admin_get_provisioning_information_for_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Set SCIM information for a provisioned enterprise user.
     *
     * This function performs a `PUT` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Replaces an existing provisioned user's information. You must provide all the information required for the user as if you were provisioning them for the first time. Any existing user information that you don't provide will be removed. If you want to only update a specific attribute, use the [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint instead.
     *
     * You must at least provide the required values for the user: `userName`, `name`, and `emails`.
     *
     * **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external identity, and deletes the associated `{scim_user_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-scim-information-for-a-provisioned-enterprise-user>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn enterprise_admin_set_information_for_provisioned_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
        body: &types::EnterpriseAdminProvisionInviteUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a SCIM user from an enterprise.
     *
     * This function performs a `DELETE` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-scim-user-from-an-enterprise>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn enterprise_admin_delete_user_from_enterprise(&self, enterprise: &str, scim_user_id: &str) -> Result<()> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an attribute for a SCIM enterprise user.
     *
     * This function performs a `PATCH` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
     *
     * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
     *
     * Allows you to change a provisioned user's individual attributes. To change a user's values, you must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`, or `replace` operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
     *
     * **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
     *
     * **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example below), it removes the user from the enterprise, deletes the external identity, and deletes the associated `:scim_user_id`.
     *
     * ```
     * {
     *   "Operations":[{
     *     "op":"replace",
     *     "value":{
     *       "active":false
     *     }
     *   }]
     * }
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-an-attribute-for-a-scim-enterprise-user>
     *
     * **Parameters:**
     *
     * * `enterprise: &str` -- The slug version of the enterprise name. You can also substitute this value with the enterprise id.
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn enterprise_admin_update_attribute_for_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
        body: &types::EnterpriseAdminUpdateAttributeUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List SCIM provisioned identities.
     *
     * This function performs a `GET` to the `/scim/v2/organizations/{org}/Users` endpoint.
     *
     * Retrieves a paginated list of all provisioned organization members, including pending invitations. If you provide the `filter` parameter, the resources for all matching provisions members are returned.
     *
     * When a user with a SAML-provisioned external identity leaves (or is removed from) an organization, the account's metadata is immediately removed. However, the returned list of user accounts might not always match the organization or enterprise member list you see on GitHub. This can happen in certain cases where an external identity associated with an organization will not match an organization member:
     *   - When a user with a SCIM-provisioned external identity is removed from an organization, the account's metadata is preserved to allow the user to re-join the organization in the future.
     *   - When inviting a user to join an organization, you can expect to see their external identity in the results before they accept the invitation, or if the invitation is cancelled (or never accepted).
     *   - When a user is invited over SCIM, an external identity is created that matches with the invitee's email address. However, this identity is only linked to a user account when the user accepts the invitation by going through SAML SSO.
     *
     * The returned list of external identities can include an entry for a `null` user. These are unlinked SAML identities that are created when a user goes through the following Single Sign-On (SSO) process but does not sign in to their GitHub account after completing SSO:
     *
     * 1. The user is granted access by the IdP and is not a member of the GitHub organization.
     *
     * 1. The user attempts to access the GitHub organization and initiates the SAML SSO process, and is not currently signed in to their GitHub account.
     *
     * 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is created and the user is prompted to sign in to their GitHub account:
     *    - If the user signs in, their GitHub account is linked to this entry.
     *    - If the user does not sign in (or does not create a new account when prompted), they are not added to the GitHub organization, and the external identity `null` entry remains in place.
     *
     * FROM: <https://docs.github.com/rest/reference/scim#list-scim-provisioned-identities>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `start_index: i64` -- Used for pagination: the index of the first result to return.
     * * `count: i64` -- Used for pagination: the number of results to return.
     * * `filter: &str` -- Filters results using the equals query parameter operator (`eq`). You can filter results that are equal to `id`, `userName`, `emails`, and `external_id`. For example, to search for an identity with the `userName` Octocat, you would use this query:
     *  
     *  `?filter=userName%20eq%20\"Octocat\"`.
     *  
     *  To filter results for the identity with the email `octocat@github.com`, you would use this query:
     *  
     *  `?filter=emails%20eq%20\"octocat@github.com\"`.
     */
    pub async fn scim_list_provisioned_identities(&self, org: &str, start_index: i64, count: i64, filter: &str) -> Result<types::ScimUserList> {
        let url = format!(
            "/scim/v2/organizations/{}/Users?count={}&filter={}&start_index={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", count),
            filter.to_string(),
            format!("{}", start_index),
        );

        self.get(&url).await
    }

    /**
     * Provision and invite a SCIM user.
     *
     * This function performs a `POST` to the `/scim/v2/organizations/{org}/Users` endpoint.
     *
     * Provision organization membership for a user, and send an activation email to the email address.
     *
     * FROM: <https://docs.github.com/rest/reference/scim#provision-and-invite-a-scim-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn scim_provision_and_invite_user(&self, org: &str, body: &types::ScimProvisionInviteUserRequest) -> Result<types::ScimUser> {
        let url = format!("/scim/v2/organizations/{}/Users", progenitor_support::encode_path(&org.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get SCIM provisioning information for a user.
     *
     * This function performs a `GET` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/scim#get-scim-provisioning-information-for-a-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn scim_get_provisioning_information_for_user(&self, org: &str, scim_user_id: &str) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Update a provisioned organization membership.
     *
     * This function performs a `PUT` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
     *
     * Replaces an existing provisioned user's information. You must provide all the information required for the user as if you were provisioning them for the first time. Any existing user information that you don't provide will be removed. If you want to only update a specific attribute, use the [Update an attribute for a SCIM user](https://docs.github.com/rest/reference/scim#update-an-attribute-for-a-scim-user) endpoint instead.
     *
     * You must at least provide the required values for the user: `userName`, `name`, and `emails`.
     *
     * **Warning:** Setting `active: false` removes the user from the organization, deletes the external identity, and deletes the associated `{scim_user_id}`.
     *
     * FROM: <https://docs.github.com/rest/reference/scim#set-scim-information-for-a-provisioned-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn scim_set_information_for_provisioned_user(
        &self,
        org: &str,
        scim_user_id: &str,
        body: &types::ScimProvisionInviteUserRequest,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete a SCIM user from an organization.
     *
     * This function performs a `DELETE` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/scim#delete-a-scim-user-from-an-organization>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn scim_delete_user_from_org(&self, org: &str, scim_user_id: &str) -> Result<()> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update an attribute for a SCIM user.
     *
     * This function performs a `PATCH` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
     *
     * Allows you to change a provisioned user's individual attributes. To change a user's values, you must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`, or `replace` operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
     *
     * **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
     *
     * **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example below), it removes the user from the organization, deletes the external identity, and deletes the associated `:scim_user_id`.
     *
     * ```
     * {
     *   "Operations":[{
     *     "op":"replace",
     *     "value":{
     *       "active":false
     *     }
     *   }]
     * }
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/scim#update-an-attribute-for-a-scim-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     * * `scim_user_id: &str` -- scim_user_id parameter.
     */
    pub async fn scim_update_attribute_for_user(
        &self,
        org: &str,
        scim_user_id: &str,
        body: &types::ScimUpdateAttributeUserRequest,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Search code.
     *
     * This function performs a `GET` to the `/search/code` endpoint.
     *
     * Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
     *
     * `q=addClass+in:file+language:js+repo:jquery/jquery`
     *
     * This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.
     *
     * #### Considerations for code search
     *
     * Due to the complexity of searching code, there are a few restrictions on how searches are performed:
     *
     * *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
     * *   Only files smaller than 384 KB are searchable.
     * *   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
     * language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-code>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See "[Searching code](https://help.github.com/articles/searching-code/)" for a detailed list of qualifiers.
     * * `sort: crate::types::SearchCodeSort` -- Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_code(
        &self,
        q: &str,
        sort: crate::types::SearchCodeSort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchCodeOkResponse> {
        let url = format!(
            "/search/code?order={}&page={}&per_page={}&q={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Search commits.
     *
     * This function performs a `GET` to the `/search/commits` endpoint.
     *
     * Find commits via various criteria on the default branch (usually `master`). This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
     * metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:
     *
     * `q=repo:octocat/Spoon-Knife+css`
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-commits>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See "[Searching commits](https://help.github.com/articles/searching-commits/)" for a detailed list of qualifiers.
     * * `sort: crate::types::SearchCommitsSort` -- Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_commits(
        &self,
        q: &str,
        sort: crate::types::SearchCommitsSort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchCommitsOkResponse> {
        let url = format!(
            "/search/commits?order={}&page={}&per_page={}&q={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Search issues and pull requests.
     *
     * This function performs a `GET` to the `/search/issues` endpoint.
     *
     * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
     * search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
     *
     * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
     *
     * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
     *
     * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-issues-and-pull-requests>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See "[Searching issues and pull requests](https://help.github.com/articles/searching-issues-and-pull-requests/)" for a detailed list of qualifiers.
     * * `sort: crate::types::SearchIssuesPullRequestsSort` -- Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_issues_and_pull_requests(
        &self,
        q: &str,
        sort: crate::types::SearchIssuesPullRequestsSort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchIssuesPullRequestsOkResponse> {
        let url = format!(
            "/search/issues?order={}&page={}&per_page={}&q={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Search labels.
     *
     * This function performs a `GET` to the `/search/labels` endpoint.
     *
     * Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:
     *
     * `q=bug+defect+enhancement&repository_id=64778136`
     *
     * The labels that best match the query appear first in the search results.
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-labels>
     *
     * **Parameters:**
     *
     * * `repository_id: i64` -- The id of the repository.
     * * `q: &str` -- The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query).
     * * `sort: crate::types::Sort` -- Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_labels(
        &self,
        repository_id: i64,
        q: &str,
        sort: crate::types::Sort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchLabelsOkResponse> {
        let url = format!(
            "/search/labels?order={}&page={}&per_page={}&q={}&repository_id={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            format!("{}", repository_id),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Search repositories.
     *
     * This function performs a `GET` to the `/search/repositories` endpoint.
     *
     * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
     *
     * `q=tetris+language:assembly&sort=stars&order=desc`
     *
     * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
     *
     * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
     *
     * `q=topic:ruby+topic:rails`
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-repositories>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See "[Searching for repositories](https://help.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.
     * * `sort: crate::types::SearchReposSort` -- Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_repos(
        &self,
        q: &str,
        sort: crate::types::SearchReposSort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchReposOkResponse> {
        let url = format!(
            "/search/repositories?order={}&page={}&per_page={}&q={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Search topics.
     *
     * This function performs a `GET` to the `/search/topics` endpoint.
     *
     * Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination). See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list of qualifiers.
     *
     * When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:
     *
     * `q=ruby+is:featured`
     *
     * This query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-topics>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_topics(&self, q: &str, per_page: i64, page: i64) -> Result<types::GetSearchTopicsOkResponse> {
        let url = format!(
            "/search/topics?page={}&per_page={}&q={}",
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
        );

        self.get(&url).await
    }

    /**
     * Search users.
     *
     * This function performs a `GET` to the `/search/users` endpoint.
     *
     * Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for users, you can get text match metadata for the issue **login**, **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
     *
     * For example, if you're looking for a list of popular users, you might try this query:
     *
     * `q=tom+repos:%3E42+followers:%3E1000`
     *
     * This query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.
     *
     * FROM: <https://docs.github.com/rest/reference/search#search-users>
     *
     * **Parameters:**
     *
     * * `q: &str` -- The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See "[Searching users](https://help.github.com/articles/searching-users/)" for a detailed list of qualifiers.
     * * `sort: crate::types::SearchUsersSort` -- Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
     * * `order: crate::types::AuditLogOrder` -- Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn search_users(
        &self,
        q: &str,
        sort: crate::types::SearchUsersSort,
        order: crate::types::AuditLogOrder,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchUsersOkResponse> {
        let url = format!(
            "/search/users?order={}&page={}&per_page={}&q={}&sort={}",
            order,
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort,
        );

        self.get(&url).await
    }

    /**
     * Get a team (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/reference/teams#get-a-team-by-name) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#get-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_get_legacy(&self, team_id: i64) -> Result<types::TeamFull> {
        let url = format!("/teams/{}", progenitor_support::encode_path(&team_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a team (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/reference/teams#delete-a-team) endpoint.
     *
     * To delete a team, the authenticated user must be an organization owner or team maintainer.
     *
     * If you are an organization owner, deleting a parent team will delete all of its child teams as well.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#delete-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_delete_legacy(&self, team_id: i64) -> Result<()> {
        let url = format!("/teams/{}", progenitor_support::encode_path(&team_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Update a team (Legacy).
     *
     * This function performs a `PATCH` to the `/teams/{team_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/reference/teams#update-a-team) endpoint.
     *
     * To edit a team, the authenticated user must either be an organization owner or a team maintainer.
     *
     * **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#update-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_update_legacy(&self, team_id: i64, body: &types::TeamsUpdateLegacyRequest) -> Result<types::TeamFull> {
        let url = format!("/teams/{}", progenitor_support::encode_path(&team_id.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List discussions (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/reference/teams#list-discussions) endpoint.
     *
     * List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-discussions-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_discussions_legacy(
        &self,
        team_id: i64,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussion>> {
        let url = format!(
            "/teams/{}/discussions?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a discussion (Legacy).
     *
     * This function performs a `POST` to the `/teams/{team_id}/discussions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/reference/teams#create-a-discussion) endpoint.
     *
     * Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_create_discussion_legacy(
        &self,
        team_id: i64,
        body: &types::TeamsCreateDiscussionInOrgRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!("/teams/{}/discussions", progenitor_support::encode_path(&team_id.to_string()),);

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a discussion (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/reference/teams#get-a-discussion) endpoint.
     *
     * Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     */
    pub async fn teams_get_discussion_legacy(&self, team_id: i64, discussion_number: i64) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a discussion (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/reference/teams#delete-a-discussion) endpoint.
     *
     * Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     */
    pub async fn teams_delete_discussion_legacy(&self, team_id: i64, discussion_number: i64) -> Result<()> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a discussion (Legacy).
     *
     * This function performs a `PATCH` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/reference/teams#update-a-discussion) endpoint.
     *
     * Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     */
    pub async fn teams_update_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::TeamsUpdateDiscussionInOrgRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List discussion comments (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/reference/teams#list-discussion-comments) endpoint.
     *
     * List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-discussion-comments-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_discussion_comments_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussionComment>> {
        let url = format!(
            "/teams/{}/discussions/{}/comments?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a discussion comment (Legacy).
     *
     * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/comments` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
     *
     * Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     */
    pub async fn teams_create_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::TeamsCreateDiscussionCommentInOrgRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a discussion comment (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
     *
     * Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_get_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a discussion comment (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
     *
     * Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_delete_discussion_comment_legacy(&self, team_id: i64, discussion_number: i64, comment_number: i64) -> Result<()> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Update a discussion comment (Legacy).
     *
     * This function performs a `PATCH` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
     *
     * Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn teams_update_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        body: &types::TeamsCreateDiscussionCommentInOrgRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for a team discussion comment (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
     *
     * List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#list-reactions-for-a-team-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `comment_number: i64`
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_team_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a team discussion comment (Legacy).
     *
     * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
     *
     * Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-team-discussion-comment-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `comment_number: i64`
     */
    pub async fn reactions_create_for_team_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        body: &types::ReactionsCreateTeamDiscussionCommentInOrgRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}/reactions",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List reactions for a team discussion (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/reactions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
     *
     * List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#list-reactions-for-a-team-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     * * `content: crate::types::Content` -- Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn reactions_list_for_team_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        content: crate::types::Content,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/teams/{}/discussions/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            content,
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create reaction for a team discussion (Legacy).
     *
     * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/reactions` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
     *
     * Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
     *
     * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-team-discussion-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `discussion_number: i64`
     */
    pub async fn reactions_create_for_team_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::ReactionsCreateTeamDiscussionInOrgRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/teams/{}/discussions/{}/reactions",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List pending team invitations (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/invitations` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
     *
     * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-pending-team-invitations-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_pending_invitations_legacy(&self, team_id: i64, per_page: i64, page: i64) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/teams/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List team members (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/members` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/reference/teams#list-team-members) endpoint.
     *
     * Team members will include the members of child teams.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-team-members-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `role: crate::types::TeamsListMembersInOrgRole` -- Filters members returned by their role in the team. Can be one of:  
     *  \* `member` - normal members of the team.  
     *  \* `maintainer` - team maintainers.  
     *  \* `all` - all members of the team.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_members_legacy(
        &self,
        team_id: i64,
        role: crate::types::TeamsListMembersInOrgRole,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::User>> {
        let url = format!(
            "/teams/{}/members?page={}&per_page={}&role={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            role,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get team member (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/members/{username}` endpoint.
     *
     * The "Get team member" endpoint (described below) is deprecated.
     *
     * We recommend using the [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.
     *
     * To list members in a team, the team must be visible to the authenticated user.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-team-member-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_get_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add team member (Legacy).
     *
     * This function performs a `PUT` to the `/teams/{team_id}/members/{username}` endpoint.
     *
     * The "Add team member" endpoint (described below) is deprecated.
     *
     * We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/teams#add-team-member-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_add_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove team member (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/members/{username}` endpoint.
     *
     * The "Remove team member" endpoint (described below) is deprecated.
     *
     * We recommend using the [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * FROM: <https://docs.github.com/rest/reference/teams#remove-team-member-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_remove_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get team membership for a user (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/memberships/{username}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
     *
     * Team members will include the members of child teams.
     *
     * To get a user's membership with a team, the team must be visible to the authenticated user.
     *
     * **Note:**
     * The response contains the `state` of the membership and the member's `role`.
     *
     * The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_get_membership_for_user_legacy(&self, team_id: i64, username: &str) -> Result<types::TeamMembership> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team membership for a user (Legacy).
     *
     * This function performs a `PUT` to the `/teams/{team_id}/memberships/{username}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.
     *
     * If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_add_or_update_membership_for_user_legacy(
        &self,
        team_id: i64,
        username: &str,
        body: &types::TeamsAddUpdateMembershipUserInOrgRequest,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove team membership for a user (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/memberships/{username}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
     *
     * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
     *
     * FROM: <https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `username: &str`
     */
    pub async fn teams_remove_membership_for_user_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List team projects (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/projects` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/rest/reference/teams#list-team-projects) endpoint.
     *
     * Lists the organization projects for a team.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#list-team-projects-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_projects_legacy(&self, team_id: i64, per_page: i64, page: i64) -> Result<Vec<types::TeamProject>> {
        let url = format!(
            "/teams/{}/projects?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check team permissions for a project (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/projects/{project_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project) endpoint.
     *
     * Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-project-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `project_id: i64`
     */
    pub async fn teams_check_permissions_for_project_legacy(&self, team_id: i64, project_id: i64) -> Result<types::TeamProject> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team project permissions (Legacy).
     *
     * This function performs a `PUT` to the `/teams/{team_id}/projects/{project_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions) endpoint.
     *
     * Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-project-permissions-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `project_id: i64`
     */
    pub async fn teams_add_or_update_project_permissions_legacy(
        &self,
        team_id: i64,
        project_id: i64,
        body: &types::TeamsAddUpdateProjectPermissionsLegacyRequest,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove a project from a team (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/projects/{project_id}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
     *
     * Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-project-from-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `project_id: i64`
     */
    pub async fn teams_remove_project_legacy(&self, team_id: i64, project_id: i64) -> Result<()> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List team repositories (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/repos` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/reference/teams#list-team-repositories) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#list-team-repositories-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_repos_legacy(&self, team_id: i64, per_page: i64, page: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/teams/{}/repos?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check team permissions for a repository (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
     *
     * **Note**: Repositories inherited through a parent team will also be checked.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-repository-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_check_permissions_for_repo_legacy(&self, team_id: i64, owner: &str, repo: &str) -> Result<types::TeamRepository> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Add or update team repository permissions (Legacy).
     *
     * This function performs a `PUT` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
     *
     * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-repository-permissions-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_add_or_update_repo_permissions_legacy(
        &self,
        team_id: i64,
        owner: &str,
        repo: &str,
        body: &types::TeamsAddUpdateRepoPermissionsLegacyRequest,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove a repository from a team (Legacy).
     *
     * This function performs a `DELETE` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
     *
     * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-repository-from-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn teams_remove_repo_legacy(&self, team_id: i64, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List IdP groups for a team (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/team-sync/group-mappings` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List IdP groups for a team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * List IdP groups connected to a team on GitHub.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_list_idp_groups_for_legacy(&self, team_id: i64) -> Result<types::GroupMapping> {
        let url = format!(
            "/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Create or update IdP group connections (Legacy).
     *
     * This function performs a `PATCH` to the `/teams/{team_id}/team-sync/group-mappings` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create or update IdP group connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections) endpoint.
     *
     * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
     *
     * Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.
     *
     * FROM: <https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     */
    pub async fn teams_create_or_update_idp_group_connections_legacy(
        &self,
        team_id: i64,
        body: &types::TeamsCreateUpdateIdpGroupConnectionsLegacyRequest,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List child teams (Legacy).
     *
     * This function performs a `GET` to the `/teams/{team_id}/teams` endpoint.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/reference/teams#list-child-teams) endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/teams/#list-child-teams-legacy>
     *
     * **Parameters:**
     *
     * * `team_id: i64`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_child_legacy(&self, team_id: i64, per_page: i64, page: i64) -> Result<Vec<types::Team>> {
        let url = format!(
            "/teams/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the authenticated user.
     *
     * This function performs a `GET` to the `/user` endpoint.
     *
     * If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.
     *
     * If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
     *
     * FROM: <https://docs.github.com/rest/reference/users#get-the-authenticated-user>
     */
    pub async fn users_get_authenticated(&self) -> Result<types::PrivateUser> {
        let url = "/user".to_string();
        self.get(&url).await
    }

    /**
     * Update the authenticated user.
     *
     * This function performs a `PATCH` to the `/user` endpoint.
     *
     * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
     *
     * FROM: <https://docs.github.com/rest/reference/users/#update-the-authenticated-user>
     */
    pub async fn users_update_authenticated(&self, body: &types::UsersUpdateAuthenticatedRequest) -> Result<types::PrivateUser> {
        let url = "/user".to_string();
        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List users blocked by the authenticated user.
     *
     * This function performs a `GET` to the `/user/blocks` endpoint.
     *
     * List the users you've blocked on your personal account.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-users-blocked-by-the-authenticated-user>
     */
    pub async fn users_list_blocked_by_authenticated(&self) -> Result<Vec<types::User>> {
        let url = "/user/blocks".to_string();
        self.get_all_pages(&url).await
    }

    /**
     * Check if a user is blocked by the authenticated user.
     *
     * This function performs a `GET` to the `/user/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/users#check-if-a-user-is-blocked-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_check_blocked(&self, username: &str) -> Result<()> {
        let url = format!("/user/blocks/{}", progenitor_support::encode_path(&username.to_string()),);

        self.get(&url).await
    }

    /**
     * Block a user.
     *
     * This function performs a `PUT` to the `/user/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/users#block-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_block(&self, username: &str) -> Result<()> {
        let url = format!("/user/blocks/{}", progenitor_support::encode_path(&username.to_string()),);

        self.put(&url, None).await
    }

    /**
     * Unblock a user.
     *
     * This function performs a `DELETE` to the `/user/blocks/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/users#unblock-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_unblock(&self, username: &str) -> Result<()> {
        let url = format!("/user/blocks/{}", progenitor_support::encode_path(&username.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Set primary email visibility for the authenticated user.
     *
     * This function performs a `PATCH` to the `/user/email/visibility` endpoint.
     *
     * Sets the visibility for your primary email addresses.
     *
     * FROM: <https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user>
     */
    pub async fn users_set_primary_email_visibility_for_authenticated(
        &self,
        body: &types::UsersSetPrimaryEmailVisibilityAuthenticatedRequestData,
    ) -> Result<Vec<types::Email>> {
        let url = "/user/email/visibility".to_string();
        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List email addresses for the authenticated user.
     *
     * This function performs a `GET` to the `/user/emails` endpoint.
     *
     * Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-email-addresses-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_emails_for_authenticated(&self, per_page: i64, page: i64) -> Result<Vec<types::Email>> {
        let url = format!("/user/emails?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Add an email address for the authenticated user.
     *
     * This function performs a `POST` to the `/user/emails` endpoint.
     *
     * This endpoint is accessible with the `user` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#add-an-email-address-for-the-authenticated-user>
     */
    pub async fn users_add_email_for_authenticated(&self, body: &types::UsersAddEmailAuthenticatedRequest) -> Result<Vec<types::Email>> {
        let url = "/user/emails".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Delete an email address for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/emails` endpoint.
     *
     * This endpoint is accessible with the `user` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#delete-an-email-address-for-the-authenticated-user>
     */
    pub async fn users_delete_email_for_authenticated(&self, body: &types::UsersDeleteEmailAuthenticatedRequest) -> Result<()> {
        let url = "/user/emails".to_string();
        self.delete(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List followers of the authenticated user.
     *
     * This function performs a `GET` to the `/user/followers` endpoint.
     *
     * Lists the people following the authenticated user.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-followers-of-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_followers_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!("/user/followers?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * List the people the authenticated user follows.
     *
     * This function performs a `GET` to the `/user/following` endpoint.
     *
     * Lists the people who the authenticated user follows.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-the-people-the-authenticated-user-follows>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_followed_by_authenticated(&self, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!("/user/following?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Check if a person is followed by the authenticated user.
     *
     * This function performs a `GET` to the `/user/following/{username}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/users#check-if-a-person-is-followed-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_check_person_is_followed_by_authenticated(&self, username: &str) -> Result<()> {
        let url = format!("/user/following/{}", progenitor_support::encode_path(&username.to_string()),);

        self.get(&url).await
    }

    /**
     * Follow a user.
     *
     * This function performs a `PUT` to the `/user/following/{username}` endpoint.
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#follow-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_follow(&self, username: &str) -> Result<()> {
        let url = format!("/user/following/{}", progenitor_support::encode_path(&username.to_string()),);

        self.put(&url, None).await
    }

    /**
     * Unfollow a user.
     *
     * This function performs a `DELETE` to the `/user/following/{username}` endpoint.
     *
     * Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#unfollow-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_unfollow(&self, username: &str) -> Result<()> {
        let url = format!("/user/following/{}", progenitor_support::encode_path(&username.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * List GPG keys for the authenticated user.
     *
     * This function performs a `GET` to the `/user/gpg_keys` endpoint.
     *
     * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-gpg-keys-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_gpg_keys_for_authenticated(&self, per_page: i64, page: i64) -> Result<Vec<types::GpgKey>> {
        let url = format!("/user/gpg_keys?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Create a GPG key for the authenticated user.
     *
     * This function performs a `POST` to the `/user/gpg_keys` endpoint.
     *
     * Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#create-a-gpg-key-for-the-authenticated-user>
     */
    pub async fn users_create_gpg_key_for_authenticated(&self, body: &types::UsersCreateGpgKeyAuthenticatedRequest) -> Result<types::GpgKey> {
        let url = "/user/gpg_keys".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a GPG key for the authenticated user.
     *
     * This function performs a `GET` to the `/user/gpg_keys/{gpg_key_id}` endpoint.
     *
     * View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#get-a-gpg-key-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `gpg_key_id: i64` -- gpg_key_id parameter.
     */
    pub async fn users_get_gpg_key_for_authenticated(&self, gpg_key_id: i64) -> Result<types::GpgKey> {
        let url = format!("/user/gpg_keys/{}", progenitor_support::encode_path(&gpg_key_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a GPG key for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/gpg_keys/{gpg_key_id}` endpoint.
     *
     * Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#delete-a-gpg-key-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `gpg_key_id: i64` -- gpg_key_id parameter.
     */
    pub async fn users_delete_gpg_key_for_authenticated(&self, gpg_key_id: i64) -> Result<()> {
        let url = format!("/user/gpg_keys/{}", progenitor_support::encode_path(&gpg_key_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * List app installations accessible to the user access token.
     *
     * This function performs a `GET` to the `/user/installations` endpoint.
     *
     * Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
     *
     * You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     *
     * You can find the permissions for the installation under the `permissions` key.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-app-installations-accessible-to-the-user-access-token>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_installations_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetAppsListInstallationsOkResponse> {
        let url = format!("/user/installations?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get(&url).await
    }

    /**
     * List repositories accessible to the user access token.
     *
     * This function performs a `GET` to the `/user/installations/{installation_id}/repositories` endpoint.
     *
     * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     *
     * You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
     *
     * The access the user has to each repository is included in the hash under the `permissions` key.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-repositories-accessible-to-the-user-access-token>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_installation_repos_for_authenticated_user(
        &self,
        installation_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetAppsListInstallationReposOkResponse> {
        let url = format!(
            "/user/installations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&installation_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
     * Add a repository to an app installation.
     *
     * This function performs a `PUT` to the `/user/installations/{installation_id}/repositories/{repository_id}` endpoint.
     *
     * Add a single repository to an installation. The authenticated user must have admin access to the repository.
     *
     * You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#add-a-repository-to-an-app-installation>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     * * `repository_id: i64`
     */
    pub async fn apps_add_repo_to_installation(&self, installation_id: i64, repository_id: i64) -> Result<()> {
        let url = format!(
            "/user/installations/{}/repositories/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Remove a repository from an app installation.
     *
     * This function performs a `DELETE` to the `/user/installations/{installation_id}/repositories/{repository_id}` endpoint.
     *
     * Remove a single repository from an installation. The authenticated user must have admin access to the repository.
     *
     * You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#remove-a-repository-from-an-app-installation>
     *
     * **Parameters:**
     *
     * * `installation_id: i64` -- installation_id parameter.
     * * `repository_id: i64`
     */
    pub async fn apps_remove_repo_from_installation(&self, installation_id: i64, repository_id: i64) -> Result<()> {
        let url = format!(
            "/user/installations/{}/repositories/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Get interaction restrictions for your public repositories.
     *
     * This function performs a `GET` to the `/user/interaction-limits` endpoint.
     *
     * Shows which type of GitHub user can interact with your public repositories and when the restriction expires.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-your-public-repositories>
     */
    pub async fn interactions_get_restrictions_for_authenticated_user(&self) -> Result<types::InteractionLimitResponse> {
        let url = "/user/interaction-limits".to_string();
        self.get(&url).await
    }

    /**
     * Set interaction restrictions for your public repositories.
     *
     * This function performs a `PUT` to the `/user/interaction-limits` endpoint.
     *
     * Temporarily restricts which type of GitHub user can interact with your public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set for individual repositories owned by the user.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-your-public-repositories>
     */
    pub async fn interactions_set_restrictions_for_authenticated_user(
        &self,
        body: &types::InteractionLimit,
    ) -> Result<types::InteractionLimitResponse> {
        let url = "/user/interaction-limits".to_string();
        self.put(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Remove interaction restrictions from your public repositories.
     *
     * This function performs a `DELETE` to the `/user/interaction-limits` endpoint.
     *
     * Removes any interaction restrictions from your public repositories.
     *
     * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-from-your-public-repositories>
     */
    pub async fn interactions_remove_restrictions_for_authenticated_user(&self) -> Result<()> {
        let url = "/user/interaction-limits".to_string();
        self.delete(&url, None).await
    }

    /**
     * List user account issues assigned to the authenticated user.
     *
     * This function performs a `GET` to the `/user/issues` endpoint.
     *
     * List issues across owned and member repositories assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/issues#list-user-account-issues-assigned-to-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `filter: crate::types::IssuesListFilter` -- Indicates which sorts of issues to return. Can be one of:  
     *  \* `assigned`: Issues assigned to you  
     *  \* `created`: Issues created by you  
     *  \* `mentioned`: Issues mentioning you  
     *  \* `subscribed`: Issues you're subscribed to updates for  
     *  \* `all`: All issues the authenticated user can see, regardless of participation or creation.
     * * `state: crate::types::IssuesListState` -- Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
     * * `labels: &str` -- A list of comma separated label names. Example: `bug,ui,@high`.
     * * `sort: crate::types::IssuesListSort` -- What to sort results by. Can be either `created`, `updated`, `comments`.
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn issues_list_for_authenticated_user(
        &self,
        filter: crate::types::IssuesListFilter,
        state: crate::types::IssuesListState,
        labels: &str,
        sort: crate::types::IssuesListSort,
        direction: crate::types::Direction,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!(
            "/user/issues?direction={}&filter={}&labels={}&page={}&per_page={}&since={}&sort={}&state={}",
            direction,
            filter,
            labels.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * List public SSH keys for the authenticated user.
     *
     * This function performs a `GET` to the `/user/keys` endpoint.
     *
     * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-public-ssh-keys-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_public_ssh_keys_for_authenticated(&self, per_page: i64, page: i64) -> Result<Vec<types::Key>> {
        let url = format!("/user/keys?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Create a public SSH key for the authenticated user.
     *
     * This function performs a `POST` to the `/user/keys` endpoint.
     *
     * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#create-a-public-ssh-key-for-the-authenticated-user>
     */
    pub async fn users_create_public_ssh_key_for_authenticated(
        &self,
        body: &types::UsersCreatePublicSshKeyAuthenticatedRequest,
    ) -> Result<types::Key> {
        let url = "/user/keys".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a public SSH key for the authenticated user.
     *
     * This function performs a `GET` to the `/user/keys/{key_id}` endpoint.
     *
     * View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#get-a-public-ssh-key-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `key_id: i64` -- key_id parameter.
     */
    pub async fn users_get_public_ssh_key_for_authenticated(&self, key_id: i64) -> Result<types::Key> {
        let url = format!("/user/keys/{}", progenitor_support::encode_path(&key_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a public SSH key for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/keys/{key_id}` endpoint.
     *
     * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/users#delete-a-public-ssh-key-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `key_id: i64` -- key_id parameter.
     */
    pub async fn users_delete_public_ssh_key_for_authenticated(&self, key_id: i64) -> Result<()> {
        let url = format!("/user/keys/{}", progenitor_support::encode_path(&key_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * List subscriptions for the authenticated user.
     *
     * This function performs a `GET` to the `/user/marketplace_purchases` endpoint.
     *
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-subscriptions-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_subscriptions_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::UserMarketplacePurchase>> {
        let url = format!(
            "/user/marketplace_purchases?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List subscriptions for the authenticated user (stubbed).
     *
     * This function performs a `GET` to the `/user/marketplace_purchases/stubbed` endpoint.
     *
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/apps#list-subscriptions-for-the-authenticated-user-stubbed>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn apps_list_subscriptions_for_authenticated_user_stubbed(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::UserMarketplacePurchase>> {
        let url = format!(
            "/user/marketplace_purchases/stubbed?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organization memberships for the authenticated user.
     *
     * This function performs a `GET` to the `/user/memberships/orgs` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-memberships-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `state: crate::types::OrgMembershipState` -- Indicates the state of the memberships to return. Can be either `active` or `pending`. If not specified, the API returns both active and pending memberships.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_memberships_for_authenticated_user(
        &self,
        state: crate::types::OrgMembershipState,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrgMembership>> {
        let url = format!(
            "/user/memberships/orgs?page={}&per_page={}&state={}",
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get an organization membership for the authenticated user.
     *
     * This function performs a `GET` to the `/user/memberships/orgs/{org}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization-membership-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_get_membership_for_authenticated_user(&self, org: &str) -> Result<types::OrgMembership> {
        let url = format!("/user/memberships/orgs/{}", progenitor_support::encode_path(&org.to_string()),);

        self.get(&url).await
    }

    /**
     * Update an organization membership for the authenticated user.
     *
     * This function performs a `PATCH` to the `/user/memberships/orgs/{org}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#update-an-organization-membership-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `org: &str`
     */
    pub async fn orgs_update_membership_for_authenticated_user(
        &self,
        org: &str,
        body: &types::OrgsUpdateMembershipRequest,
    ) -> Result<types::OrgMembership> {
        let url = format!("/user/memberships/orgs/{}", progenitor_support::encode_path(&org.to_string()),);

        self.patch(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List user migrations.
     *
     * This function performs a `GET` to the `/user/migrations` endpoint.
     *
     * Lists all migrations a user has started.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#list-user-migrations>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn migrations_list_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::Migration>> {
        let url = format!("/user/migrations?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Start a user migration.
     *
     * This function performs a `POST` to the `/user/migrations` endpoint.
     *
     * Initiates the generation of a user migration archive.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#start-a-user-migration>
     */
    pub async fn migrations_start_for_authenticated_user(&self, body: &types::MigrationsStartRequest) -> Result<types::Migration> {
        let url = "/user/migrations".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * Get a user migration status.
     *
     * This function performs a `GET` to the `/user/migrations/{migration_id}` endpoint.
     *
     * Fetches a single user migration. The response includes the `state` of the migration, which can be one of the following values:
     *
     * *   `pending` - the migration hasn't started yet.
     * *   `exporting` - the migration is in progress.
     * *   `exported` - the migration finished successfully.
     * *   `failed` - the migration failed.
     *
     * Once the migration has been `exported` you can [download the migration archive](https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive).
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#get-a-user-migration-status>
     *
     * **Parameters:**
     *
     * * `migration_id: i64` -- migration_id parameter.
     * * `exclude: &[String]`
     */
    pub async fn migrations_get_status_for_authenticated_user(&self, migration_id: i64, exclude: &[String]) -> Result<types::Migration> {
        let url = format!(
            "/user/migrations/{}?exclude={}",
            progenitor_support::encode_path(&migration_id.to_string()),
            exclude.join(" "),
        );

        self.get(&url).await
    }

    /**
     * Download a user migration archive.
     *
     * This function performs a `GET` to the `/user/migrations/{migration_id}/archive` endpoint.
     *
     * Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources your repository uses, the migration archive can contain JSON files with data for these objects:
     *
     * *   attachments
     * *   bases
     * *   commit\_comments
     * *   issue\_comments
     * *   issue\_events
     * *   issues
     * *   milestones
     * *   organizations
     * *   projects
     * *   protected\_branches
     * *   pull\_request\_reviews
     * *   pull\_requests
     * *   releases
     * *   repositories
     * *   review\_comments
     * *   schema
     * *   users
     *
     * The archive will also contain an `attachments` directory that includes all attachment files uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive>
     *
     * **Parameters:**
     *
     * * `migration_id: i64` -- migration_id parameter.
     */
    pub async fn migrations_get_archive_for_authenticated_user(&self, migration_id: i64) -> Result<()> {
        let url = format!("/user/migrations/{}/archive", progenitor_support::encode_path(&migration_id.to_string()),);

        self.get(&url).await
    }

    /**
     * Delete a user migration archive.
     *
     * This function performs a `DELETE` to the `/user/migrations/{migration_id}/archive` endpoint.
     *
     * Deletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#delete-a-user-migration-archive>
     *
     * **Parameters:**
     *
     * * `migration_id: i64` -- migration_id parameter.
     */
    pub async fn migrations_delete_archive_for_authenticated_user(&self, migration_id: i64) -> Result<()> {
        let url = format!("/user/migrations/{}/archive", progenitor_support::encode_path(&migration_id.to_string()),);

        self.delete(&url, None).await
    }

    /**
     * Unlock a user repository.
     *
     * This function performs a `DELETE` to the `/user/migrations/{migration_id}/repos/{repo_name}/lock` endpoint.
     *
     * Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a status of `404 Not Found` if the repository is not locked.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#unlock-a-user-repository>
     *
     * **Parameters:**
     *
     * * `migration_id: i64` -- migration_id parameter.
     * * `repo_name: &str` -- repo_name parameter.
     */
    pub async fn migrations_unlock_repo_for_authenticated_user(&self, migration_id: i64, repo_name: &str) -> Result<()> {
        let url = format!(
            "/user/migrations/{}/repos/{}/lock",
            progenitor_support::encode_path(&migration_id.to_string()),
            progenitor_support::encode_path(&repo_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repositories for a user migration.
     *
     * This function performs a `GET` to the `/user/migrations/{migration_id}/repositories` endpoint.
     *
     * Lists all the repositories for this user migration.
     *
     * FROM: <https://docs.github.com/rest/reference/migrations#list-repositories-for-a-user-migration>
     *
     * **Parameters:**
     *
     * * `migration_id: i64` -- migration_id parameter.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn migrations_list_repos_for_user(&self, migration_id: i64, per_page: i64, page: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/user/migrations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&migration_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organizations for the authenticated user.
     *
     * This function performs a `GET` to the `/user/orgs` endpoint.
     *
     * List organizations for the authenticated user.
     *
     * **OAuth scope requirements**
     *
     * This only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth requests with insufficient scope receive a `403 Forbidden` response.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!("/user/orgs?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * Get a package for the authenticated user.
     *
     * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}` endpoint.
     *
     * Gets a specific package for a package owned by the authenticated user.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     */
    pub async fn packages_get_package_for_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/user/packages/{}/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a package for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/packages/{package_type}/{package_name}` endpoint.
     *
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     */
    pub async fn packages_delete_package_for_authenticated_user(&self, package_type: crate::types::PackageType, package_name: &str) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Restore a package for the authenticated user.
     *
     * This function performs a `POST` to the `/user/packages/{package_type}/{package_name}/restore` endpoint.
     *
     * Restores a package owned by the authenticated user.
     *
     * You can restore a deleted package under the following conditions:
     *   - The package was deleted within the last 30 days.
     *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `token: &str` -- package token.
     */
    pub async fn packages_restore_package_for_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        token: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/restore?token={}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            token.to_string(),
        );

        self.post(&url, None).await
    }

    /**
     * Get all package versions for a package owned by the authenticated user.
     *
     * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}/versions` endpoint.
     *
     * Returns all package versions for a package owned by the authenticated user.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `page: i64` -- Page number of the results to fetch.
     * * `per_page: i64` -- Results per page (max 100).
     * * `state: crate::types::PackagesGetAllPackageVersionsOwnedByState` -- The state of the package, either active or deleted.
     */
    pub async fn packages_get_all_package_versions_for_package_owned_by_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        page: i64,
        per_page: i64,
        state: crate::types::PackagesGetAllPackageVersionsOwnedByState,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/user/packages/{}/{}/versions?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a package version for the authenticated user.
     *
     * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
     *
     * Gets a specific package version for a package owned by the authenticated user.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_get_package_version_for_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Delete a package version for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
     *
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.
     *
     * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_delete_package_version_for_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Restore a package version for the authenticated user.
     *
     * This function performs a `POST` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore` endpoint.
     *
     * Restores a package version owned by the authenticated user.
     *
     * You can restore a deleted package version under the following conditions:
     *   - The package was deleted within the last 30 days.
     *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `package_version_id: i64` -- Unique identifier of the package version.
     */
    pub async fn packages_restore_package_version_for_authenticated_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}/restore",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
     * Create a user project.
     *
     * This function performs a `POST` to the `/user/projects` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#create-a-user-project>
     */
    pub async fn projects_create_for_authenticated_user(&self, body: &types::ProjectsCreateRequest) -> Result<types::Project> {
        let url = "/user/projects".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List public email addresses for the authenticated user.
     *
     * This function performs a `GET` to the `/user/public_emails` endpoint.
     *
     * Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-public-email-addresses-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_public_emails_for_authenticated(&self, per_page: i64, page: i64) -> Result<Vec<types::Email>> {
        let url = format!("/user/public_emails?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * List repositories for the authenticated user.
     *
     * This function performs a `GET` to the `/user/repos` endpoint.
     *
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repositories-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `visibility: crate::types::ReposListVisibility` -- Can be one of `all`, `public`, or `private`. Note: For GitHub AE, can be one of `all`, `internal`, or `private`.
     * * `affiliation: &str` -- Comma-separated list of values. Can include:  
     *  \* `owner`: Repositories that are owned by the authenticated user.  
     *  \* `collaborator`: Repositories that the user has been added to as a collaborator.  
     *  \* `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
     * * `type_: crate::types::ReposListType` -- Can be one of `all`, `owner`, `public`, `private`, `member`. Note: For GitHub AE, can be one of `all`, `owner`, `internal`, `private`, `member`. Default: `all`  
     *    
     *  Will cause a `422` error if used in the same request as **visibility** or **affiliation**. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
     * * `sort: crate::types::ReposListSort` -- Can be one of `created`, `updated`, `pushed`, `full_name`.
     * * `direction: crate::types::Direction` -- Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `before: DateTime<Utc>` -- Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    pub async fn repos_list_for_authenticated_user(
        &self,
        visibility: crate::types::ReposListVisibility,
        affiliation: &str,
        type_: crate::types::ReposListType,
        sort: crate::types::ReposListSort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
    ) -> Result<Vec<types::Repository>> {
        let url = format!(
            "/user/repos?affiliation={}&before={}&direction={}&page={}&per_page={}&since={}&sort={}&type={}&visibility={}",
            affiliation.to_string(),
            before.to_rfc3339(),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort,
            type_,
            visibility,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Create a repository for the authenticated user.
     *
     * This function performs a `POST` to the `/user/repos` endpoint.
     *
     * Creates a new repository for the authenticated user.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user>
     */
    pub async fn repos_create_for_authenticated_user(&self, body: &types::ReposCreateRequest) -> Result<types::Repository> {
        let url = "/user/repos".to_string();
        self.post(&url, Some(reqwest::Body::from(serde_json::to_vec(body).unwrap()))).await
    }

    /**
     * List repository invitations for the authenticated user.
     *
     * This function performs a `GET` to the `/user/repository_invitations` endpoint.
     *
     * When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repository-invitations-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_invitations_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::RepositoryInvitation>> {
        let url = format!(
            "/user/repository_invitations?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Decline a repository invitation.
     *
     * This function performs a `DELETE` to the `/user/repository_invitations/{invitation_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#decline-a-repository-invitation>
     *
     * **Parameters:**
     *
     * * `invitation_id: i64` -- invitation_id parameter.
     */
    pub async fn repos_decline_invitation(&self, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/user/repository_invitations/{}",
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * Accept a repository invitation.
     *
     * This function performs a `PATCH` to the `/user/repository_invitations/{invitation_id}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/repos#accept-a-repository-invitation>
     *
     * **Parameters:**
     *
     * * `invitation_id: i64` -- invitation_id parameter.
     */
    pub async fn repos_accept_invitation(&self, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/user/repository_invitations/{}",
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.patch(&url, None).await
    }

    /**
     * List repositories starred by the authenticated user.
     *
     * This function performs a `GET` to the `/user/starred` endpoint.
     *
     * Lists repositories the authenticated user has starred.
     *
     * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-starred-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_repos_starred_by_authenticated_user(
        &self,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Repository>> {
        let url = format!(
            "/user/starred?direction={}&page={}&per_page={}&sort={}",
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check if a repository is starred by the authenticated user.
     *
     * This function performs a `GET` to the `/user/starred/{owner}/{repo}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#check-if-a-repository-is-starred-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_check_repo_is_starred_by_authenticated_user(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Star a repository for the authenticated user.
     *
     * This function performs a `PUT` to the `/user/starred/{owner}/{repo}` endpoint.
     *
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * FROM: <https://docs.github.com/rest/reference/activity#star-a-repository-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_star_repo_for_authenticated_user(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
     * Unstar a repository for the authenticated user.
     *
     * This function performs a `DELETE` to the `/user/starred/{owner}/{repo}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#unstar-a-repository-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `owner: &str`
     * * `repo: &str`
     */
    pub async fn activity_unstar_repo_for_authenticated_user(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
     * List repositories watched by the authenticated user.
     *
     * This function performs a `GET` to the `/user/subscriptions` endpoint.
     *
     * Lists repositories the authenticated user is watching.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-watched-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_watched_repos_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!("/user/subscriptions?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * List teams for the authenticated user.
     *
     * This function performs a `GET` to the `/user/teams` endpoint.
     *
     * List all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/apps/building-oauth-apps/).
     *
     * FROM: <https://docs.github.com/rest/reference/teams#list-teams-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn teams_list_for_authenticated_user(&self, per_page: i64, page: i64) -> Result<Vec<types::TeamFull>> {
        let url = format!("/user/teams?page={}&per_page={}", format!("{}", page), format!("{}", per_page),);

        self.get_all_pages(&url).await
    }

    /**
     * List users.
     *
     * This function performs a `GET` to the `/users` endpoint.
     *
     * Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
     *
     * Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-users>
     *
     * **Parameters:**
     *
     * * `since: i64` -- A user ID. Only return users with an ID greater than this ID.
     * * `per_page: i64` -- Results per page (max 100).
     */
    pub async fn users_list(&self, since: i64, per_page: i64) -> Result<Vec<types::User>> {
        let url = format!("/users?per_page={}&since={}", format!("{}", per_page), format!("{}", since),);

        self.get_all_pages(&url).await
    }

    /**
     * Get a user.
     *
     * This function performs a `GET` to the `/users/{username}` endpoint.
     *
     * Provides publicly available information about someone with a GitHub account.
     *
     * GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub plan information' below"
     *
     * The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
     *
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/reference/users#emails)".
     *
     * FROM: <https://docs.github.com/rest/reference/users#get-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn users_get_by_username(&self, username: &str) -> Result<types::PrivateUser> {
        let url = format!("/users/{}", progenitor_support::encode_path(&username.to_string()),);

        self.get(&url).await
    }

    /**
     * List events for the authenticated user.
     *
     * This function performs a `GET` to the `/users/{username}/events` endpoint.
     *
     * If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-events-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_events_for_authenticated_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organization events for the authenticated user.
     *
     * This function performs a `GET` to the `/users/{username}/events/orgs/{org}` endpoint.
     *
     * This is the user's organization dashboard. You must be authenticated as the user to view this.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-organization-events-for-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `org: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_org_events_for_authenticated_user(
        &self,
        username: &str,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events/orgs/{}?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List public events for a user.
     *
     * This function performs a `GET` to the `/users/{username}/events/public` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_public_events_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events/public?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List followers of a user.
     *
     * This function performs a `GET` to the `/users/{username}/followers` endpoint.
     *
     * Lists the people following the specified user.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-followers-of-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_followers_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/users/{}/followers?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List the people a user follows.
     *
     * This function performs a `GET` to the `/users/{username}/following` endpoint.
     *
     * Lists the people who the specified user follows.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-the-people-a-user-follows>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_following_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::User>> {
        let url = format!(
            "/users/{}/following?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Check if a user follows another user.
     *
     * This function performs a `GET` to the `/users/{username}/following/{target_user}` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/users#check-if-a-user-follows-another-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `target_user: &str`
     */
    pub async fn users_check_following_for_user(&self, username: &str, target_user: &str) -> Result<()> {
        let url = format!(
            "/users/{}/following/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&target_user.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List gists for a user.
     *
     * This function performs a `GET` to the `/users/{username}/gists` endpoint.
     *
     * Lists public gists for the specified user:
     *
     * FROM: <https://docs.github.com/rest/reference/gists#list-gists-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `since: DateTime<Utc>` -- Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn gists_list_for_user(&self, username: &str, since: DateTime<Utc>, per_page: i64, page: i64) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/users/{}/gists?page={}&per_page={}&since={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List GPG keys for a user.
     *
     * This function performs a `GET` to the `/users/{username}/gpg_keys` endpoint.
     *
     * Lists the GPG keys for a user. This information is accessible by anyone.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-gpg-keys-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_gpg_keys_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::GpgKey>> {
        let url = format!(
            "/users/{}/gpg_keys?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get contextual information for a user.
     *
     * This function performs a `GET` to the `/users/{username}/hovercard` endpoint.
     *
     * Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
     *
     * The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
     *
     * ```shell
     *  curl -u username:token
     *   https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
     * ```
     *
     * FROM: <https://docs.github.com/rest/reference/users#get-contextual-information-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `subject_type: crate::types::UsersGetContextUserSubjectType` -- Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
     * * `subject_id: &str` -- Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
     */
    pub async fn users_get_context_for_user(
        &self,
        username: &str,
        subject_type: crate::types::UsersGetContextUserSubjectType,
        subject_id: &str,
    ) -> Result<types::Hovercard> {
        let url = format!(
            "/users/{}/hovercard?subject_id={}&subject_type={}",
            progenitor_support::encode_path(&username.to_string()),
            subject_id.to_string(),
            subject_type,
        );

        self.get(&url).await
    }

    /**
     * Get a user installation for the authenticated app.
     *
     * This function performs a `GET` to the `/users/{username}/installation` endpoint.
     *
     * Enables an authenticated GitHub App to find the users installation information.
     *
     * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     *
     * FROM: <https://docs.github.com/rest/reference/apps#get-a-user-installation-for-the-authenticated-app>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn apps_get_user_installation(&self, username: &str) -> Result<types::Installation> {
        let url = format!("/users/{}/installation", progenitor_support::encode_path(&username.to_string()),);

        self.get(&url).await
    }

    /**
     * List public keys for a user.
     *
     * This function performs a `GET` to the `/users/{username}/keys` endpoint.
     *
     * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
     *
     * FROM: <https://docs.github.com/rest/reference/users#list-public-keys-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn users_list_public_keys_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::KeySimple>> {
        let url = format!(
            "/users/{}/keys?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List organizations for a user.
     *
     * This function performs a `GET` to the `/users/{username}/orgs` endpoint.
     *
     * List [public organization memberships](https://help.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.
     *
     * This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
     *
     * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn orgs_list_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!(
            "/users/{}/orgs?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a package for a user.
     *
     * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}` endpoint.
     *
     * Gets a specific package metadata for a public package owned by a user.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-a-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `username: &str`
     */
    pub async fn packages_get_package_for_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        username: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/users/{}/packages/{}/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get all package versions for a package owned by a user.
     *
     * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}/versions` endpoint.
     *
     * Returns all package versions for a public package owned by a specified user.
     *
     * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-a-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `username: &str`
     */
    pub async fn packages_get_all_package_versions_for_package_owned_by_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        username: &str,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/users/{}/packages/{}/{}/versions",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get a package version for a user.
     *
     * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
     *
     * Gets a specific package version for a public package owned by a specified user.
     *
     * At this time, to use this endpoint, you must authenticate using an access token with the `packages:read` scope.
     * If `package_type` is not `container`, your token must also include the `repo` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user>
     *
     * **Parameters:**
     *
     * * `package_type: crate::types::PackageType` -- The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
     * * `package_name: &str` -- The name of the package.
     * * `package_version_id: i64` -- Unique identifier of the package version.
     * * `username: &str`
     */
    pub async fn packages_get_package_version_for_user(
        &self,
        package_type: crate::types::PackageType,
        package_name: &str,
        package_version_id: i64,
        username: &str,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/users/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List user projects.
     *
     * This function performs a `GET` to the `/users/{username}/projects` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/projects#list-user-projects>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `state: crate::types::IssuesListState` -- Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn projects_list_for_user(
        &self,
        username: &str,
        state: crate::types::IssuesListState,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/users/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state,
        );

        self.get_all_pages(&url).await
    }

    /**
     * List events received by the authenticated user.
     *
     * This function performs a `GET` to the `/users/{username}/received_events` endpoint.
     *
     * These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-events-received-by-the-authenticated-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_received_events_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/received_events?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List public events received by a user.
     *
     * This function performs a `GET` to the `/users/{username}/received_events/public` endpoint.
     *
     *
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-received-by-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_received_public_events_for_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/received_events/public?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * List repositories for a user.
     *
     * This function performs a `GET` to the `/users/{username}/repos` endpoint.
     *
     * Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user.
     *
     * FROM: <https://docs.github.com/rest/reference/repos#list-repositories-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `type_: crate::types::ReposListUserType` -- Can be one of `all`, `owner`, `member`.
     * * `sort: crate::types::ReposListSort` -- Can be one of `created`, `updated`, `pushed`, `full_name`.
     * * `direction: crate::types::Direction` -- Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc`.
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn repos_list_for_user(
        &self,
        username: &str,
        type_: crate::types::ReposListUserType,
        sort: crate::types::ReposListSort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/users/{}/repos?direction={}&page={}&per_page={}&sort={}&type={}",
            progenitor_support::encode_path(&username.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
            type_,
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get GitHub Actions billing for a user.
     *
     * This function performs a `GET` to the `/users/{username}/settings/billing/actions` endpoint.
     *
     * Gets the summary of the free and paid GitHub Actions minutes used.
     *
     * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     *
     * Access tokens must have the `user` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn billing_get_github_actions_billing_user(&self, username: &str) -> Result<types::ActionsBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/actions",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get GitHub Packages billing for a user.
     *
     * This function performs a `GET` to the `/users/{username}/settings/billing/packages` endpoint.
     *
     * Gets the free and paid storage used for GitHub Packages in gigabytes.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * Access tokens must have the `user` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn billing_get_github_packages_billing_user(&self, username: &str) -> Result<types::PackagesBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/packages",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * Get shared storage billing for a user.
     *
     * This function performs a `GET` to the `/users/{username}/settings/billing/shared-storage` endpoint.
     *
     * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
     *
     * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
     *
     * Access tokens must have the `user` scope.
     *
     * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     */
    pub async fn billing_get_shared_storage_billing_user(&self, username: &str) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
     * List repositories starred by a user.
     *
     * This function performs a `GET` to the `/users/{username}/starred` endpoint.
     *
     * Lists repositories a user has starred.
     *
     * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-starred-by-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `sort: crate::types::Sort` -- One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
     * * `direction: crate::types::Direction` -- One of `asc` (ascending) or `desc` (descending).
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_repos_starred_by_user(
        &self,
        username: &str,
        sort: crate::types::Sort,
        direction: crate::types::Direction,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::StarredRepository>> {
        let url = format!(
            "/users/{}/starred?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&username.to_string()),
            direction,
            format!("{}", page),
            format!("{}", per_page),
            sort,
        );

        self.get_all_pages(&url).await
    }

    /**
     * List repositories watched by a user.
     *
     * This function performs a `GET` to the `/users/{username}/subscriptions` endpoint.
     *
     * Lists repositories a user is watching.
     *
     * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-watched-by-a-user>
     *
     * **Parameters:**
     *
     * * `username: &str`
     * * `per_page: i64` -- Results per page (max 100).
     * * `page: i64` -- Page number of the results to fetch.
     */
    pub async fn activity_list_repos_watched_by_user(&self, username: &str, per_page: i64, page: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/users/{}/subscriptions?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
     * Get the Zen of GitHub.
     *
     * This function performs a `GET` to the `/zen` endpoint.
     *
     * Get a random sentence from the Zen of GitHub
     */
    pub async fn meta_get_zen(&self) -> Result<String> {
        let url = "/zen".to_string();
        self.get(&url).await
    }
}
